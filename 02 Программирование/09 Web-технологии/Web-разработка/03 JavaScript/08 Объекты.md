Объекты представляют собой наборы ключ-значение, элементом набора является общедоступное свойство. Таким образом даже свойство `Array.length` является доступным для изменения

```javascript
// Литерал объекта
let obj = {};

let user = {     // объект
    name: "John",  // под ключом "name" хранится значение "John"
    age: 30        // под ключом "age" хранится значение 30
    "likes birds": true
    sayHi: function() { alert('hi'); }
    // OR
    sayHi() { alert('hi'); }
};

// третье слово состоит из двух слов, поэтому заключено в
// кавычки
// уникальный способ обращения к свойствам
user["likes birds"] = false;

// Можно удалить определенное свойство
delete user.age;
```

## Аксессоры

Геттеры и сеттеры:
```javascript
let obj = {
    get propName() {
        // геттер, срабатывает при чтении obj.propName
    },
    set propName(value) {
        // сеттер, срабатывает при записи obj.propName = value
    }
};
```

Вставка аксессора в объект:

```javascript
let user = {
    name: 'Dan'
    surname: 'Stone'
}

Object.defineProperty(user, 'fullName', {
    get() {
        return `${this.name} ${this.surname}`;
    },
    
    set(value) {
        [this.name, this.surname] = value.split(" ");
    }
});
```

Вычисляемое в Runtime свойство:

```javascript
let fruit = askForFruit();

let bag = {
    [fruit]: 5
}

// Аналогично
let bag = {};
// имя свойства будет взято из переменной fruit
bag[fruit] = 5;
```

Можно создать объект с любыми именами свойств, вычисляемыми в Runtime:

```javascript
function makeUser(name, age) {
    return {
        name: name,
        age: age
        // ...другие свойства
    };
}
```

```javascript
let user = {
    name,  // тоже самое, что и name:name
    age: 30
};
```

Также допустимы следующие имена свойств:

```javascript
let obj = {
    for: 1,
    let: 2,
    return: 3
    0: 0 // свойство как индекс
};

obj[0] = 2;
obj['0'] = 2; // аналогичный вариант
```

> В JavaScript можно получить доступ к любому свойству, даже если этого свойства **не существует**. Несуществующее свойство равно `undefined`

Поэтому возможно следующее:

```javascript
let arr = []
arr[99999] = 6;
arr.color = 'indigo';
```

### Оператор in

Позволяет проверить наличие свойства в объекте.

```javascript
"key" in dict // true

let prop = 'dim' + 2;
prop in obj // вычисляемое имя свойства
```

Оператор `in` лучше, чем сравнение с `undefined`, так как некоторые существующие свойства могут быть равны `undefined`. Оператор `in` корректно определяет существование свойства.

При переборе объекта в цикле через оператор `in`, свойства сортируются в порядке добавления, кроме чисел, они сортируются в порядке возрастания.

## Оператор this

`this` — это ссылка не текущий объект. Используется в методах

```javascript
let user = {
    name: "John",
    age: 30,
    
    sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
    }
};
```

Отличается от реализации в других языках программирования. `this` является контекстно-зависимым и вычисляется в Runtime.

```javascript
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
    alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f']();
```

## Константные объекты

Можно создавать константы-объекты, но константной будет лишь ссылка, а данные на которые указывает эта ссылка не будут константными

[[07 Копирование объектов|Копирование объектов]]

#JavaScript
