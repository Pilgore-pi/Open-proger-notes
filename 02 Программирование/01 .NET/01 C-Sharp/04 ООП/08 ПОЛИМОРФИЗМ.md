
Назад: [[07 ИНКАПСУЛЯЦИЯ|Инкапсуляция]]
Далее: [[09 Отношения классов|Отношения классов]]

Полиморфизм — один из трёх столпов объектно-ориентированного программирования, который позволяет использовать объекты разных типов через единый интерфейс, обеспечивая гибкость и расширяемость кода.

> **Полиморфизм** — это способность объектов с одинаковым интерфейсом иметь различную реализацию, позволяя обрабатывать объекты разных типов единообразно

Полиморфизм решает три основные задачи:

- **Унификация интерфейса** — возможность работать с разными типами через общий интерфейс
- **Расширяемость кода** — добавление новых типов без изменения существующего кода
- **Переиспользование кода** — написание универсальных алгоритмов для различных типов данных

## Виды полиморфизма

В C# существует три основных вида полиморфизма:

### 1 Ad-hoc полиморфизм (Специальный полиморфизм)

Ad-hoc полиморфизм достигается через **перегрузку методов** и **перегрузку операторов**. Это полиморфизм времени компиляции

> **Ad-hoc полиморфизм** — возможность использовать одно имя для различных реализаций, выбор которых происходит на основе типов и количества параметров

#### Перегрузка методов

```csharp
public class Calculator {
    // Перегрузка метода Add для разных типов
    public int Add(int a, int b) {
        Console.WriteLine("Adding integers");
        return a + b;
    }
    
    public double Add(double a, double b) {
        Console.WriteLine("Adding doubles");
        return a + b;
    }
    
    public string Add(string a, string b) {
        Console.WriteLine("Concatenating strings");
        return a + b;
    }
    
    // Перегрузка по количеству параметров
    public int Add(int a, int b, int c) {
        Console.WriteLine("Adding three integers");
        return a + b + c;
    }
}
```

```csharp
var calc = new Calculator();

int result1 = calc.Add(5, 3);           // "Adding integers" -> 8
double result2 = calc.Add(5.5, 3.2);    // "Adding doubles" -> 8.7
string result3 = calc.Add("Hello", " World");  // "Concatenating strings" -> "Hello World"
int result4 = calc.Add(1, 2, 3);        // "Adding three integers" -> 6
```

#### Перегрузка операторов

[[12 Перегрузка операторов|Подробнее о перегрузке операторов]]

```csharp
public class Vector2D {
    public double X { get; set; }
    public double Y { get; set; }
    
    public Vector2D(double x, double y) {
        X = x;
        Y = y;
    }
    
    // Перегрузка оператора сложения
    public static Vector2D operator +(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X + v2.X, v1.Y + v2.Y);
    }
    
    // Перегрузка оператора умножения на скаляр
    public static Vector2D operator *(Vector2D v, double scalar) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Перегрузка оператора равенства
    public static bool operator ==(Vector2D v1, Vector2D v2) {
        if (ReferenceEquals(v1, v2)) return true;
        if (v1 is null || v2 is null) return false;
        return v1.X == v2.X && v1.Y == v2.Y;
    }
    
    public static bool operator !=(Vector2D v1, Vector2D v2) {
        return !(v1 == v2);
    }
    
    public override string ToString() => $"({X}, {Y})";
}
```

```csharp
var v1 = new Vector2D(3, 4);
var v2 = new Vector2D(1, 2);

var v3 = v1 + v2;           // (4, 6)
var v4 = v1 * 2;            // (6, 8)
bool equal = v1 == v2;      // false

Console.WriteLine($"v1 + v2 = {v3}");
Console.WriteLine($"v1 * 2 = {v4}");
```

#### Перегрузка конструкторов

```csharp
public class Person {
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
    
    // Конструктор по умолчанию
    public Person() {
        Name = "Unknown";
        Age = 0;
    }
    
    // Конструктор с одним параметром
    public Person(string name) {
        Name = name;
        Age = 0;
    }
    
    // Конструктор с двумя параметрами
    public Person(string name, int age) {
        Name = name;
        Age = age;
    }
    
    // Конструктор с тремя параметрами
    public Person(string name, int age, string email) : this(name, age) {
        Email = email;
    }
}
```

```csharp
var person1 = new Person();                          // Unknown, 0
var person2 = new Person("Alice");                   // Alice, 0
var person3 = new Person("Bob", 30);                 // Bob, 30
var person4 = new Person("Charlie", 25, "c@mail.com"); // Charlie, 25, c@mail.com
```

### 2 Полиморфизм подтипов (Subtype Polymorphism)

Полиморфизм подтипов — это классический ООП полиморфизм, основанный на наследовании и переопределении методов. Это полиморфизм **времени выполнения**

> **Полиморфизм подтипов** — возможность использовать объекты производных классов через ссылки на базовый класс или интерфейс

#### Полиморфизм через наследование классов

```csharp
public abstract class Animal {
    public string Name { get; set; }
    
    // Абстрактный метод — должен быть реализован в производных классах
    public abstract void MakeSound();
    
    // Виртуальный метод — может быть переопределён
    public virtual void Move() {
        Console.WriteLine($"{Name} is moving");
    }
    
    // Обычный метод — наследуется без изменений
    public void Sleep() {
        Console.WriteLine($"{Name} is sleeping");
    }
}

public class Dog : Animal {
    public override void MakeSound() {
        Console.WriteLine($"{Name} says: Woof! Woof!");
    }
    
    public override void Move() {
        Console.WriteLine($"{Name} is running on four legs");
    }
}

public class Cat : Animal {
    public override void MakeSound() {
        Console.WriteLine($"{Name} says: Meow!");
    }
    
    // Move() не переопределён — используется реализация из Animal
}

public class Bird : Animal {
    public override void MakeSound() {
        Console.WriteLine($"{Name} says: Tweet! Tweet!");
    }
    
    public override void Move() {
        Console.WriteLine($"{Name} is flying");
    }
}
```

```csharp
// Полиморфное использование через базовый класс
Animal[] animals = new Animal[] {
    new Dog { Name = "Rex" },
    new Cat { Name = "Whiskers" },
    new Bird { Name = "Tweety" }
};

foreach (Animal animal in animals) {
    animal.MakeSound();  // Вызывается соответствующая реализация
    animal.Move();
    animal.Sleep();      // Одинаковая реализация для всех
    Console.WriteLine();
}

// Вывод:
// Rex says: Woof! Woof!
// Rex is running on four legs
// Rex is sleeping
//
// Whiskers says: Meow!
// Whiskers is moving
// Whiskers is sleeping
//
// Tweety says: Tweet! Tweet!
// Tweety is flying
// Tweety is sleeping
```

#### Полиморфизм через интерфейсы

```csharp
public interface IPaymentMethod {
    string Name { get; }
    bool ProcessPayment(decimal amount);
    void RefundPayment(decimal amount);
}

public class CreditCard : IPaymentMethod {
    public string Name => "Credit Card";
    public string CardNumber { get; set; }
    
    public bool ProcessPayment(decimal amount) {
        Console.WriteLine($"Processing ${amount} via Credit Card {CardNumber}");
        // Логика обработки платежа
        return true;
    }
    
    public void RefundPayment(decimal amount) {
        Console.WriteLine($"Refunding ${amount} to Credit Card {CardNumber}");
    }
}

public class PayPal : IPaymentMethod {
    public string Name => "PayPal";
    public string Email { get; set; }
    
    public bool ProcessPayment(decimal amount) {
        Console.WriteLine($"Processing ${amount} via PayPal account {Email}");
        return true;
    }
    
    public void RefundPayment(decimal amount) {
        Console.WriteLine($"Refunding ${amount} to PayPal account {Email}");
    }
}

public class Cryptocurrency : IPaymentMethod {
    public string Name => "Cryptocurrency";
    public string WalletAddress { get; set; }
    
    public bool ProcessPayment(decimal amount) {
        Console.WriteLine($"Processing ${amount} via Crypto wallet {WalletAddress}");
        return true;
    }
    
    public void RefundPayment(decimal amount) {
        Console.WriteLine($"Refunding ${amount} to Crypto wallet {WalletAddress}");
    }
}
```

```csharp
public class PaymentProcessor {
    // Метод работает с любой реализацией IPaymentMethod
    public void ExecutePayment(IPaymentMethod paymentMethod, decimal amount) {
        Console.WriteLine($"Using payment method: {paymentMethod.Name}");
        
        if (paymentMethod.ProcessPayment(amount)) {
            Console.WriteLine("Payment successful!");
        } else {
            Console.WriteLine("Payment failed!");
        }
    }
}
```

```csharp
var processor = new PaymentProcessor();

IPaymentMethod[] paymentMethods = new IPaymentMethod[] {
    new CreditCard { CardNumber = "**** 1234" },
    new PayPal { Email = "user@example.com" },
    new Cryptocurrency { WalletAddress = "0x742d35Cc..." }
};

foreach (var method in paymentMethods) {
    processor.ExecutePayment(method, 99.99m);
    Console.WriteLine();
}
```

#### Множественная реализация интерфейсов

```csharp
public interface IDrawable {
    void Draw();
}

public interface IResizable {
    void Resize(double scale);
}

public interface IRotatable {
    void Rotate(double angle);
}

public class Image : IDrawable, IResizable, IRotatable {
    
    public string Path { get; set; }
    public double Width { get; set; }
    public double Height { get; set; }
    
    public void Draw() {
        Console.WriteLine($"Drawing image from {Path}");
    }
    
    public void Resize(double scale) {
        Width *= scale;
        Height *= scale;
        Console.WriteLine($"Resized to {Width}x{Height}");
    }
    
    public void Rotate(double angle) {
        Console.WriteLine($"Rotated by {angle} degrees");
    }
}
```

```csharp
var image = new Image { Path = "photo.jpg", Width = 800, Height = 600 };

// Полиморфное использование через разные интерфейсы
IDrawable drawable = image;
drawable.Draw();

IResizable resizable = image;
resizable.Resize(0.5);

IRotatable rotatable = image;
rotatable.Rotate(90);
```

#### Ковариантность и контравариантность

```csharp
// Ковариантность (out) — можно возвращать более конкретный тип
public interface IAnimalFactory<out T> where T : Animal {
    T CreateAnimal();
}

public class DogFactory : IAnimalFactory<Dog> {
    public Dog CreateAnimal() {
        return new Dog { Name = "New Dog" };
    }
}

// Контравариантность (in) — можно принимать более общий тип
public interface IAnimalFeeder<in T> where T : Animal {
    void Feed(T animal);
}

public class AnimalFeeder : IAnimalFeeder<Animal> {
    public void Feed(Animal animal) {
        Console.WriteLine($"Feeding {animal.Name}");
    }
}
```

```csharp
// Ковариантность: DogFactory можно использовать как IAnimalFactory<Animal>
IAnimalFactory<Animal> factory = new DogFactory();
Animal animal = factory.CreateAnimal();

// Контравариантность: AnimalFeeder можно использовать как IAnimalFeeder<Dog>
IAnimalFeeder<Dog> feeder = new AnimalFeeder();
feeder.Feed(new Dog { Name = "Rex" });
```

### 3 Параметрический полиморфизм (Parametric Polymorphism)

Параметрический полиморфизм реализуется через **обобщения (generics)**, позволяя писать код, который работает с любыми типами данных

> **Параметрический полиморфизм** — возможность определять алгоритмы и структуры данных, не зависящие от конкретных типов

#### Обобщённые классы

[[01 Обобщения|Подробнее об обобщенных типах]]

```csharp
public class Box<T> {
    private T content;
    
    public void Pack(T item) {
        content = item;
        Console.WriteLine($"Packed: {item}");
    }
    
    public T Unpack() {
        Console.WriteLine($"Unpacked: {content}");
        return content;
    }
    
    public bool IsEmpty() => content == null;
}
```

```csharp
// Box может работать с любым типом
var intBox = new Box<int>();
intBox.Pack(42);
int number = intBox.Unpack();

var stringBox = new Box<string>();
stringBox.Pack("Hello");
string text = stringBox.Unpack();

var personBox = new Box<Person>();
personBox.Pack(new Person("Alice", 30));
Person person = personBox.Unpack();
```

#### Обобщённые методы

```csharp
public class ArrayHelper {
    // Обобщённый метод для вывода массива любого типа
    public static void PrintArray<T>(T[] array) {
        Console.Write("[");
        for (int i = 0; i < array.Length; i++) {
            Console.Write(array[i]);
            if (i < array.Length - 1) Console.Write(", ");
        }
        Console.WriteLine("]");
    }
    
    // Обобщённый метод для поиска элемента
    public static int FindIndex<T>(T[] array, T item) where T : IEquatable<T> {
        for (int i = 0; i < array.Length; i++) {
            if (array[i].Equals(item)) return i;
        }
        return -1;
    }
    
    // Обобщённый метод для обмена элементов
    public static void Swap<T>(ref T a, ref T b) {
        T temp = a;
        a = b;
        b = temp;
    }
}
```

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };
ArrayHelper.PrintArray(numbers);  // [1, 2, 3, 4, 5]

string[] words = { "apple", "banana", "cherry" };
ArrayHelper.PrintArray(words);    // [apple, banana, cherry]

int index = ArrayHelper.FindIndex(numbers, 3);  // 2

int x = 10, y = 20;
ArrayHelper.Swap(ref x, ref y);
Console.WriteLine($"x = {x}, y = {y}");  // x = 20, y = 10
```

#### Ограничения обобщений (Generic Constraints)

```csharp
// where T : class — T должен быть ссылочным типом
public class Repository<T> where T : class {
    private List<T> items = new List<T>();
    
    public void Add(T item) {
        if (item != null) {
            items.Add(item);
        }
    }
    
    public T GetById(int id) => items.ElementAtOrDefault(id);
}

// where T : struct — T должен быть значимым типом
public class Calculator<T> where T : struct {
    public T Add(T a, T b) {
        dynamic x = a;
        dynamic y = b;
        return x + y;
    }
}

// where T : new() — T должен иметь конструктор без параметров
public class Factory<T> where T : new() {
    public T Create() {
        return new T();
    }
    
    public List<T> CreateMany(int count) {
        var list = new List<T>();
        for (int i = 0; i < count; i++) {
            list.Add(new T());
        }
        return list;
    }
}

// where T : BaseClass — T должен наследоваться от BaseClass
public class AnimalShelter<T> where T : Animal {
    private List<T> animals = new List<T>();
    
    public void AddAnimal(T animal) {
        animals.Add(animal);
        animal.Sleep();  // Можем вызывать методы Animal
    }
    
    public void MakeAllSounds() {
        foreach (var animal in animals) {
            animal.MakeSound();
        }
    }
}

// where T : IInterface — T должен реализовывать IInterface
public class Sorter<T> where T : IComparable<T> {
    public void Sort(List<T> list) {
        list.Sort();
    }
}

// Множественные ограничения
public class AdvancedRepository<T> where T : class, IEntity, new() {
    private Dictionary<int, T> storage = new Dictionary<int, T>();
    
    public void Add(T entity) {
        storage[entity.Id] = entity;
    }
    
    public T GetOrCreate(int id) {
        if (!storage.ContainsKey(id)) {
            var entity = new T();
            entity.Id = id;
            storage[id] = entity;
        }
        return storage[id];
    }
}

public interface IEntity {
    int Id { get; set; }
}
```

```csharp
// Использование с ограничениями
var dogShelter = new AnimalShelter<Dog>();
dogShelter.AddAnimal(new Dog { Name = "Rex" });

var factory = new Factory<Person>();
Person newPerson = factory.Create();

var numbers = new List<int> { 5, 2, 8, 1, 9 };
var sorter = new Sorter<int>();
sorter.Sort(numbers);
ArrayHelper.PrintArray(numbers.ToArray());  // [1, 2, 5, 8, 9]
```

#### Обобщённые интерфейсы и делегаты

```csharp
// Обобщённый интерфейс
public interface IRepository<T> where T : class {
    void Add(T item);
    T GetById(int id);
    IEnumerable<T> GetAll();
    void Delete(T item);
}

public class PersonRepository : IRepository<Person> {
    private List<Person> persons = new List<Person>();
    
    public void Add(Person item) => persons.Add(item);
    
    public Person GetById(int id) => persons.ElementAtOrDefault(id);
    
    public IEnumerable<Person> GetAll() => persons;
    
    public void Delete(Person item) => persons.Remove(item);
}

// Обобщённые делегаты
public delegate T Operation<T>(T a, T b);

public class MathOperations {
    public static int Add(int a, int b) => a + b;
    public static double Add(double a, double b) => a + b;
    
    public static T ExecuteOperation<T>(T a, T b, Operation<T> operation) {
        Console.WriteLine($"Executing operation on {a} and {b}");
        return operation(a, b);
    }
}
```

```csharp
// Использование обобщённых делегатов
Operation<int> intOp = MathOperations.Add;
int result1 = MathOperations.ExecuteOperation(5, 3, intOp);  // 8

Operation<double> doubleOp = MathOperations.Add;
double result2 = MathOperations.ExecuteOperation(5.5, 3.2, doubleOp);  // 8.7

// Встроенные обобщённые делегаты
Func<int, int, int> addFunc = (a, b) => a + b;
Action<string> printAction = message => Console.WriteLine(message);
Predicate<int> isEven = number => number % 2 == 0;
```

## Практические примеры полиморфизма

### Пример 1: Система обработки документов

```csharp
public interface IDocument {
    string Name { get; }
    void Open();
    void Save();
    void Close();
}

public class TextDocument : IDocument {
    public string Name { get; set; }
    private string content;
    
    public void Open() {
        Console.WriteLine($"Opening text document: {Name}");
        content = File.ReadAllText(Name);
    }
    
    public void Save() {
        Console.WriteLine($"Saving text document: {Name}");
        File.WriteAllText(Name, content);
    }
    
    public void Close() {
        Console.WriteLine($"Closing text document: {Name}");
        content = null;
    }
}

public class PdfDocument : IDocument {
    public string Name { get; set; }
    
    public void Open() {
        Console.WriteLine($"Opening PDF document: {Name}");
        // Логика открытия PDF
    }
    
    public void Save() {
        Console.WriteLine($"Saving PDF document: {Name}");
        // Логика сохранения PDF
    }
    
    public void Close() {
        Console.WriteLine($"Closing PDF document: {Name}");
        // Логика закрытия PDF
    }
}

public class DocumentManager {
    private List<IDocument> openDocuments = new List<IDocument>();
    
    public void OpenDocument(IDocument document) {
        document.Open();
        openDocuments.Add(document);
    }
    
    public void SaveAll() {
        foreach (var doc in openDocuments) {
            doc.Save();
        }
    }
    
    public void CloseAll() {
        foreach (var doc in openDocuments) {
            doc.Close();
        }
        openDocuments.Clear();
    }
}
```

### Пример 2: Обобщённая коллекция с фильтрацией

```csharp
public class SmartCollection<T> {
    private List<T> items = new List<T>();
    
    public void Add(T item) => items.Add(item);
    
    public void AddRange(IEnumerable<T> collection) => items.AddRange(collection);
    
    // Обобщённый метод фильтрации
    public SmartCollection<T> Where(Func<T, bool> predicate) {
        var result = new SmartCollection<T>();
        foreach (var item in items) {
            if (predicate(item)) {
                result.Add(item);
            }
        }
        return result;
    }
    
    // Обобщённый метод преобразования
    public SmartCollection<TResult> Select<TResult>(Func<T, TResult> selector) {
        var result = new SmartCollection<TResult>();
        foreach (var item in items) {
            result.Add(selector(item));
        }
        return result;
    }
    
    public void ForEach(Action<T> action) {
        foreach (var item in items) {
            action(item);
        }
    }
    
    public List<T> ToList() => new List<T>(items);
}
```

```csharp
var numbers = new SmartCollection<int>();
numbers.AddRange(new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });

// Фильтрация чётных чисел
var evenNumbers = numbers.Where(n => n % 2 == 0);
evenNumbers.ForEach(n => Console.Write($"{n} "));  // 2 4 6 8 10

// Преобразование в строки
var strings = numbers.Select(n => $"Number: {n}");
strings.ForEach(Console.WriteLine);
```

### Пример 3: Паттерн Стратегия с полиморфизмом

```csharp
public interface ISortStrategy<T> {
    void Sort(List<T> list);
}

public class BubbleSort<T> : ISortStrategy<T> where T : IComparable<T> {
    public void Sort(List<T> list) {
        Console.WriteLine("Using Bubble Sort");
        for (int i = 0; i < list.Count - 1; i++) {
            for (int j = 0; j < list.Count - i - 1; j++) {
                if (list[j].CompareTo(list[j + 1]) > 0) {
                    T temp = list[j];
                    list[j] = list[j + 1];
                    list[j + 1] = temp;
                }
            }
        }
    }
}

public class QuickSort<T> : ISortStrategy<T> where T : IComparable<T> {
    public void Sort(List<T> list) {
        Console.WriteLine("Using Quick Sort");
        QuickSortRecursive(list, 0, list.Count - 1);
    }
    
    private void QuickSortRecursive(List<T> list, int low, int high) {
        if (low < high) {
            int pi = Partition(list, low, high);
            QuickSortRecursive(list, low, pi - 1);
            QuickSortRecursive(list, pi + 1, high);
        }
    }
    
    private int Partition(List<T> list, int low, int high) {
        T pivot = list[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (list[j].CompareTo(pivot) < 0) {
                i++;
                T temp = list[i];
                list[i] = list[j];
                list[j] = temp;
            }
        }
        
        T temp1 = list[i + 1];
        list[i + 1] = list[high];
        list[high] = temp1;
        
        return i + 1;
    }
}

public class Sorter<T> where T : IComparable<T> {
    private ISortStrategy<T> strategy;
    
    public void SetStrategy(ISortStrategy<T> strategy) {
        this.strategy = strategy;
    }
    
    public void Sort(List<T> list) {
        if (strategy == null) {
            throw new InvalidOperationException("Sort strategy not set");
        }
        strategy.Sort(list);
    }
}
```

```csharp
var numbers = new List<int> { 64, 34, 25, 12, 22, 11, 90 };
var sorter = new Sorter<int>();

// Используем разные стратегии сортировки
sorter.SetStrategy(new BubbleSort<int>());
sorter.Sort(new List<int>(numbers));

sorter.SetStrategy(new QuickSort<int>());
sorter.Sort(new List<int>(numbers));
```

## Преимущества и недостатки различных видов полиморфизма

### Ad-hoc полиморфизм

**Преимущества:**

- Простота использования и понимания
- Разрешается на этапе компиляции (быстрее)
- Позволяет оптимизировать код для конкретных типов

**Недостатки:**

- Требует явного определения для каждой комбинации типов
- Может привести к дублированию кода
- Ограниченная расширяемость

### Полиморфизм подтипов

**Преимущества:**

- Высокая гибкость и расширяемость
- Позволяет писать универсальный код
- Поддерживает принцип открытости/закрытости (Open/Closed Principle)

**Недостатки:**

- Небольшие накладные расходы времени выполнения
- Может усложнить иерархию классов
- Требует тщательного проектирования

### Параметрический полиморфизм

**Преимущества:**

- Максимальное переиспользование кода
- Типобезопасность на этапе компиляции
- Отсутствие приведения типов и boxing/unboxing
- Высокая производительность

**Недостатки:**

- Может усложнить код при избыточном использовании
- Ограничения обобщений могут быть сложными
- Сложнее отлаживать ошибки с обобщениями

Далее: [[09 Отношения классов|Отношения классов]]

#C-Sharp #OOP #C-Sharp/Type_casting #GENERATED
