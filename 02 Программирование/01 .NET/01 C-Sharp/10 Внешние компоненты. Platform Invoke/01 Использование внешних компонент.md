
https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke

https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke-source-generation

https://www.youtube.com/watch?v=KYq2WF3otxc

> `P/Invoke` — это технология обращения к неуправляемым сборкам, которая предоставляет возможность использования структур данных и функций, содержащихся в уже скомпилированной библиотеке.

> Компоненты технологии `P/Invoke` содержатся в двух пространствах имен: `System` и `System.Runtime.InteropServices`

Для совершения вызова функции, необходимо знать ее название и передаваемые параметры

Пример обращения к неуправляемой библиотеки из **WinApi**:

```cs
using System;
using System.Runtime.InteropServices;

public partial class Program
{
    // Импортируем библиотеку user32.dll (содержащую нужную функцию) и объявляем метод
    // соответствующий нативной функции
    [LibraryImport("user32.dll", StringMarshalling = StringMarshalling.Utf16, SetLastError = true)]
    private static partial int MessageBoxW(IntPtr hWnd, string lpText, string lpCaption, uint uType);

    public static void Main(string[] args)
    {
        // Вызов функции как обычного управляемого метода
        MessageBoxW(IntPtr.Zero, "Command-line message box", "Attention!", 0);
    }
}
```

- **Атрибут `LibraryImportAttribute`** говорит среде выполнения загрузить неуправляемую библиотеку.
- **Строка, передаваемая в атрибут**,.......
- **`StringMarshalling`** определяет кодировку текста, в которой будет производиться чтение библиотеки.
- **`SetLastError = true`** специфицирует поведение метода при возникновении ошибки. Если значение задано в `true`, то когда возникает ошибка, вызывается функция (C++) `void SetLastError([in] DWORD dwErrCode);`, которая устанавливает код последней ошибки для текущего потока (thread). Это позволяет пользователю обрабатывать эти ошибки, получая их через метод `Marshal.GetLastPInvokeError()`
- Частичный метод `static partial int MessageBoxW()` полностью соответствует сигнатуре из импортируемой библиотеки. Метод должен быть частичным, чтобы компилятор мог генерировать код для нативного обращения к неуправляемому коду

В генерируемом компилятором коде, и, в целом, в .NET версии 7 и меньше используется атрибут `DllImport` и ключевое слово `extern`, которое говорит, что нужно найти объявленный метод в неуправляемой библиотеке, указанной в `DllImport`

Обращение к нативной библиотеке MacOS аналогично сценарию с Windows библиотекой. В следующем примере вызывается системная функция `getpid(2)` для получения ID процесса приложения и последующего вывода в консоль

```cs
using System;
using System.Runtime.InteropServices;

namespace PInvokeSamples;

public static partial class Program {

    // Импорт динамической библиотеки libSystem и определение
    // метода, соответствующего нативной функции
    [LibraryImport("libSystem.dylib")]
    private static partial int getpid();

    public static void Main(string[] args) {
        // Вызов функции и получение ID процесса
        int pid = getpid();
        Console.WriteLine(pid);
    }
}
```
Аналогичный пример и в Linux. Название функции такое же, так как `getpid(2)` является частью системного API [POSIX](https://en.wikipedia.org/wiki/POSIX)

```cs
using System;
using System.Runtime.InteropServices;

namespace PInvokeSamples;

public static partial class Program {
    // Импорт динамической библиотеки libc
    // и определение соотв. метода
    [LibraryImport("libc.so.6")]
    private static partial int getpid();

    public static void Main(string[] args) {
        // Вызов функции и получение ID процесса
        int pid = getpid();
        Console.WriteLine(pid);
    }
}
```

## Вызов управляемого кода из неуправляемого

Система CLR обеспечивает двухстороннее взаимодействие управляемого и неуправляемого кода. Такой механизм открывает возможность из нативных функций неуправляемых сборок обращаться к управляемой сборке через указатели на функции.
Наиболее близким объектом к понятию "указатель на функцию" является делегат, который и используется для обеспечения взаимодействия управляемых и неуправляемых сборок

Способ использования этого механизма аналогичен обращению управляемого кода к неуправляемому, описанному выше. Для конкретного вызова нужно определить делегат, соответствующий сигрануре неуправляемой функции и передать этот делегат во внешний (external) метод. CLR сама организует всю остальную работу

```cs
using System;
using System.Runtime.InteropServices;

namespace ConsoleApplication1;

public static partial class Program {
    
    // Определение делегата, соответствующего сигнатуре неуправляемой функции
    // Неуправляемые типы HWND и LPARAM подменяются неуправляемым типом IntPtr (nint)
    private delegate bool EnumWC(IntPtr hwnd, IntPtr lParam);
    
    // Импорт user32.dll и определение нативной функции
    [LibraryImport("user32.dll")]
    private static partial int EnumWindows(EnumWC lpEnumFunc, IntPtr lParam);
    
    // Определение реализации делегата;
    // здесь просто выводиться адрес обработчика окна (handle)
    private static bool OutputWindow(IntPtr hwnd, IntPtr lParam) {
        Console.WriteLine(hwnd.ToInt64());
        return true;
    }
    
    public static void Main(string[] args) {
        // Вызов метода; делегат передается первым параметром.
        EnumWindows(OutputWindow, IntPtr.Zero);
    }
}
```

Перед рассмотрения пример, будет полезно обратить внимание на сигнатуру неуправляемой функции, с которой идет работа. Функция, перечисляющая все окна, имеет следующую сигнаруту: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`

Первый параметр -- указатель на функцию. Указатель на функцию имеет следующую сигнатуру `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`

> Важно понимать, что из управляемой сборки невозможно изменить в рантайме подключаемую библиотеку, так как она уже скомпилирована. Из управляемого кода можно только передавать параметры, в том числе и указатели на функции, которые будут выполнены из нативной библиотеки

### Linux & MacOS

Примеры с Linux и macOS показаны ниже. В примере используется функция `ftw()`, которая содержится в `libc`, библиотеке написанной на C. Эта функия используется, чтобы пройти по иерархии каталогов. Функция `ftw()` имеет следующую сигнатуру: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`

```cs
using System;
using System.Runtime.InteropServices;

namespace PInvokeSamples;

public static partial class Program {
    // Определяем делегат с сигнатурой, соответствующей нативной функции
    private delegate int DirClbk(string fName, ref Stat stat, int typeFlag);
    
    [LibraryImport("libc.so.6", StringMarshalling = StringMarshalling.Utf16)]
    private static partial int ftw(string dirpath, DirClbk cl, int descriptors);
    
    // Реализация делегата DirClbk
    // Печать имени файла, которое передается на вход
    private static int DisplayEntry(string fName, ref Stat stat, int typeFlag) {
        Console.WriteLine(fName);
        return 0;
    }
    
    public static void Main(string[] args) {
        // Вызов нативной функции
        // Во второй параметр передается делегат
        ftw(".", DisplayEntry, 10);
    }
}

// Нативный указатель на функцию на вход принимает указатель на структуру
// Этот тип является представлением нативной неуправляемой структуры
[StructLayout(LayoutKind.Sequential)]
public struct Stat {
    public uint DeviceID;
    public uint InodeNumber;
    public uint Mode;
    public uint HardLinks;
    public uint UserID;
    public uint GroupID;
    public uint SpecialDeviceID;
    public ulong Size;
    public ulong BlockSize;
    public uint Blocks;
    public long TimeLastAccess;
    public long TimeLastModification;
    public long TimeLastStatusChange;
}
```

Для MacOS используется такой же код, но вызывается другая библиотека, так как MacOS хранит `libc` в другом месте

```cs
using System;
using System.Runtime.InteropServices;

namespace PInvokeSamples;

public static partial class Program {
    
    private delegate int DirClbk(string fName, ref Stat stat, int typeFlag);
    
    [LibraryImport("libSystem.dylib", StringMarshalling = StringMarshalling.Utf16)]
    private static partial int ftw(string dirpath, DirClbk cl, int descriptors);
    
    private static int DisplayEntry(string fName, ref Stat stat, int typeFlag) {
        Console.WriteLine(fName);
        return 0;
    }
    
    public static void Main(string[] args) {
        ftw(".", DisplayEntry, 10);
    }
}

[StructLayout(LayoutKind.Sequential)]
public struct Stat {
    public uint DeviceID;
    public uint InodeNumber;
    public uint Mode;
    public uint HardLinks;
    public uint UserID;
    public uint GroupID;
    public uint SpecialDeviceID;
    public ulong Size;
    public ulong BlockSize;
    public uint Blocks;
    public long TimeLastAccess;
    public long TimeLastModification;
    public long TimeLastStatusChange;
}
```

Оба предыдущих примера зависят от передаваемых параметров, и, в обоих случаях, параметры представлены управляемым типом. CLR делает свою работу по преобразованию управляемого типа в нативный автоматически. Этот процесс называется **маршаллингом**

----

Но класс так же может быть использован для описания дополнительных характеристик, например, можно с помощью атрибута CharSet = CharSet.Unicode явно указать какая кодировка используется для работы функции в приложении

Ключевые `P/Invoke` библиотеки:

[Win32 API](https://learn.microsoft.com/ru-ru/windows/win32/) состоит из следующих библиотек:

- `user32.dll` https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/
- `gdi32.dll`
- `kernel32.dll`

### Функционал библиотеки `user32.dll`

https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-mouse_event?redirectedfrom=MSDN

```csharp
[DllImport("user32.dll")]
static extern void Mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, int dwExtraInfo);
    
    Возрват: отсутствует
    Действие: Позволяет программно управлять событиями мышью
    Параметры (C++ типы):
    
        [in] DWORD dwFlags // Определяет события, которые будут выполняться
                           // при вызове функции. Является аналогом [Flags] enum
            Возможные состояния:
                MOUSEEVENTF_MOVE       0x0001  // Курсор был сдвинут
                MOUSEEVENTF_LEFTDOWN   0x0002  // ЛКМ нажата
                MOUSEEVENTF_LEFTUP     0x0004  // ЛКМ отпущена
                MOUSEEVENTF_RIGHTDOWN  0x0008  // ПКМ нажата
                MOUSEEVENTF_RIGHTUP    0x0010  // ПКМ отпущена
                MOUSEEVENTF_MIDDLEDOWN 0x0020  // СКМ нажата
                MOUSEEVENTF_MIDDLEUP   0x0040  // СКМ отпущена
                MOUSEEVENTF_XDOWN      0x0080  // Доп. кнопка мыши нажата
                MOUSEEVENTF_XUP        0x0100  // Доп. кнопка мыши отпущена
                MOUSEEVENTF_WHEEL      0x0800  // Колесико прокручено на dwData единиц
                MOUSEEVENTF_HWHEEL     0x1000  // Колесико наклонено
                MOUSEEVENTF_ABSOLUTE   0x8000  // 
                
        [in] DWORD dx, dy // нормализованные абсолютные координаты курсора
        
        [in] DWORD dwData — Если задано событие:
                MOUSEEVENTF_WHEEL  // - WHEEL_DELTA, единицы прокрутки колесика
                                   //   Одна прокрутка колесика = +-120 единицам
                MOUSEEVENTF_HWHEEL // - Положительное dwData означает, что колесико
                                   //   наклонено вправо, Отрицательное - влево
                MOUSEEVENTF_XDOWN или MOUSEEVENTF_XUP
                    // dwData содержит флаги,
                    // соответсвтующие нажатым доп. кнопкам:
                    XBUTTON1 0x0001
                    XBUTTON2 0x0002 
                Если перечисленные флаги dwFlags не заданы, то dwData = 0
        
        [in] ULONG_PTR dwExtraInfo // Доп. инфа, привязанная к событию.
                                   // Для получения доп. инфы, требуется
                                   // вызывать функцию GetMessageExtraInfo
```

```csharp
[DllImport("user32.dll")]
static extern bool SetCursorPos(int x, int y);

    Возрват: отсутствует
    Действие: Мгновенно перемещает курсор в указанную позицию. Если позиция курсора
        вне пределов экрана, то курсор будет перемещен в крайнюю точку экрана
    Параметры:
        int x — Позиция по оси X
        int y — Позиция по оси Y (направление сверху вниз)
```

```csharp
[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool GetCursorPos(out POINT lpPoint);

[StructLayout(LayoutKind.Sequential)]
public struct POINT
{
    public int X;
    public int Y;
    public POINT(int x, int y){ this.X = x; this.Y = y; }
}
```

```csharp
[DllImport("user32.dll")]
static extern int MessageBox(IntPtr hWnd, string text, string caption, int options);
Возврат:
Действие: открывает окно с сообщением
Параметры:
    hWnd    // 
    text    // текст сообщения
    caption // текст заголовка
    options // 
```

### Функционал библиотеки `win32.dll`

## Генератор кода PInvoke `win32metadata`

Существует Nuget-пакет, который позволяет автоматически генерировать объявление внешних функций и сопоставлять C++ типы с .Net типами. Для работы пакета требуется включение небезопасного кода.

Для установки проекции необходимо:

- Добавить ссылку на `Microsoft.Windows.SDK.Win32Metadata` от `nuget.org`;

- Поместить файл `NativeMethods.txt` в корневую директорию проекта вместе со списком функций `Win32`, которые запланированы для проекта.

После этого проекция C# / Win32 начнёт генерировать обёртки P/Invoke для запрашиваемых функций и всех их зависимостей

```powershell
dotnet add package Microsoft.Windows.CsWin32 --prerelease
```

Для проектов ниже версий .NET Core 2.1 и .NET 5 требуется установить эти пакеты:

```powershell
dotnet add package System.Memory
dotnet add package System.Runtime.CompilerServices.Unsafe
```

#C-Sharp #C-Sharp/P-Invoke #API #OS/Windows
