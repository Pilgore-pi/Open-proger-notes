
## План запроса

> **План запроса** — это детализированное описание последовательности операций, которые система управления базами данных (СУБД) выполнит для получения результата SQL-запроса.

Включает в себя:

- Какие таблицы будут сканироваться и в каком порядке.

- Какие индексы будут использоваться.

- Какие типы соединений (`JOIN`, `UNION`) применяются и как они будут выполняться (например, вложенные циклы, хеш-соединения).

- Какие операции сортировки, фильтрации, агрегации и другие будут выполнены.

- Оценки количества обрабатываемых строк и стоимости каждой операции.

План запроса показывает, как СУБД планирует достичь результата, оптимизируя выполнение. Он служит основой для анализа и оптимизации запросов — по нему можно понять, какие части запроса работают эффективно, а какие — требуют улучшения

----

https://habr.com/ru/companies/tensor/articles/790282/

план выполнения запроса представляет из себя некоторую древовидную структуру

узлом дерева плана является какая-то атомарная операция, с точки зрения PostgreSQL: каким образом данные надо получить, какой индекс стоит использовать или даже сразу несколько и надо ли строить по ним битовые карты, какой вид соединения или операции над множествами надо использовать

сначала выполняются все нижележащие узлы, а только потом их "предок" - и результат самого верхнего "корневого" узла и есть результат выполнения всего запроса

В третьих, на каждом узле плана в ходе реального выполнения запроса аккумулируются фактически затраченные на выполнение поддерева ресурсы: процессорное время, прочитанные блоки данных, задержки доступа к диску

## Команда `EXPLAIN`

Синтаксис:

```sql
EXPLAIN [ ( параметр [, ...] ) ] оператор

Здесь допускается параметр:

    ANALYZE [ boolean ]
    VERBOSE [ boolean ]
    COSTS [ boolean ]
    SETTINGS [ boolean ]
    GENERIC_PLAN [ boolean ]
    BUFFERS [ boolean ]
    SERIALIZE [ { NONE | TEXT | BINARY } ]
    WAL [ boolean ]
    TIMING [ boolean ]
    SUMMARY [ boolean ]
    MEMORY [ boolean ]
    FORMAT { TEXT | XML | JSON | YAML }
```

Пример:

```sql
EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 row)
```

Эта команда выводит план выполнения, генерируемый планировщиком Postgres для заданного оператора. План выполнения показывает, как будут сканироваться таблицы, затрагиваемые оператором — просто последовательно, по индексу и т. д. — а если запрос связывает несколько таблиц, какой алгоритм соединения будет выбран для объединения считанных из них строк.

Наибольший интерес в выводимой информации представляет ожидаемая стоимость выполнения оператора, которая показывает, сколько, по мнению планировщика, будет выполняться этот оператор (это значение измеряется в единицах стоимости, которые не имеют точного определения, но обычно это обращение к странице на диске). Фактически выводятся два числа: стоимость запуска до выдачи первой строки и общая стоимость выдачи всех строк. Для большинства запросов важна общая стоимость, но в таких контекстах, как подзапрос в `EXISTS`, планировщик будет минимизировать стоимость запуска, а не общую стоимость (так как исполнение запроса всё равно завершится сразу после получения одной строки). Кроме того, если количество возвращаемых строк ограничивается предложением `LIMIT`, планировщик интерполирует стоимость между двумя этими числами, выбирая наиболее выгодный план.

С параметром `ANALYZE` оператор будет выполнен на самом деле, а не только запланирован. При этом в вывод добавляются фактические сведения о времени выполнения, включая общее время, затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате. Это помогает понять, насколько близки к реальности предварительные оценки планировщика

> В других СУБД есть аналогичные средства для анализа запросов. В MySQL: `EXPLAIN`, `ANALYZE`; MS SQL Server: `EXPLAIN PLAN`, `SET SHOWPLAN_ALL ON` (через SQL Server Management Studio или через хранимые процедуры); Oracle: `EXPLAIN PLAN FOR`; SQLite: `EXPLAIN`, `EXPLAIN QUERY PLAN`

Имейте в виду, что с указанием ANALYZE оператор действительно выполняется. Хотя EXPLAIN отбрасывает результат, который вернул бы SELECT, в остальном все действия выполняются как обычно. Если вы хотите выполнить EXPLAIN ANALYZE с командой INSERT, UPDATE, DELETE, MERGE, CREATE TABLE AS или EXECUTE, не допуская изменения данных этой командой, воспользуйтесь таким приёмом:

```sql
BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
```

### Параметры команды `EXPLAIN`

**ANALYZE**

Выполнить команду и вывести фактическое время выполнения и другую статистику. По умолчанию этот параметр равен FALSE.

**VERBOSE**

Вывести дополнительную информацию о плане запроса. В частности, включить список столбцов результата для каждого узла в дереве плана, дополнить схемой имена таблиц и функций, всегда указывать для переменных в выражениях псевдоним их таблицы, а также выводить имена всех триггеров, для которых выдаётся статистика. Также для данного запроса будет выводиться идентификатор, если он был вычислен; за подробностями обратитесь к compute_query_id. По умолчанию этот параметр равен FALSE.

**COSTS**

Вывести рассчитанную стоимость запуска и общую стоимость каждого узла плана, а также рассчитанное число строк и ширину каждой строки. Этот параметр по умолчанию равен TRUE.

**SETTINGS**

Вывести информацию о параметрах конфигурации. А именно, будут выведены параметры, влияющие на планирование, значения которых отличаются от стандартных значений по умолчанию. В отсутствие данного указания подразумевается FALSE (эта информация не выводится).

**GENERIC_PLAN**

Использовать операторы с шаблонами параметров в виде $1 и создать общий план, не зависящий от значений параметров. За подробной информацией об общих планах и типах операторов, поддерживающих параметры, обратитесь к PREPARE. Этот параметр нельзя использовать с ANALYZE. Значение по умолчанию — FALSE.

**BUFFERS**

Включить информацию об использовании буфера. В частности, вывести число попаданий, блоков прочитанных, загрязнённых и записанных в общем буфере, число попаданий, блоков прочитанных, загрязнённых и записанных в локальном буфере, число прочитанных и записанных временных блоков, а также время в миллисекундах, потраченное на чтение и запись блоков файлов данных, локальных блоков и блоков временных файлов, если включён параметр track_io_timing. Попаданием (hit) считается ситуация, когда требуемый блок уже находится в кеше и чтения с диска удаётся избежать. Блоки в общем буфере содержат данные обычных таблиц и индексов, в локальном — данные временных таблиц и индексов, а временные блоки предназначены для краткосрочного использования при выполнении сортировки, хеширования, материализации и подобных узлов плана. Число загрязнённых блоков (dirtied) показывает, сколько ранее не модифицированных блоков изменила данная операция; тогда как число записанных блоков (written) показывает, сколько ранее загрязнённых блоков данный серверный процесс вынес из кеша при обработке запроса. Значения, указываемые для узла верхнего уровня, включают значения всех его дочерних узлов. В текстовом формате выводятся только ненулевые значения. При использовании ANALYZE информация о буферах включается в вывод автоматически.

**SERIALIZE**

Включить информацию о стоимости сериализации выходных данных запроса, преобразовывая её в текстовый или двоичный формат для отправки клиенту. Это может занять значительную часть времени обычной работы запроса, если функции вывода типа данных дорогие или если необходимо вывести значения в формате TOAST из отдельного хранилища. При значении по умолчанию, SERIALIZE NONE, эти преобразования не происходят. При заданных значениях SERIALIZE TEXT или SERIALIZE BINARY необходимое преобразование происходит, а затраченное время оценивается (если не задано значение TIMING OFF). Если указан параметр BUFFERS, в стоимость также включаются обращения к буферам, участвующим в преобразовании. При этом команда EXPLAIN никогда не отправляет полученные данные клиенту, поэтому стоимость передачи по сети таким образом рассчитать нельзя. Сериализация может работать только в режиме ANALYZE. Если для SERIALIZE не указан аргумент, подразумевается TEXT.

**WAL**

Включить информацию о формировании записей WAL. В частности, вывести число записей, число полных образов страниц (fpi, full page images), объём сгенерированных записей в байтах и количество случаев переполнения буферов WAL. В текстовом формате выводятся только ненулевые значения. Этот параметр может использоваться, только если также включён режим ANALYZE. По умолчанию он отключён (FALSE).

**TIMING**

Включить в вывод фактическое время запуска и время, затраченное на каждый узел. Постоянное чтение системных часов может значительно замедлить запрос, так что если достаточно знать фактическое число строк, имеет смысл сделать этот параметр равным FALSE. Время выполнения всего оператора замеряется всегда, даже когда этот параметр выключен и на уровне узлов время не подсчитывается. Этот параметр действует только в режиме ANALYZE. По умолчанию его значение равно TRUE.

**SUMMARY**

Включить сводку (например, суммарное время) после плана запроса. Сводка включается по умолчанию, когда используется ANALYZE, но этот параметр позволяет получить её и с другими вариантами команды. Время планирования в EXPLAIN EXECUTE включает время извлечения плана из кеша и время перепланирования, если оно потребовалось.

**MEMORY**

Вывести информацию о потреблении памяти на этапе планирования запросов. А именно, выводить точный объём памяти, используемый структурами данных в оперативной памяти, а также её общий объём с учётом издержек на выделение. Значение по умолчанию: FALSE.

**FORMAT**

Установить один из следующих форматов вывода: TEXT, XML, JSON или YAML. Последние три формата содержат ту же информацию, что и текстовый, но больше подходят для программного разбора. По умолчанию выбирается формат TEXT.

**boolean**

Включает или отключает заданный параметр. Для включения параметра можно написать TRUE, ON или 1, а для отключения — FALSE, OFF или 0. Значение boolean можно опустить, в этом случае подразумевается TRUE.

**оператор**

Любой оператор `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `MERGE`, `VALUES`, `EXECUTE`, `DECLARE`, `CREATE TABLE AS` и `CREATE MATERIALIZED VIEW AS`, план выполнения которого вас интересует.

> Чтобы планировщик запросов PostgreSQL был достаточно информирован для эффективной оптимизации запросов, данные в pg_statistic должны быть актуальными для всех таблиц, задействованных в запросе. Обычно об этом автоматически заботится деймон (daemon) автоочистки. Но если в таблице недавно произошли значительные изменения, может потребоваться вручную выполнить `ANALYZE`, не дожидаясь, пока автоочистка обработает эти изменения

### Примеры

```sql
EXPLAIN (FORMAT JSON) SELECT * FROM foo;
           QUERY PLAN
--------------------------------
 [                             +
   {                           +
     "Plan": {                 +
       "Node Type": "Seq Scan",+
       "Relation Name": "foo", +
       "Alias": "foo",         +
       "Startup Cost": 0.00,   +
       "Total Cost": 155.00,   +
       "Plan Rows": 10000,     +
       "Plan Width": 4         +
     }                         +
   }                           +
 ]
(1 row)
```

Если в таблице есть индекс, а в запросе присутствует условие `WHERE`, для которого полезен этот индекс, `EXPLAIN` может показать другой план:

```sql
EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 rows)
План того же запроса, но в формате YAML:

EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i='4';
          QUERY PLAN
-------------------------------
 - Plan:                      +
     Node Type: "Index Scan"  +
     Scan Direction: "Forward"+
     Index Name: "fi"         +
     Relation Name: "foo"     +
     Alias: "foo"             +
     Startup Cost: 0.00       +
     Total Cost: 5.98         +
     Plan Rows: 1             +
     Plan Width: 4            +
     Index Cond: "(i = 4)"
(1 row)
```

Рассмотрение формата XML оставлено в качестве упражнения для читателя.

План того же запроса без вывода оценок стоимости:

```sql
EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;

        QUERY PLAN
----------------------------
 Index Scan using fi on foo
   Index Cond: (i = 4)
(2 rows)
```

Пример плана для запроса с агрегатной функцией:

```sql
EXPLAIN SELECT sum(i) FROM foo WHERE i < 10;

                             QUERY PLAN
-------------------------------------------------------------------​--
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   ->  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i < 10)
(3 rows)
```

Пример использования `EXPLAIN EXECUTE` для отображения плана выполнения подготовленного запроса:

```sql
PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id > $1 AND id < $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------​------------------------------------------------------
 HashAggregate  (cost=10.77..10.87 rows=10 width=12) (actual time=0.043..0.044 rows=10.00 loops=1)
   Group Key: foo
   Batches: 1  Memory Usage: 24kB
   Buffers: shared hit=4
   ->  Index Scan using test_pkey on test  (cost=0.29..10.27 rows=99 width=8) (actual time=0.009..0.025 rows=99.00 loops=1)
         Index Cond: ((id > 100) AND (id < 200))
         Index Searches: 1
         Buffers: shared hit=4
 Planning Time: 0.244 ms
 Execution Time: 0.073 ms
(10 rows)
```

Разумеется, конкретные числа, показанные здесь, зависят от фактического содержимого задействованных таблиц. Также учтите, что эти числа и даже выбранная стратегия выполнения запроса могут меняться от версии к версии Postgres Pro вследствие усовершенствования планировщика. Кроме того, команда `ANALYZE` при обработке статистических данных производит случайные выборки, так что оценки стоимости могут меняться при каждом чистом запуске `ANALYZE`, даже когда фактическое распределение данных в таблице не меняется.

Обратите внимание, что в предыдущем примере показан «специализированный» план для запроса EXECUTE с определёнными значениями параметров. С помощью `GENERIC_PLAN` можно также посмотреть общий план для параметризованного запроса:

```sql
EXPLAIN (GENERIC_PLAN)
  SELECT sum(bar) FROM test
    WHERE id > $1 AND id < $2
    GROUP BY foo;

                                  QUERY PLAN
-------------------------------------------------------------------​------------
 HashAggregate  (cost=26.79..26.89 rows=10 width=12)
   Group Key: foo
   ->  Index Scan using test_pkey on test  (cost=0.29..24.29 rows=500 width=8)
         Index Cond: ((id > $1) AND (id < $2))
(4 rows)
```

В этом случае анализатор запроса корректно предполагает, что $1 и $2 должны иметь тот же тип данных, что и id, так что отсутствие информации о типе данных из PREPARE не представляет проблемы. В других случаях может потребоваться явно указать типы для символов параметров, что можно сделать путём приведения типов, например:

```sql
EXPLAIN (GENERIC_PLAN)
  SELECT sum(bar) FROM test
    WHERE id > $1::integer AND id < $2::integer
    GROUP BY foo;
```

----

1. Когда мы пишем запросы на SQL-подобном языке, мы используем декларативный подход к написанию: в тексте запроса мы не указываем способ получения данных, а просто говорим, какие данные хотим извлечь, **что** хотим получить.

2. Структура базы данных определяет, **где** эта информация находится

3. План запроса отвечает на вопрос «**Как** извлечь информацию из базы данных таким образом, чтобы набор данных соответствовал исходному тексту запроса»

Зачастую **построение плана занимает больше времени, чем само выполнение**, потому что этот процесс – достаточно сложный и ресурсоемкий

Можно составить множество различных планов запросов, которые соответствуют декларативному коду запроса и структуре базы данных, поэтому в качестве плана выбирается самый легкий с точки зрения ресурсов план. Прежде, чем создавать план, происходит поиск в кэше, так как такой план уже мог быть использован.

Сам план запроса определяет, какие операции над данными будут выполнены для выполнения декларативного запроса.

#DB
