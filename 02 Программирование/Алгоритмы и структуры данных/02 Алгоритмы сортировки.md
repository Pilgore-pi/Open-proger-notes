
Можно выделить несколько основных типов алгоритмов сортировки:

1. [[#Сравнительные алгоритмы|Сравнительные алгоритмы]]
2. [[#Неустойчивые|Неустойчивые]]
3. [[#Устойчивые|Устойчивые]]
4. [[#Алгоритмы, не основывающиеся на сравнении|Алгоритмы, не основывающиеся на сравнении]]
5. [[#Непрактичные алгоритмы|Непрактичные]]

## Сравнительные алгоритмы

Эти алгоритмы основываются на сравнении элементов.

- **Сортировка пузырьком (Bubble Sort)**: Простой, но неэффективный алгоритм, который сравнивает соседние элементы и меняет их местами. Временная сложность: $O(n^2)$ в худшем случае[1](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[2](https://stefaniuk.website/all/sorting-algorithms/)

- **Сортировка вставками (Insertion Sort)**: Элементы по одному вставляются в отсортированную часть массива. Хорошо работает для небольших массивов. Временная сложность: $O(n^2)$[1](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[2](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)

- **Сортировка выбором (Selection Sort)**: Делит массив на отсортированную и неотсортированную части, последовательно выбирая минимальные элементы. Временная сложность: $O(n^2)$[1](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[2](https://stefaniuk.website/all/sorting-algorithms/)

- **Быстрая сортировка (Quicksort)**: Один из самых быстрых алгоритмов, использует метод "разделяй и властвуй". Временная сложность: $O(n \times \log_2 n)$ в среднем[1](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[2](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)

- **Сортировка слиянием (Merge Sort)**: Рекурсивный алгоритм, который делит массив на две половины, сортирует их и сливает. Временная сложность: $O(n \times \log_2 n)$[1](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[2](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)

## Неустойчивые

Эти алгоритмы могут менять порядок равных элементов.

- **Пирамидальная сортировка (Heapsort)**: Строит двоичную кучу и извлекает максимальные элементы. Временная сложность: $O(n \times \log_2 n)$[](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)

- **Сортировка расчёской (Comb Sort)**: Улучшение пузырьковой сортировки с использованием переменных расстояний между элементами. Временная сложность: $O(n \times \log_2 n)$ в среднем[](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[](https://stefaniuk.website/all/sorting-algorithms/)

## Устойчивые

Эти алгоритмы сохраняют порядок равных элементов.

- **Timsort**: Гибрид сортировок вставками и слиянием, оптимизированный для реальных данных. Используется в Python и Java. Временная сложность: $O(n \times \log_2 n)$[](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)[](https://stefaniuk.website/all/sorting-algorithms/)

## Алгоритмы, не основывающиеся на сравнении

Эти алгоритмы используют другие методы для сортировки

- **Блочная сортировка (Bucket Sort)**: Разделяет элементы по "корзинам" и сортирует их отдельно. Временная сложность: $O(n+k)$, где $k$ — количество корзин

- **Цифровая сортировка (Radix Sort)**: Сортирует числа по разрядам, начиная с младших к старшим. Эффективна для целых чисел и строк фиксированной длины

## Непрактичные алгоритмы

Сюда можно отести любые неэффективные алгоритмы сортировки, например **`Bogosort`**, суть которого заключается в рандомном перемешивании массива до тех пор, пока случайно после перемешивания все элементы не расположаться по порядку.

# Структуры данных

Для иных структур данных, таких как дерево и список могут применяться некоторые из приведенных алгоритмов, но применение того или иного алгоритма зависит от способа хранения данных дерева или списка. К тому же списки и деревья могут быть как односвязными (каждый узел содержит ссылку на *потомка*), так и двухсвязными (каждый узел содержит ссылку на *потомка и родителя*)

Например, бинарное дерево можно хранить в виде массива, так как ограничение на количество потомков одного узла позволяет однозначно понимать, как распологать элементы дерева в массиве.

#Algorithms #Algorithms/Sorting