
> Классы могут перенимать **черты** от других классов, этот механизм называется **наследованием**

> **Наследование** — это один из важнейших принципов ООП, позволяющий избежать повторения кода и поддерживать целостность типов

Логически, наследование недоступно для структур, но, фактически, структуры в CLR представлены как **запечатанные** классы (`sealed class`), то есть классы, которые не могут иметь потомков:

Простой пример наследования:

```csharp
// Базовый класс "Горожанин"
public class Citizen {

    public string Name { get; set; }

    // Метод "Говорить()"
    public void Speak() {
        Console.WriteLine("Speaking...");
    }
}

// Производный класс "Преступник"
public class Criminal : Citizen {

    // Неявно определен метод Speak()

    // Добавочный метод "Украсть()", которого нет в базовом классе
    public void Steal(object item) {
        // stealing logic
    }
}
```

В этом примере `Criminal` наследуется от `Human`. Это означает, что у `Criminal` есть все свойства и методы `Citizen`, плюс свои собственные

Иерархию наследуемых классов, относящимся к самому верхнему по иерархии типу будем называть **семейством**. В приведенном примере было построено простое семейство типа `Citizen`

> Можно запретить возможность наследования от класса, пометив его модификатором `sealed`. Такие классы называются **запечатанными**

> В CLR Структуры, на самом деле, являются запечатанными классами, которые компилятор пытается располагать на стеке, если это возможно

### Оператор base (ссылка на базовый класс)

Ключевое слово `base` используется для обращения к членам базового класса из производного класса.

```csharp
public class Criminal : Citizen {

    // Добавочный метод "Представиться()"
    public void Represent() {
        Console.WriteLine($"{base.Name} is barking...");
    }
}
```

### Переопределение методов

Иногда необходимо изменить поведение метода базового класса в производном классе. Для этого используется ключевое слово `override`

```csharp
public class Citizen {

    public virtual void GoHome() {
        Console.WriteLine("Went to home");
    }
}

public class Criminal : Citizen {

    // Метод "ПойтиДомой" изменен под реалии преступника
    // преступники живут в тюрьме
    public override void GoHome() {
        Console.WriteLine("Went to prison");
    }
}
```

#### Сокрытие

Можно не переопределяя метод базового типа, подменить его на новый метод с тем же именем. В таком случае оригинальный метод базового типа будет скрыт и перестанет быть доступным в производном типе.

Такие методы помечаются специальным ключевым словом `new`

```cs
public class Citizen {

    public virtual void GoHome() {
        Console.WriteLine("Went to home");
    }
}

public class Criminal : Citizen {

    // Метод "ПойтиДомой" изменен под реалии преступника
    // преступники живут в тюрьме
    public new void GoHome() {
        Console.WriteLine("Went to prison");
    }
}
```

Синтаксически, ключевое слово `new` необязательно, но настоятельно рекомендуется его применять, чтобы избежать неднозначности.

Механизм сокрытия происходит при указании метода в производном классе с таким же именем и сигнатурой, независимо от применения ключевого слова `new`

### Абстрактные классы и методы

Абстрактный класс представляет собой нечто, что не является логически достаточно конкретным, чтобы существовать. Нельзя создать объект абстрактного класса. Аналогично существуют абстрактные методы и свойства. Вся идея использования абстрактных классов заключается в наследовании от них и реализации конкретной логики уже в производных классах.

```csharp
public abstract class Animal {

    public abstract void MakeSound(); // нельзя определять реализацию
    
    // никакого скрытого поля не создается
    public abstract string Name { get; set; }
}

public class Dog : Animal {

    public override void MakeSound() {
        Console.WriteLine("Bark");
    }
    private string name;
    public string Name => name;
}
```

### Интерфейсы

Интерфейсы определяют контракт, который должны соблюдать классы. Класс может реализовать несколько интерфейсов. Под контрактом подразумевается унифицированный набор возможностей как самого объекта, так и возможностей выполнять действия над объектом, выполняющий контракт.

Экземпляром интерфейса может быть только класс, который **реализует** интерфейс

```csharp
public interface IAnimal {
    void MakeSound();
}

public class Dog : IAnimal {

    public void MakeSound() {
        Console.WriteLine("Bark");
    }
}
```

### Множественное наследование

> В C\# класс может наследоваться только от **одного базового класса**, но может реализовывать **несколько интерфейсов**

```csharp
public interface IAnimal {
    void MakeSound();
}

public interface IPet {
    void Play();
}

public class Dog : IAnimal, IPet {

    public void MakeSound() {
        Console.WriteLine("Bark");
    }

    public void Play() {
        Console.WriteLine("Playing...");
    }
}
```

## Отличия интерфейса от абстрактного класса


| Интерфейс                                                                     | Абстрактный класс                                                                         |
| ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Множественная реализация**. Класс может реализовывать множество интерфейсов | Класс может наследоваться только от одного абстрактного класса                            |
| Используется для определения контракта                                        | Используется для определения базового функционала, который может быть частично реализован |
| Не может содержать конструкторы                                               | Может содержать конструкторы                                                              |
| Не может содержать поля                                                       | Может содержать поля                                                                      |
| Не может иметь состояния                                                      | Может иметь состояние (поля)                                                              |
| Члены должны быть открытыми для доступа извне                                 | Члены могут иметь разный уровень доступа, в том числе и private                           |

**Итог**. Абстрактные классы уже могут содержать часть данных и структуры объекта, они используются, когда часто приходится использовать одно и тоже ядро. Интерфейс — это то, как сущность может взаимодействовать с миром, например, змея может видеть свет через интерфейс, называемый "зрение", чувствовать запахи через интерфейс "обоняние", питаться через интерфейс "челюсть". Интерфейс не имеет предопределенной логики и состояния, он просто требует, чтобы сущность могла определенным образом взаимодействовать с другими объектами. Можно считать, что интерфейс — это очень абстрактный класс, но никогда нельзя считать абстрактный класс интерфейсом.

#C-Sharp #OOP
