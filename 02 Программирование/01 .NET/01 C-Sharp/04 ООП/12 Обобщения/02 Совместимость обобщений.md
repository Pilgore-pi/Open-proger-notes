> По умолчанию, обобщенные типы не являются совместимыми с такими же обобщенными типами, но разными типами универсальных параметров. Это явление называется ***Инвариантностью***.

```csharp
// Список объектов и список строк несовместимы между собой

List<object> objs = new List<string>(); // compile error

List<string> strs = new List<object>(); // compile error
```

Однако, можно специфицировать, что универсальные параметры могут быть преобразованы в более общий или более узкий тип.

> Вид совместимости, когда обобщенный тип с более **общим** универсальным параметром совместим с типом с более **узким** типом параметра, называется ***Ковариантностью***

> Вид совместимости, когда обобщенный тип с более **узким** универсальным параметром совместим с типом с более **общим** типом параметра, называется ***Контрвариантностью***

Встроенный интерфейс `IEnumerable<T>` поддерживает коваринтность, то есть коллекция более общих типов может быть инициализирована коллекцией более конкретных типов:

```csharp
// модификатор out указывает на то, что IEnumerable<T> совместим с IEnumerable<U> where U : T
public interface IEnumerable<out T> : System.Collections.IEnumerable { ... }

IEnumerable<string> strings = new List<string>();

IEnumerable<object> objects = strings; // OK
```

Ковариантность типа `IEnumerable<T>` обуславливается его ограничениями — элементы коллекции доступны только для чтения

```csharp
public delegate TResult MyDelegate<in T, out TResult>(T arg);

MyDelegate<object, ArgumentException> fn1 = null;
// Явного приведения типа не требуется 
MyDelegate<string, Exception> fn2 = fn1;
Exception e = fn2(""); 
```
Резюмируя виды совместимости обобщений, можно выделить следующие термины:

* Инвариантность — несовместимость обобщенных типов
* Ковариантность (out) — допускается upcast — возможно привести к базовому типу
* Контрвариантность (in) — допускается downcast —  возможно привести к производному типу
* Вариантность = ковариантность или контрвариантность

> Обобщенные типы не могут быть и ковариантыми и контрвариантными одновременно (недопустимо совмещение модификаторов `in` и `out`)

> Вариантными могут быть только универсальные параметры интерфейсов и делегатов.

> Все классы и структуры инвариантны

Обобщенные методы, чисто технически, не могут поддерживать вариантность, так как механизм наследования для них недоступен

[[03 Наследование обобщений|Наследование обобщений]]

#C-Sharp #OOP #OOP/Generics #C-Sharp/Generics 
