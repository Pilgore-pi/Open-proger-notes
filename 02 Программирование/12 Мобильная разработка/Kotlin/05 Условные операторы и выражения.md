
В Kotlin условные операторы `if-else` и `when` являются **выражениями**, возвращающими какое-то значение, что отличает их от многих других языков программирования. Это означает, что результат условного оператора можно присвоить переменной

Переменную типа `Boolean` можно инициализировать такими выражениями:

```kotlin
val isTrue = (5 > 6) || (4 < 6)
```

## Конструкция `if-else`

```kotlin
// Выражение со скобками
val result = if (a > b) {
    println("a > b")
    "a больше b"
} else {
    println("b >= a")
    "b больше или равно a"
}

// Выражение без скобок (для одной строки кода)
val result = if (a > b) "a > b" else "b >= a"

// Аналогичный вариант с переносом строк
val result = if (a > b)
    "a > b"
else
    "b >= a"

// Использование в качестве оператора (без присваивания)
if (a > b) {
    println("a > b")
} else {
    println("b >= a")
}

// Цепочка условий
val message = if (a > b) {
    "a больше b"
} else if (a < b) {
    "b больше a"
} else {
    "a равно b"
}
```

Переменная, объявленная внутри блока `if-else`, существует только внутри области видимости этого блока. После выхода из области видимости переменная становится недоступной

**Важно:** В Kotlin последнее выражение в блоке `if` или `else` автоматически становится возвращаемым значением, поэтому явный `return` не требуется

## Конструкция `when` (паттерн Matching

```kotlin
val choice = readLine()?.toIntOrNull() ?: 0

// Базовое использование
when (choice) {
    1 -> println(a + b)
    2 -> println(a - b)
    3 -> println(a * b)
    else -> println(0)
}

// Использование в качестве выражения
val result = when (choice) {
    1 -> a + b
    2 -> a - b
    3 -> a * b
    else -> 0
}

// Несколько значений в одной ветке
val result = when (choice) {
    1, 2 -> a + b
    3, 4 -> a - b
    5, 6 -> a * b
    else -> 0
}

// Использование диапазонов
val result = when (choice) {
    in 1..3 -> "Первая группа"
    in 4..6 -> "Вторая группа"
    else -> "Неизвестная группа"
}

// Использование условий
val result = when {
    a > b -> "a больше b"
    a < b -> "b больше a"
    else -> "a равно b"
}

// Блоки кода в ветках
val result = when (choice) {
    1 -> {
        println("Выполняем сложение")
        a + b
    }
    2 -> {
        println("Выполняем вычитание")
        a - b
    }
    else -> {
        println("Неизвестная операция")
        0
    }
}
```

Конструкция `when` в Kotlin является более мощной и гибкой альтернативой `switch-case` из других языков. Каждая ветка `when` завершается автоматически после выполнения, без необходимости использования `break`. Последнее выражение в каждой ветке становится её результатом

**Основные особенности `when`:**

- **Точное совпадение** — `1 -> ...` выполняется, если `choice == 1`
- **Несколько значений** — `1, 2 -> ...` выполняется при совпадении с любым из перечисленных значений
- **Диапазоны** — `in 1..10 -> ...` проверяет принадлежность значения диапазону
- **Условия** — `is String -> ...` проверяет тип данных
- **Блок без аргумента** — `when { условие1 -> ..., условие2 -> ... }` используется для проверки произвольных условий
- **Автоматическое завершение** — не требуется `break` между ветками

## Тернарная операция

> **Тернарная операция** (от слова "терра" - три (операнда)) — это **выражение**, которое возвращает одно из двух значений в зависимости от условия

В Kotlin тернарной операции как отдельной конструкции нет, так как вместо нее можно использовать выражение `if-else`

#Kotlin
