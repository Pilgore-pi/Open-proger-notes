Представляют собой наборы ключ-значение, элементом набора является общедоступное свойство. Таким образом даже свойство `Array.length` является доступным для изменения.

```js
// Литерал объекта
let obj = {};

let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
  "likes birds": true
  sayHi: function() { alert('hi'); }
  // OR
  sayHi() { alert('hi'); }
};

// третье слово состоит из двух слов, поэтому заключено в
// кавычки
// уникальный способ обращения к свойствам
user["likes birds"] = false;

// Можно удалить определенное свойство
delete user.age;
```

## Аксессоры

Геттеры и сеттеры:
```js
let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },
  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};
```

Вставка аксессора в объект:

```js
let user = {
	name: 'Dan'
	surname: 'Stone'
}

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});
```

Вычисляемое в Runtime свойство:

```js
let fruit = askForFruit();

let bag = {
	[fruit]: 5
}

// Аналогично
let bag = {};
// имя свойства будет взято из переменной fruit
bag[fruit] = 5;
```

Можно создать объект с любыми именами свойств, вычисляемыми в Runtime:

```js
function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...другие свойства
  };
}
```

``` js
let user = {
  name,  // тоже самое, что и name:name
  age: 30
};
```

Также допустимы следующие имена свойств:

```js
let obj = {
  for: 1,
  let: 2,
  return: 3
  0: 0 // свойство как индекс
};

obj[0] = 2;
obj['0'] = 2; // аналогичный вариант
```

> В JavaScript можно получить доступ к любому свойству, даже если этого свойства **не существует**. Несуществующее свойство равно `undefined`

Поэтому возможно следующее:

```js
let arr = []
arr[99999] = 6;
arr.color = 'indigo';
```

### Оператор in

Позволяет проверить наличие свойства в объекте.

```js
"key" in dict // true

let prop = 'dim' + 2;
prop in obj // вычисляемое имя свойства
```

Оператор `in` лучше, чем сравнение с `undefined`, так как некоторые существующие свойства могут быть равны `undefined`. Оператор `in` корректно определяет существование свойства.

При переборе объекта в цикле через оператор `in`, свойства сортируются в порядке добавления, кроме чисел, они сортируются в порядке возрастания.

## Оператор this

`this` — это ссылка не текущий объект. Используется в методах

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" - это "текущий объект".
    alert(this.name);
  }
};
```

Отличается от реализации в других языках программирования. `this` является контекстно-зависимым и вычисляется в Runtime.

```js
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f']();
```

## Константные объекты

Можно создавать константы-объекты, но константной будет лишь ссылка, а данные на которые указывает эта ссылка не будут константными.

[[07 Копирование объектов]]

#JavaScript