
> **Финализатор** — это особый метод класса, который вызывается **автоматически средой выполнения (CLR) перед удалением объекта сборщиком мусора**. Финализатор позволяет выполнить заключительную очистку объекта, например, освободить неуправляемые ресурсы

- В C\# финализатор записывается в виде **деструктора** классa — метода с синтаксисом `~ИмяКласса()`. Например:

```csharp
class Person {
    public string Name { get; }
    public Person(string name) => Name = name;
    
    ~Person() {
        Console.WriteLine($"{Name} deleted");
    }
}
```

- Хотя это называют деструктором, на самом деле C\# компилирует его в метод `Finalize()` — вызов этого метода происходит перед фактическим сбором объекта сборщиком мусора
- В отличие от C++ деструкторов, **время вызова финализатора неопределено** и зависит от работы сборщика мусора; объект может прожить в памяти неопределённое время после того, как на него перестали ссылаться
- Метод `Finalize` нельзя вызвать явно из кода, он вызывается автоматически средой выполнения
- Обычно финализатор используется для освобождения **неуправляемых ресурсов** (например, файловых дескрипторов, сетевых сокетов), которые не покрываются сборщиком мусора
- Если класс реализует финализатор, сборка такого объекта происходит медленнее, так как объект попадает в очередь финализации

## Очередь финализации

**Очередь финализации** (finalization queue) — это специальная внутренняя структура данных, поддерживаемая средой выполнения .NET (CLR), в которую помещаются ссылки на объекты, имеющие финализаторы (деструкторы) [^1]

Когда сборщик мусора обнаруживает, что объект стал недостижимым и готов к удалению из памяти, он проверяет, есть ли у этого объекта финализатор [^5]. Если финализатор присутствует, сборщик мусора не удаляет объект сразу, а вместо этого добавляет его в очередь финализации [^3][^8]

**Как это работает:**

* **Добавление в очередь:** При создании объекта с финализатором, ссылка на него добавляется в очередь финализации [^6]
* **Удержание в памяти:** Эта очередь выступает в роли "корня", то есть даже если на объект больше нет ссылок в приложении, он всё равно удерживается в памяти очередью финализации [^6]
* **Перемещение объектов:** Когда сборщик мусора определяет, что объект из очереди финализации готов к удалению, он перемещает ссылку на этот объект в другую очередь — **очередь объектов, готовых к завершению (freachable queue)** [^6]
* **Выполнение финализаторов:** Специальный **поток финализации** (finalizer thread), работающий параллельно, выбирает объекты из этой очереди и вызывает их метод `Finalize()` (который компилируется из деструктора C\#) [^1][^6][^8]
* **Освобождение памяти:** После выполнения финализатора объект становится полностью недоступным, и только при следующей сборке мусора память, занимаемая этим объектом, будет окончательно освобождена [^6][^8]

**Ключевые моменты:**

* **Два этапа сборки мусора:** Объекты с финализаторами требуют как минимум двух проходов сборщика мусора для полного удаления: один для добавления в очередь финализации и выполнения финализатора, и второй для освобождения памяти [^1][^4]
* **Влияние на производительность:** Наличие объектов с финализаторами замедляет процесс сборки мусора и в целом негативно сказывается на производительности приложения, поскольку усложняет управление памятью [^4][^7]
* **Неопределённое время вызова:** Время вызова финализатора непредсказуемо и зависит от работы сборщика мусора, что затрудняет управление ресурсами [^3][^7]
* **Использование `IDisposable`:** Из-за этих недостатков рекомендуется использовать паттерн `IDisposable` для явного и своевременного освобождения неуправляемых ресурсов, а финализаторы рассматривать как "страховку" на случай, если `Dispose()` не был вызван [^7]

В современных версиях .NET (начиная с .NET 5) деструкторы не вызываются автоматически при завершении работы приложения, что делает явный вызов `GC.Collect()` или другие механизмы для демонстрации работы финализаторов необходимыми при тестировании [^2][^3].

## Пример вызова финализаторов и порядок:

В иерархии наследования финализаторы вызываются в порядке от самого производного класса к базовому:

```csharp
class Base {
    ~Base() { Console.WriteLine("Base finalizer"); }
}

class Derived : Base {
    ~Derived() { Console.WriteLine("Derived finalizer"); }
}
```

При удалении `Derived` сначала вызовется финализатор `Derived`, затем `Base`.

## Связь с паттерном IDisposable и освобождением ресурсов

- В C\# для правильного освобождения ресурсов используется интерфейс `IDisposable` с методом `Dispose()`, вызов которого контролирует разработчик (обычно через `using`)
- Это позволяет **освобождать ресурсы "здесь и сейчас"**, а не в неопределённом времени финализатором.
- Финализаторы обеспечивают "страховку", на случай если `Dispose` не был вызван, но их стоит избегать, так как они снижают производительность и усложняют работу сборщика мусора.

[^1]: https://professorweb.ru/my/csharp/charp_theory/level13/13_5.php
[^2]: https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/finalizers
[^3]: https://metanit.com/sharp/tutorial/8.2.php
[^4]: https://ru.stackoverflow.com/questions/500438/Различие-dispose-finalize-Деструктора-и-класса-gc
[^5]: https://learn.microsoft.com/ru-ru/dotnet/fundamentals/runtime-libraries/system-object-finalize
[^6]: https://professorweb.ru/my/csharp/optimization/level3/3_6.php
[^7]: https://easyoffer.ru/question/5219
[^8]: https://devkazakov.com/ru/blog/sborka-musora-idisposable-i-finalizatory-v-c-sharp/
[^9]: https://habr.com/ru/companies/pvs-studio/articles/311998/
[^10]: https://pvs-studio.ru/ru/blog/posts/csharp/0437/

#C-Sharp #Performance