
Назад: [[06 Статические классы|Статические классы]]

Инкапсуляция — один из трёх столпов объектно-ориентированного программирования, который заключается в сокрытии внутренней реализации класса и предоставлении контролируемого доступа к его данным и функциональности через открытый интерфейс

> **Инкапсуляция** —  это механизм, суть которого заключается в объединении данных и методов работы с этими данными в единую структуру (класс), скрывая детали реализации и защищая данные от некорректного использования

Инкапсуляция решает три основные задачи:

- **Сокрытие данных** — защита внутреннего состояния объекта от прямого доступа извне
- **Контроль доступа** — управление тем, какие части класса доступны другим классам
- **Упрощение интерфейса** — предоставление простого и понятного способа взаимодействия с объектом

## Модификаторы доступа

> По умолчанию члены класса имеют модификатор доступа `private`, а сами классы — `internal`

```csharp
public class BankAccount {
    // Приватное поле — доступно только внутри класса
    private decimal balance;
    
    // Публичное свойство — доступно везде
    public string AccountNumber { get; private set; }
    
    // Защищённое поле — доступно в этом и производных классах
    protected DateTime createdDate;
    
    // Внутренний метод — доступен только в текущей сборке
    internal void InternalAudit() {
        Console.WriteLine($"Auditing account {AccountNumber}");
    }
    
    // Публичный метод для контролируемого доступа к балансу
    public decimal GetBalance() => balance;
    
    public void Deposit(decimal amount) {
        if (amount <= 0)
            throw new ArgumentException("Amount must be positive");
        balance += amount;
    }
}
```

## Принципы инкапсуляции

### 1 Сокрытие полей

Поля класса должны быть приватными, доступ к ним предоставляется через свойства или методы:

```csharp
public class Person {
    // Плохая практика: публичное поле
    // public string name;
    
    // Хорошая практика: приватное поле с публичным свойством
    private string name;
    
    public string Name {
        get => name;
        set {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("Name cannot be empty");
            name = value.Trim();
        }
    }
}
```

### 2 Валидация данных

Инкапсуляция позволяет контролировать корректность данных при их установке:

```csharp
public class Rectangle {
    private double width;
    private double height;
    
    public double Width {
        get => width;
        set {
            if (value <= 0)
                throw new ArgumentException("Width must be positive");
            width = value;
        }
    }
    
    public double Height {
        get => height;
        set {
            if (value <= 0)
                throw new ArgumentException("Height must be positive");
            height = value;
        }
    }
    
    // Вычисляемое свойство — не имеет backing field
    public double Area => width * height;
    
    public double Perimeter => 2 * (width + height);
}
```

### 3 Изменение внутренней реализации без изменения интерфейса

```csharp
public class Temperature {
    // Внутреннее хранение в Кельвинах
    private double kelvin;
    
    // Публичный интерфейс предоставляет работу с Цельсиями
    public double Celsius {
        get => kelvin - 273.15;
        set => kelvin = value + 273.15;
    }
    
    public double Fahrenheit {
        get => Celsius * 9 / 5 + 32;
        set => Celsius = (value - 32) * 5 / 9;
    }
    
    // Пользователи класса не знают, что внутри используются Кельвины
    public double Kelvin {
        get => kelvin;
        set {
            if (value < 0)
                throw new ArgumentException("Temperature cannot be below absolute zero");
            kelvin = value;
        }
    }
}
```

```csharp
var temp = new Temperature();
temp.Celsius = 25;
Console.WriteLine($"{temp.Fahrenheit}°F"); // 77°F
Console.WriteLine($"{temp.Kelvin}K");      // 298.15K
```

## Сокрытие методов (new)

Ключевое слово `new` используется для **сокрытия** (hiding) члена базового класса в производном классе. Это **не переопределение**, а создание нового члена с тем же именем.

> **Сокрытие** создаёт новый член в производном классе, который "затеняет" член базового класса, но не заменяет его

```csharp
public class BaseClass {
    public void Display() {
        Console.WriteLine("BaseClass Display");
    }
    
    public int Value { get; set; } = 10;
}

public class DerivedClass : BaseClass {
    // Сокрытие метода базового класса
    public new void Display() {
        Console.WriteLine("DerivedClass Display");
    }
    
    // Сокрытие свойства базового класса
    public new int Value { get; set; } = 20;
}
```

```csharp
DerivedClass derived = new DerivedClass();
derived.Display();  // "DerivedClass Display"
Console.WriteLine(derived.Value);  // 20

// При приведении к базовому типу вызывается член базового класса
BaseClass baseRef = derived;
baseRef.Display();  // "BaseClass Display"
Console.WriteLine(baseRef.Value);  // 10
```

> Без ключевого слова `new` компилятор выдаст предупреждение о непреднамеренном сокрытии. Использование `new` явно указывает на намерение скрыть член базового класса

### Когда использовать сокрытие

```csharp
public class Logger {
    public void Log(string message) {
        Console.WriteLine($"[LOG] {message}");
    }
}

public class FileLogger : Logger {
    private string filePath;
    
    public FileLogger(string path) {
        filePath = path;
    }
    
    // Полностью новая реализация, не связанная с базовой
    public new void Log(string message) {
        File.AppendAllText(filePath, $"{DateTime.Now}: {message}\n");
    }
}
```

## Виртуальные методы (virtual/override)

Виртуальные методы используются для **переопределения** (overriding) — механизма полиморфизма, при котором производный класс предоставляет новую реализацию метода базового класса.

> **Переопределение** заменяет реализацию метода базового класса, сохраняя полиморфное поведение

### Объявление виртуальных методов

```csharp
public class Shape {
    // Виртуальный метод может быть переопределён в производных классах
    public virtual double GetArea() {
        return 0;
    }
    
    public virtual void Draw() {
        Console.WriteLine("Drawing a shape");
    }
    
    // Виртуальное свойство
    public virtual string Type => "Shape";
}

public class Circle : Shape {
    public double Radius { get; set; }
    
    // Переопределение метода
    public override double GetArea() {
        return Math.PI * Radius * Radius;
    }
    
    public override void Draw() {
        Console.WriteLine($"Drawing a circle with radius {Radius}");
    }
    
    public override string Type => "Circle";
}

public class Rectangle : Shape {
    public double Width { get; set; }
    public double Height { get; set; }
    
    public override double GetArea() {
        return Width * Height;
    }
    
    public override void Draw() {
        Console.WriteLine($"Drawing a rectangle {Width}x{Height}");
    }
    
    public override string Type => "Rectangle";
}
```

```csharp
Shape[] shapes = new Shape[] {
    new Circle { Radius = 5 },
    new Rectangle { Width = 4, Height = 6 },
    new Shape()
};

foreach (Shape shape in shapes) {
    // Полиморфный вызов — вызывается метод соответствующего типа
    Console.WriteLine($"{shape.Type}: Area = {shape.GetArea()}");
    shape.Draw();
}

// Вывод:
// Circle: Area = 78.53981633974483
// Drawing a circle with radius 5
// Rectangle: Area = 24
// Drawing a rectangle 4x6
// Shape: Area = 0
// Drawing a shape
```

### Запрет дальнейшего переопределения (sealed)

```csharp
public class OptimizedCircle : Circle {
    // sealed запрещает дальнейшее переопределение этого метода
    public sealed override double GetArea() {
        // Оптимизированная реализация
        return 3.14159 * Radius * Radius;
    }
}

public class SpecialCircle : OptimizedCircle {
    // Ошибка компиляции: нельзя переопределить sealed метод
    // public override double GetArea() { ... }
}
```

### Вызов базовой реализации

```csharp
public class LoggingShape : Shape {
    public override void Draw() {
        Console.WriteLine("--- Start Drawing ---");
        base.Draw();  // Вызов метода базового класса
        Console.WriteLine("--- End Drawing ---");
    }
}
```

```csharp
var loggingShape = new LoggingShape();
loggingShape.Draw();

// Вывод:
// --- Start Drawing ---
// Drawing a shape
// --- End Drawing ---
```

## Различия между сокрытием (new) и переопределением (virtual/override)

| Аспект | Сокрытие (new) | Переопределение (virtual/override) |
| -------- | ---------------- | ---- |
| **Ключевые слова** | `new` в производном классе | `virtual` в базовом, `override` в производном |
| **Полиморфизм** | Не поддерживается | Поддерживается |
| **Вызов через базовый тип** | Вызывается метод базового класса | Вызывается метод производного класса |
| **Назначение** | Создание нового независимого члена | Изменение поведения базового метода |
| **Связь с базовым классом** | Нет связи, независимые методы | Тесная связь, замена реализации |

### Наглядное сравнение

```csharp
public class Animal {
    public virtual void MakeSound() {
        Console.WriteLine("Animal makes a sound");
    }
    
    public void Move() {
        Console.WriteLine("Animal moves");
    }
}

public class Dog : Animal {
    // Переопределение виртуального метода
    public override void MakeSound() {
        Console.WriteLine("Dog barks: Woof!");
    }
    
    // Сокрытие невиртуального метода
    public new void Move() {
        Console.WriteLine("Dog runs");
    }
}
```

```csharp
Dog dog = new Dog();
dog.MakeSound();  // "Dog barks: Woof!"
dog.Move();       // "Dog runs"

Console.WriteLine("--- Through base reference ---");

Animal animalRef = dog;
animalRef.MakeSound();  // "Dog barks: Woof!" — полиморфизм работает
animalRef.Move();       // "Animal moves" — вызывается метод базового класса
```

### Практический пример различий

```csharp
public class PaymentProcessor {
    public virtual decimal CalculateFee(decimal amount) {
        return amount * 0.02m; // 2% комиссия
    }
}

public class CreditCardProcessor : PaymentProcessor {
    // Переопределение — изменяем логику расчёта комиссии
    public override decimal CalculateFee(decimal amount) {
        return amount * 0.03m + 0.5m; // 3% + фиксированная плата
    }
}

public class CryptoProcessor : PaymentProcessor {
    // Сокрытие — полностью новый метод, не связанный с базовым
    public new decimal CalculateFee(decimal amount) {
        // Новая логика, игнорирующая базовую
        return 5m; // фиксированная комиссия
    }
}
```

```csharp
void ProcessPayment(PaymentProcessor processor, decimal amount) {
    decimal fee = processor.CalculateFee(amount);
    Console.WriteLine($"Fee: {fee:C}");
}

ProcessPayment(new CreditCardProcessor(), 100m);  // Fee: $3.50 (полиморфизм)
ProcessPayment(new CryptoProcessor(), 100m);      // Fee: $2.00 (базовая реализация!)

// Прямой вызов
var crypto = new CryptoProcessor();
Console.WriteLine(crypto.CalculateFee(100m));     // Fee: $5.00
```

> **Важно:** Сокрытие нарушает полиморфизм. При работе через ссылку базового типа будет вызван метод базового класса, а не производного

## Абстрактные методы

Абстрактные методы — это виртуальные методы без реализации, которые **обязательно** должны быть переопределены в производных классах.

```csharp
public abstract class DatabaseConnection {
    // Абстрактные методы не имеют тела
    public abstract void Connect();
    public abstract void Disconnect();
    public abstract void ExecuteQuery(string query);
    
    // Обычные методы могут использовать абстрактные
    public void PerformOperation(string query) {
        Connect();
        try {
            ExecuteQuery(query);
        }
        finally {
            Disconnect();
        }
    }
}

public class SqlConnection : DatabaseConnection {
    private string connectionString;
    
    public SqlConnection(string connStr) {
        connectionString = connStr;
    }
    
    // Обязательное переопределение абстрактных методов
    public override void Connect() {
        Console.WriteLine($"Connecting to SQL Server: {connectionString}");
    }
    
    public override void Disconnect() {
        Console.WriteLine("Disconnecting from SQL Server");
    }
    
    public override void ExecuteQuery(string query) {
        Console.WriteLine($"Executing SQL query: {query}");
    }
}

public class MongoConnection : DatabaseConnection {
    public override void Connect() {
        Console.WriteLine("Connecting to MongoDB");
    }
    
    public override void Disconnect() {
        Console.WriteLine("Disconnecting from MongoDB");
    }
    
    public override void ExecuteQuery(string query) {
        Console.WriteLine($"Executing MongoDB query: {query}");
    }
}
```

```csharp
DatabaseConnection[] connections = {
    new SqlConnection("Server=localhost;Database=MyDB"),
    new MongoConnection()
};

foreach (var conn in connections) {
    conn.PerformOperation("SELECT * FROM Users");
    Console.WriteLine();
}
```

> Абстрактные классы не могут быть инстанцированы напрямую. Они служат базой для других классов

## Инкапсуляция и неизменяемость

Инкапсуляция часто используется для создания неизменяемых (immutable) объектов:

```csharp
public class Point {
    // Свойства только для чтения
    public double X { get; }
    public double Y { get; }
    
    public Point(double x, double y) {
        X = x;
        Y = y;
    }
    
    // Методы возвращают новые объекты вместо изменения текущего
    public Point Move(double dx, double dy) {
        return new Point(X + dx, Y + dy);
    }
    
    public double DistanceTo(Point other) {
        double dx = X - other.X;
        double dy = Y - other.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
}
```

```csharp
Point p1 = new Point(0, 0);
Point p2 = p1.Move(3, 4);

Console.WriteLine($"p1: ({p1.X}, {p1.Y})");  // (0, 0) — не изменился
Console.WriteLine($"p2: ({p2.X}, {p2.Y})");  // (3, 4)
Console.WriteLine($"Distance: {p1.DistanceTo(p2)}");  // 5
```

## Лучшие практики инкапсуляции

### 1. Минимизация публичного интерфейса

```csharp
public class ShoppingCart {
    private List<CartItem> items = new List<CartItem>();
    
    // Плохо: прямой доступ к коллекции
    // public List<CartItem> Items => items;
    
    // Хорошо: контролируемый доступ
    public IReadOnlyCollection<CartItem> Items => items.AsReadOnly();
    
    public void AddItem(CartItem item) {
        if (item == null)
            throw new ArgumentNullException(nameof(item));
        items.Add(item);
    }
    
    public bool RemoveItem(CartItem item) {
        return items.Remove(item);
    }
    
    public decimal GetTotal() {
        return items.Sum(item => item.Price * item.Quantity);
    }
}
```

### 2. Валидация в одном месте

```csharp
public class User {
    private string email;
    
    public string Email {
        get => email;
        set {
            if (!IsValidEmail(value))
                throw new ArgumentException("Invalid email format");
            email = value;
        }
    }
    
    private bool IsValidEmail(string email) {
        return !string.IsNullOrWhiteSpace(email) && email.Contains("@");
    }
    
    // Конструктор использует то же свойство для валидации
    public User(string email) {
        Email = email;  // Валидация происходит автоматически
    }
}
```

### 3. Инкапсуляция сложной логики

```csharp
public class Order {
    private List<OrderItem> items = new List<OrderItem>();
    private OrderStatus status = OrderStatus.Draft;
    
    public OrderStatus Status => status;
    
    public void Submit() {
        ValidateCanSubmit();
        status = OrderStatus.Submitted;
        SendConfirmationEmail();
        UpdateInventory();
    }
    
    // Инкапсуляция сложной логики в приватных методах
    private void ValidateCanSubmit() {
        if (status != OrderStatus.Draft)
            throw new InvalidOperationException("Order already submitted");
        if (items.Count == 0)
            throw new InvalidOperationException("Cannot submit empty order");
    }
    
    private void SendConfirmationEmail() {
        // Логика отправки email
    }
    
    private void UpdateInventory() {
        // Логика обновления склада
    }
}

public enum OrderStatus {
    Draft,
    Submitted,
    Shipped,
    Delivered
}
```

Далее: [[08 ПОЛИМОРФИЗМ|Полиморфизм]]

#C-Sharp #OOP
