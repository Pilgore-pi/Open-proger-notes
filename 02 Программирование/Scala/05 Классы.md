Назад: [[04 Ввод, рандом, коллекции]]

## Классы

Для членов по умолчанию модификатор **public**, но ключевого слова "`public`" не существует. Есть `private[this]`, `private`,  `protected`

`private[this]` — доступ только через `this.`. Дополнительные параметры для модификаторов доступа `protected` тоже существуют\*

```scala
class Animal
val anAnimal = new Animal
```

```scala
class Animal{
	val age: Int = 0
	def eat() = println("eating")
}

// конструктор (параметры НЕ РАВНО поля)
// это неявные val поля
class Dog(name: String) extends Animal
```

Параметры, передаваемые в конструкторе видны на уровне класса

```scala
// теперь name — поле
class Dog(val name: String) extends Animal

// обязательно указывать конструктор,
// если нет конструктора без параметров
class A extends B(i, j)

val dog = new Dog("Bally")
val name = dog.name;
```

Дополнения — конструкторы, поля и var/val:
- Параметры конструктора по умолчанию — не поля. Чтобы сделать поле — добавь `val` (или `var`, если нужно изменяемое поле).
- `var` создаёт изменяемое поле с геттером и сеттером; `val` — только геттер.
- Можно указывать параметры по умолчанию и перегружать конструктор через auxiliary constructors (см. ниже).

Примеры:

```scala
class Cat(val name: String, var age: Int = 0) {
  def this(name: String) = this(name, 0) // вспомогательный конструктор
}
```

Основной и вспомогательный конструкторы:

- Основной конструктор — это сигнатура класса (параметры после имени класса).
- Вспомогательные конструкторы объявляются как `def this(...) = { ... }` и обязаны в итоге вызывать предыдущий конструктор.

Наследование, `overriding`, `final`:

- По умолчанию методы виртуальные (можно переопределять).
- Чтобы переопределить метод, используйте `override`.
- Запретить наследование класса — ключевое слово `final class`.
- Запретить переопределение метода/поле — `final def` / `final val`.

Метод ***apply*** является особенным. Он фактически представляет собой конструктор, к которому можно обратиться как конструктору, а можно явно **`.apply`**

```scala
def apply(x: Int): Int = x + 1

MySingleton.apply(65)
MySingleton(65) // эквивалентно MySingleton.apply(65)
```

Пример использования companion object с `apply` (фабрика):

```scala
class Person(val name: String, val age: Int)

object Person {
  def apply(name: String, age: Int): Person = new Person(name, age)
  def unapply(p: Person): Option[(String, Int)] = Some((p.name, p.age))
}

val p = Person("Alice", 30) // вызывает Person.apply
```

Другие полезные моменты о методе `apply`:

- Можно определять `apply` в классах и объектах.
- Часто используется для создания DSL и фабрик.

## Интерфейсы

Интерфейсы классов в Scala называются "чертами". Черты класса могут иметь реализацию:

```scala
trait Yellable{
	def yell(sound: String): Unit
}
trait Movable{
	def move(): Unit
}

class elephant extends Animal with Yellable with Movable{
	override def yell(sound: String): Unit = print("Hoo")
	override def move():Unit = ()
}
```

Jтличие `trait` от `abstract class`:
- `trait` не может иметь конструкторных параметров (в классическом Scala; в Scala 3 есть возможности расширений).
- `trait` может содержать поля и реализации.
- класс может наследовать много `trait`-ов, но только один класс.
- Используй `abstract class` если нужен конструктор с параметрами или частично реализованный класс, который не должен быть `trait`.

Запечатанный трейт (`sealed trait`):
- `sealed trait` ограничивает расширения только файлами в том же исходном файле

Пример `sealed trait` + `case classes`:

```scala
sealed trait Expr
case class Const(v: Int) extends Expr
case class Sum(a: Expr, b: Expr) extends Expr
```

Инфиксная нотация: `object method argument` (только один параметр)

```scala
class Human{
	def ?(question: String): Unit = println(question)
}

val human = new Human
human ? "Who am I?"
```

```scala
val basicMath = 1 + 2
val anotherBasicMath = 1.+(2) // эквивалент
```

Методы с несколькими параметрами не могут быть в инфиксной нотации (за исключением синтаксического сахара с backticks и т.п.)

## Анонимные классы (как в Java)

Анонимный класс, реализующий черту `Movable`:

```scala
val snake = new Movable{
	override move(): Unit = println("I'm moving!")
}
```

Анонимный класс может расширять класс и реализовать несколько trait-ов, например

```scala
new SomeClass with Trait1 with Trait2 { ... }
```
## Объекты

Объекты — это как статические классы

```scala
object Animal { }
```

Если определен класс "`Animal`" и объект "`Animal`", то эти класс и объект имеют доступ к приватным членам друг друга

В таком случае `object Animal` будет называться **классом-компаньоном**

## Case-classes

Это классы, для которых неявно определены классы-компаньоны с методом `apply`, который возвращает экземпляр обычного класса

```scala
case class Person(name: String, age: Int)

val bullyMaguire = Person(name: "Bully", age: 166)
//Person.apply(name: "Bully", age: 30)
```

Далее: [[06 Обобщения]]

#Scala