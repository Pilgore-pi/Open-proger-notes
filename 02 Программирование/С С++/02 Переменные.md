
## Переменные в C++

### Объявление и инициализация переменных

> **Переменная** — это именованная область памяти, которая хранит значение определённого типа данных

> **Литерал** — это неименованное значение (число, строка, указатель, экземпляр объекта или другое значение)

В C++ переменные должны быть объявлены до их использования. Объявление переменной включает указание типа данных и имени переменной:

```cpp
int age;                    // объявление переменной
int age = 25;               // объявление и инициализация
int age = 25, height = 180; // объявление нескольких переменных

double pi = 3.14159;
char symbol = 'A';
bool isActive = true;
```

**Инициализация переменных:**

```cpp
// Традиционная инициализация (C-style)
int number = 42;

// Инициализация через конструктор (C++98)
int number(42);

// Uniform инициализация (C++11)
int number{42};
int number = {42};

// Инициализация без значения (содержит мусор)
int number;
```

> **Важно:** В C++ переменные, объявленные без инициализации, содержат случайные значения (мусор). Рекомендуется всегда инициализировать переменные при объявлении

### Базовые типы данных

#### Целые числа

| Тип данных         | Диапазон                            | Размер (байт) | Примечание                                                   |
| ------------------ | ----------------------------------- | ------------- | ------------------------------------------------------------ |
| char               | `[-128, 127]`                       | 1             | Может использоваться как для символов, так и для целых чисел |
| unsigned char      | `[0, 255]`                          | 1             | Беззнаковый символ                                           |
| short              | `[-2^15, 2^15)`                     | 2             | Короткое целое число                                         |
| unsigned short     | `[0, 2^16)`                         | 2             | Беззнаковое короткое целое число                             |
| int                | `[-2^31, 2^31)`                     | 4             | Стандартное целое число                                      |
| unsigned int       | `[0, 2^32)`                         | 4             | Беззнаковое целое число                                      |
| long               | `[-2^31, 2^31)` или `[-2^63, 2^63)` | 4 или 8       | Зависит от платформы и компилятора                           |
| unsigned long      | `[0, 2^32)` или `[0, 2^64)`         | 4 или 8       | Зависит от платформы и компилятора                           |
| long long          | `[-2^63, 2^63)`                     | 8             | Гарантированно 64-битное целое число (C++11)                 |
| unsigned long long | `[0, 2^64)`                         | 8             | Беззнаковое 64-битное целое число (C++11)                    |

> **Примечание:** Размер типов `int`, `long` и `short` зависит от компилятора и платформы. Для гарантированного размера следует использовать типы из заголовка `<cstdint>`: `int8_t`, `int16_t`, `int32_t`, `int64_t` и их беззнаковые аналоги `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`

----
#MERGE_NOTES
## [Stack Overflow](https://stackoverflow.com/questions/75191/what-is-an-unsigned-char)

In C++, there are three _distinct_ character types:

1. `char`
2. `signed char`
3. `unsigned char`

### 1. `char`

If you are using character types for **text**, use the unqualified `char`:

- it is the type of character literals like `'a'` or `'0'` (in C++ only, in C their type is `int`)
- it is the type that makes up C strings like `"abcde"`

It also works out as a number value, but it is unspecified whether that value is treated as signed or unsigned. Beware character comparisons through inequalities - although if you limit yourself to ASCII (0-127) you're just about safe.

### 2. `signed char`/ 3. `unsigned char`

If you are using character types as **numbers**, use:

- `signed char`, which gives you _at least_ the -127 to 127 range. (-128 to 127 is common)
- `unsigned char`, which gives you _at least_ the 0 to 255 range. This might be useful for displaying an octet e.g. as hex value.

"At least", because the C++ standard only gives the minimum range of values that each numeric type is required to cover. `sizeof (char)` is required to be 1 (i.e. one byte), but a byte could in theory be for example 32 bits. **`sizeof` would still be report its size as `1`** - meaning that you _could_ have `sizeof (char) == sizeof (long) == 1`

----

#### Числа с плавающей точкой

| Тип данных | Диапазон | Размер (байт) | Точность |
| ---------- | -------- | ------------- | -------- |
| float | от $±1.2\ \times\ 10^{−38}$ до $±3.4\ \times\ 10^{38}$ | 4 | 6-7 знаков |
| double | от $±2.2\ \times\ 10^{−308}$ до $±1.8\ \times\ 10^{308}$ | 8 | 15-16 знаков |
| long double | от $±3.4\ \times\ 10^{−4932}$ до $±1.2\ \times\ 10^{4932}$ | 8, 10 или 16 | 18-19 знаков |

> **Примечание:** Размер и точность `long double` зависит от компилятора и платформы

#### Текстовые данные

| Тип данных    | Описание                              | Примечание                                                       |
| ------------- | ------------------------------------- | ---------------------------------------------------------------- |
| `char`        | Символ (обычно 1 байт)                | Может быть знаковым или беззнаковым в зависимости от компилятора |
| `wchar_t`     | Широкий символ                        | Размер зависит от платформы (обычно 2 или 4 байта)               |
| `char8_t`     | UTF-8 символ                          | Введён в C++20                                                   |
| `char16_t`    | UTF-16 символ                         | Введён в C++11                                                   |
| `char32_t`    | UTF-32 символ                         | Введён в C++11                                                   |
| `const char*` | Строка (указатель на массив символов) | Не является встроенным типом, это указатель                      |

#### Логический тип

| Тип данных | Описание                                 | Размер (байт) |
| ---------- | ---------------------------------------- | ------------- |
| `bool`     | Может хранить `true` (1) или `false` (0) | 1             |

#### Пустой тип

| Тип данных | Описание                                                                       |
| ---------- | ------------------------------------------------------------------------------ |
| `void`     | Обозначает пустое значение; используется для функций, не возвращающих значение |

### Модификаторы типов

В C++ существуют модификаторы, которые изменяют свойства типов данных:

| Модификатор | Описание                                                                           |
| ----------- | ---------------------------------------------------------------------------------- |
| `signed`    | Тип может хранить отрицательные значения (по умолчанию для `int`, `short`, `long`) |
| `unsigned`  | Тип может хранить только неотрицательные значения                                  |
| `short`     | Уменьшает размер типа (применяется к `int`)                                        |
| `long`      | Увеличивает размер типа (применяется к `int`, `double`)                            |
| `const`     | Переменная не может быть изменена после инициализации                              |
| `static`    | Переменная имеет статическое хранилище (область видимости и время жизни)           |

```cpp
unsigned int count = 100;
long long bigNumber = 9223372036854775807LL;
const int MAX_SIZE = 100;
```

### Именование переменных

> **Идентификатор переменной** — это уникальное имя переменной, по которому можно к ней обращаться

**Правила именования:**

- Имя переменной не должно начинаться с цифры
- Имя переменной может содержать буквы (a-z, A-Z), цифры (0-9) и символ подчёркивания (`_`)
- Имя переменной не должно совпадать с зарезервированным ключевым словом языка
- Имена переменных чувствительны к регистру (`myVar` и `myvar` — разные переменные)
- Рекомендуется использовать только ASCII символы

```cpp
int myVariable;
int my_variable;
int MY_VARIABLE;
int _my_variable;
int myVariable123;
```

Недопустимые идентификаторы:

```cpp
int 123var;      // начинается с цифры
int my-variable; // содержит дефис
int my var;      // содержит пробел
int int;         // совпадает с ключевым словом
int @myvar;      // содержит недопустимый символ
```

### Виды нотаций

| Нотация           | Пример         | Использование                              |
| ----------------- | -------------- | ------------------------------------------ |
| верхняя верблюжья | UpperCamelCase | Классы, структуры, пространства имён       |
| нижняя верблюжья  | lowerCamelCase | Переменные, функции, методы                |
| змеиная           | snake_case     | Переменные, функции (часто в C-стиле коде) |
| толстая змеиная   | FAT_SNAKE_CASE | Константы, макросы                         |

```cpp
class MyClass { };           // UpperCamelCase
int myVariable = 0;          // lowerCamelCase
int my_variable = 0;         // snake_case
const int MAX_BUFFER_SIZE = 256; // FAT_SNAKE_CASE
```

### Литералы

#### Целочисленные литералы

```cpp
// Десятичная система (по умолчанию)
42
-33
1000000

// Двоичная система (C++14)
0b1010       // 10 в десятичной системе
0B11111111   // 255 в десятичной системе

// Восьмеричная система
010          // 8 в десятичной системе
0777         // 511 в десятичной системе

// Шестнадцатеричная система
0x1A         // 26 в десятичной системе
0xFF         // 255 в десятичной системе
0xDEADBEEF

// Разделители для удобочитаемости (C++14)
1'000'000
0xFF'FF'FF'FF

// Суффиксы типов
42L          // long
42l          // long
42LL         // long long
42ll         // long long
42U          // unsigned int
42u          // unsigned int
42UL         // unsigned long
42ULL        // unsigned long long
```

#### Литералы с плавающей точкой

```cpp
// Десятичная форма
3.14
0.5
.5           // 0.5
5.           // 5.0

// Запись в стандартном виде
3e2          // 300.0
1.5e-3       // 0.0015
2E+10

// Суффиксы типов
3.14f        // float
3.14F        // float
3.14         // double (по умолчанию)
3.14d        // double (нестандартный суффикс)
3.14D        // double (нестандартный суффикс)
3.14l        // long double
3.14L        // long double
```

#### Символьные и строковые литералы

```cpp
// Символы (тип char)
'A'
'a'
'0'
'\n'         // символ новой строки
'\t'         // символ табуляции
'\\'         // обратный слеш
'\''         // одиночная кавычка
'\"'         // двойная кавычка

// Строки (указатель const char*)
"Hello"
"Hello World"
""           // пустая строка
"Line 1\nLine 2"

// Сырые строки (C++11)
R"(C:\Users\file.txt)"
R"delimiter(текст с "кавычками")delimiter"

// Строки с префиксами (C++11 и позже)
u8"UTF-8 string"         // UTF-8
u"UTF-16 string"         // UTF-16
U"UTF-32 string"         // UTF-32
L"Wide character string" // wchar_t
```

#### Escape-последовательности

| Escape-последовательность | Описание |
| ------------------------- | -------- |
| `\\` | Обратный слеш (`\`) |
| `\'` | Одиночная кавычка (`'`) |
| `\"` | Двойная кавычка (`"`) |
| `\0` | Нулевой символ (конец строки) |
| `\a` | Звуковой сигнал (bell) |
| `\b` | Backspace |
| `\f` | Подача формы (form feed) |
| `\n` | Перевод строки (newline) |
| `\r` | Возврат каретки (carriage return) |
| `\t` | Горизонтальная табуляция |
| `\v` | Вертикальная табуляция |
| `\xhh` | Символ с шестнадцатеричным кодом `hh` |
| `\ooo` | Символ с восьмеричным кодом `ooo` |
| `\uhhhh` | Символ Unicode с кодом `hhhh` (C++11) |
| `\Uhhhhhhhh` | Символ Unicode с кодом `hhhhhhhh` (C++11) |

```cpp
std::cout << "Line 1\nLine 2\n";
std::cout << "Tab\tseparated\tvalues\n";
std::cout << "Path: C:\\Users\\file.txt\n";
std::cout << "Quote: \"Hello\"\n";
std::cout << "\x41";  // выводит 'A'
std::cout << "\101";  // выводит 'A'
```

### Указатели и ссылки

> **Указатель** — это переменная, которая хранит адрес памяти другой переменной

```cpp
int x = 10;
int* ptr = &x;        // ptr содержит адрес переменной x
int value = *ptr;     // разыменование указателя, value = 10

// Указатель на указатель
int** ptrPtr = &ptr;
```

> **Операция разыменования** — получение значения переменной через указатель на нее

> **Ссылка** — это альтернативное имя для существующей переменной

```cpp
int x = 10;
int& ref = x;         // ref — это ссылка на x
ref = 20;             // изменяет x
int y = ref;          // y = 20

// Ссылки нельзя переприсваивать
// ref = y;  // ОШИБКА: ссылка уже привязана к x
```

### Константы

> **Константа** — это переменная, значение которой не может быть изменено после инициализации

```cpp
// Константа с типом
const int MAX_SIZE = 100;
const double PI = 3.14159;
const char SYMBOL = 'A';

// Константный указатель (указатель, который нельзя изменить)
int x = 10;
const int* ptr = &x;  // ptr нельзя переприсвоить
*ptr = 20;            // но можно изменить значение, на которое он указывает

// Указатель на константу (нельзя изменить значение через указатель)
const int* ptr2 = &x; // можно переприсвоить ptr2
*ptr2 = 20;            // ОШИБКА: нельзя изменить значение через ptr2

// Константная ссылка
const int& ref = x;   // нельзя изменить значение через ref
```

#### Макросы-константы

В C++ часто используются препроцессорные макросы для определения констант:

```cpp
#define MAX_BUFFER_SIZE 256
#define PI 3.14159
#define MIN(a, b) ((a) < (b) ? (a) : (b))
```

> **Примечание:** Макросы обрабатываются препроцессором до компиляции и просто заменяются на их значение. Это отличается от `const` переменных, которые обрабатываются компилятором

#### Constexpr (C++11 и позже)

`constexpr` позволяет вычислять значения на этапе компиляции:

```cpp
constexpr int MAX_SIZE = 100;
constexpr double PI = 3.14159;
constexpr int square(int x) { return x * x; }

int arr[square(10)];  // размер массива вычисляется во время компиляции
```

### Область видимости переменных

В C++ существуют различные области видимости переменных:

```cpp
int globalVar = 10;  // глобальная переменная

void function() {
    int localVar = 20;  // локальная переменная (видна только в функции)
    
    {
        int blockVar = 30;  // видна только в этом блоке
    }
    // blockVar недоступна здесь
}

namespace MyNamespace {
    int nsVar = 40;  // видна в пространстве имён
}

class MyClass {
public:
    int publicMember = 50;   // доступна снаружи класса
private:
    int privateMember = 60;  // доступна только внутри класса
};
```

### Время жизни переменных

**Автоматические переменные (stack):**

```cpp
void function() {
    int x = 10;  // создаётся при входе в функцию
}                // уничтожается при выходе из функции
```

**Статические переменные (static storage):**

```cpp
void function() {
    static int counter = 0;  // инициализируется один раз
    counter++;               // значение сохраняется между вызовами
}
```

**Динамические переменные (heap):**

```cpp
int* ptr = new int(10);  // выделение памяти в heap
delete ptr;              // освобождение памяти
ptr = nullptr;           // хорошая практика
```

**Глобальные переменные:**

```cpp
int globalVar = 10;  // существует на протяжении всей программы
```

## Отличия в C

### 1 Отсутствие встроенного типа `bool`

```c
// В C нет встроенного типа bool
// Вместо этого используется int (0 = false, non-zero = true)
int isActive = 1;  // true
int isActive = 0;  // false

// В C99 стандарте добавлена библиотека <stdbool.h>
#include <stdbool.h>
bool isActive = true;   // теперь можно использовать bool
```

### 2 Отсутствие ссылок

В C нельзя объявлять ссылки, но можно получать адрес переменной (для инициализации указателя)

```c
// В C нет ссылок, только указатели
int x = 10;
int* ptr = &x;      // указатель
int value = *ptr;   // разыменование
```

### 3 Отсутствие типов `wchar_t`, `char16_t`, `char32_t`

```c
// В C есть только char и в C99 добавлен wchar_t
char symbol = 'A';
wchar_t wideSymbol = L'A';

// char16_t и char32_t есть только в C++11 и позже
```

### 4 Отсутствие `constexpr`

```c
// В C нет constexpr
// Константы вычисляются только через макросы или const
const int MAX_SIZE = 100;  // вычисляется во время выполнения

#define MAX_SIZE 100        // вычисляется препроцессором
```

### 5 Другие целые типы

```c
// В C99 добавлены типы из <stdint.h>
#include <stdint.h>

int8_t byte = 127;
int16_t shortInt = 32767;
int32_t integer = 2147483647;
int64_t longInt = 9223372036854775807LL;

uint8_t uByte = 255;
uint16_t uShortInt = 65535;
uint32_t uInteger = 4294967295U;
uint64_t uLongInt = 18446744073709551615ULL;
```

### 6 Отсутствие `long long` в старых стандартах

```c
// long long добавлен в C99
long long bigNumber = 9223372036854775807LL;

// В C89/C90 максимум — long
long number = 2147483647L;
```

### 7 Отсутствие сырых строк

```c
// В C нет сырых строк (R"...")
// Вместо этого используются обычные строки с escape-последовательностями
const char* path = "C:\\Users\\file.txt";

// Или можно использовать макросы
#define PATH "C:\\Users\\file.txt"
```

### 8 Отсутствие Unicode литералов (в старых стандартах)

```c
// В C99 и позже есть поддержка Unicode
#include <uchar.h>

char8_t utf8str[] = u8"Hello";      // C11
char16_t utf16str[] = u"Hello";     // C11
char32_t utf32str[] = U"Hello";     // C11
wchar_t wideStr[] = L"Hello";       // все стандарты
```

### 9 Другие стандарты и особенности

| Особенность    | C89/C90    | C99        | C11              | C17       | C++       |
| -------------- | ---------- | ---------- | ---------------- | --------- | --------- |
| `bool`         | Нет        | Нет        | Да (в stdbool.h) | Да        | Да        |
| `long long`    | Нет        | Да         | Да               | Да        | Да        |
| `<stdint.h>`   | Нет        | Да         | Да               | Да        | Да        |
| `_Bool`        | Нет        | Да         | Да               | Да        | Нет       |
| `_Complex`     | Нет        | Да         | Да               | Да        | Нет       |
| `_Imaginary`   | Нет        | Да         | Да               | Да        | Нет       |
| Инициализаторы | Ограничены | Ограничены | Расширены        | Расширены | Расширены |
| `restrict`     | Нет        | Да         | Да               | Да        | Нет       |

#C #C-Plus-Plus