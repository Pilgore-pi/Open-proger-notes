Код в формах разделен на 2 логических пространства: Клиент и Сервер. Каждая переменная или функция относится к клиенту, к серверу или к клиенту и серверу.

Ранее прямого разделения на Сервер и Клиент не было. Ранее существовал только толстый клиент, но с выходом версии 8.2 появился **тонкий клиент**, который уменьшил количество вычисляемых операций на стороне клиента.

Каждая из директив компиляции определяет, где будет выполняться процедура или функция: на клиенте или на сервере, и как будет происходить взаимодействие с контекстом формы. Контекст формы находится на клиенте ~И НА СЕРВЕРЕ*

Доступность вызова методов одних из других определяется этой схемой:

- `&НаКлиенте`
    - `&НаСервере`
        - `&НаКлиентеНаСервере`~
            - `&НаСервереБезКонтекста`
                - `&НаКлиентеНаСервереБезКонтекста`

## Где доступны директивы

| Директива                         | Где доступно                       |
| --------------------------------- | ---------------------------------- |
| `&НаКлиенте`                      | Модули форм, общие модули, команды |
| `&НаСервере`                      | Модули форм, общие модули          |
| `&НаКлиентеНаСервере`             | Модули форм                        |
| `&НаСервереБезКонтекста`          | Модули форм                        |
| `&НаКлиентеНаСервереБезКонтекста` | Модули форм                        |

Из клиента можно вызывать любую функцию, а, например, из `&НаСервереБезКонтекста` можно вызывать только `&НаКлиентеНаСервереБезКонтекста`

>**Серверный вызов** – это передача какой-то информации с клиентской части «1С:Предприятие 8» на серверную часть с целью вернуть обратно некий набор данных. Сервер не может инициировать запрос к клиенту

При совершении серверного вызова можно увидеть обновление счетчика "Текущие вызовы" в левой нижней окна приложения

| Сущность кода с аннотацией              | Доступность | Сущность кода или источник данных |
| --------------------------------------- | ----------- | --------------------------------- |
| `&НаСервере` любая сущность             | Есть        | Данные формы, база данных         |
| `&НаКлиенте` любая сущность             | Есть        | Данные формы                      |
| `&НаКлиентеНаСервере` любая сущность    | Есть        | Данные формы                      |
| `&НаСервереБезКонтекста` любая сущность | Есть        | База данных                       |
| `&НаКлиентеНаСервереБезКонтекста` метод | Есть        | Только параметры метода           |
| Метод `&НаКлиенте`                      | Нет         | переменная модуля `&НаСервере`    |
| Метод `&НаСервере`                      | Нет         | переменная модуля `&НаКлиенте`    |

>В общих модулях доступны только 2 директивы: `&НаКлиенте` и `&НаСервере`. В общих модулях контекст формы отсутствует~~

* В правой колонке под "базой данных" подразумевается вся информация в базе данных, объекты конфигурации и метаданные конфигурации. Клиент может получить данные из БД только через серверные вызовы.

Директива `&НаСервере` **используется по умолчанию** и подразумевает выполнение кода на сервере, при этом на сервер передается весь контекст формы (для общих форм контекст не передается~).

При использовании директивы `&НаСервереБезКонтекста` отправка контекста не совершается, что позволяет совершать меньше операций и занимать меньше памяти. Однако можно передать необходимые данные через параметры серверного метода

Рекомендуется совершать минимальное количество серверных вызовов и избегать их выполнение в цикле. Обычно, можно подготовить данные для отправки одним пакетом, чтобы не плодить много вызовов.

Метод с директивой `&НаКлиентеНаСервереБезКонтекста` полностью аналогичен двум таким же методам с директивами: `&НаКлиенте` и `&НаСервереБезКонтекста`. Метод с такой директивой может взаимодействовать с общими модулями

* Нельзя применять несколько директив к методу и объявлять одинаковые методы с разными директивами

## Конвертация данных формы (клиента) в прикладные объекты (сервер)

Для конвертирования прикладных объектов в данные формы и обратно существует набор глобальных методов:

| Метод | Описание |
|-|-|
| `ЗначениеВДанныеФормы(значение, объектФормы)` | преобразует объект прикладного типа в данные формы |
| `ДанныеФормыВЗначение(объектФормы, тип)` | (не рекомендуется) преобразует данные формы в объект прикладного типа. **Нельзя преобразовать в объект типа `ТабличнаяЧасть`**. Эффект данного метода полностью совпадает с метдом `РеквизитФормыВЗначение()`. Данный метод требует обязательное указание типа данных, в то время, как `РеквизитФормыВЗначение()` автоматически выводит тип |
| `КопироватьДанныеФормы(источник, приемник)` | Копирует данные одного объекта формы в другой. Возвращает значение Истина, если копирование произведено, или Ложь, если структура объектов несовместима. Метод доступен `&НаКлиенте` |
| `<УправФорма>.РеквизитФормыВЗначение(имяРеквизита, [тип])` | преобразует реквизит данных формы в объект прикладного типа |
| `<УправФорма>.ЗначениеВРеквизитФормы(значение, имяРеквизитаФормы)` | выполняет преобразование объекта прикладного типа в заданный реквизит формы |

Все методы, кроме `КопироватьДанныеФормы`, не доступны на клиенте

Упомянутый параметр `объектФормы` может представлять один из типов формы:

- `ДанныеФормыСтруктура`
- `ДанныеФормыКоллекция`
- `ДанныеФормыСтруктураСКоллекцией`
- `ДанныеФормыДерево`

В целом, только эти типы данных поддерживают преобразования в прикладные объекты (помимо примитивных типов)

При преобразовании данных формы в прикладные объекты и обратно используется кеширование объектов, но при этом выполняется проверка актуальности версии объекта в кеше

При выполнении стандартных действий (открытие формы, выполнение стандартной команды Записать и т. д.) в форме с основным реквизитом преобразование выполняется автоматически

Использование данных методов обычно удобнее, так как они имеют, например, информацию о типе реквизита формы. Кроме того, метод РеквизитФормыВЗначение() выполняет установку соответствия данных формы и объекта, которая используется при формировании сообщений (см. [здесь](https://its.1c.ru/db/v837doc/content/src/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0/%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0%206.%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D1%8B%D0%B9%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81.htm_?anchor=_ref220330559).

При преобразовании ТаблицыЗначений и ДереваЗначений, требуется чтобы количество всех колонок было не меньше, чем в соответствующих элементах формы (ДанныеФормыКоллекция, ДанныеФормыДерево)

> Колонки реквизитов, не связанные с данными, не участвуют в преобразовании значений между данными формы и объектами информационной базы и обратно. Колонки, отсутствующие в данных объекта, очищаются при преобразовании в данные формы

**Пример:**

```bsl
&НаСервере
Процедура ПересчитатьНаСервере()

    // Преобразует реквизит Объект в прикладной объект
    Документ = РеквизитФормыВЗначение(«Объект»);

    // Выполняет пересчет методом, определенным в модуле объекта
    Документ.Пересчитать();

    // Преобразует прикладной объект обратно в реквизит
    ЗначениеВРеквизитФормы(Документ, «Объект»);

КонецПроцедуры
```

> **`ЗначениеВРеквизитФормы()`** необходимо использовать, если происходит редактирование данных формы на сервере, полученных через `РеквизитФормыВЗначение()`, чтобы оповестить форму о совершенных изменениях.

Если бы мы сразу в этой процедуре изменили что-нибудь на форме, то она бы перерисовалась сама собой. А, так как вызывается метод объекта, который никак не связан с представлением, то надо бы "оповестить" форму о том, что ее изменили.

#question

> **Можно ли выполнять преобразование вложенных данных формы, типа Объект.Товары?**

-----

## Предопределенные значения на клиенте

Значение предопределенных данных `&НаКлиенте` можно получить только через функцию `ПредопределенноеЗначение()`

Метод применим к пользовательским и системным перечислениям, а также к предопределенным элементам справочника

```bsl
// Пользовательское перечисление
ЮрФизЛицо = ПредопределенноеЗначение("Перечисление.ЮридическоеФизическоеЛицо.ЮридическоеЛицо");

// Системное перечисление (типСистемногоПеречисления.Значение)
ТипДиаграммы = ПредопределенноеЗначение("ТипДиаграммы.ВогнутаяПоверхность");

// Предопределенный элемент справочника

```

#1С #1С/Язык_программирования
