Назад: [[06 Обобщения]]

В метод передается лямбда ***по имени***, что позволяет делать ленивые вычисления

```scala
def maybeExpensive(doIt: Boolean, expensive: => String) {
  if (doIt) println(expensive)
}

// (0 to 1000000).toString is never called!
maybeExpensive(false, (0 to 1000000).toString)

// It is called and used this time
maybeExpensive(true, (0 to 10).toString)
```

Отличие call-by-name и `Function0`, и побочные эффекты:
- Параметр вида `=> T` — call-by-name: выражение вычисляется каждый раз, когда параметр используется в теле функции.
- `() => T` — это `Function0`, объект-функция, передаётся как значение и вызывается `f()`. Call-by-name удобнее синтаксически.
- Если нужно вычислить выражение только один раз (лениво и затем кэшировать), можно использовать `lazy val` внутри функции или извне.

Примеры:

```scala
def repeated(expensive: => Int): Unit = {
    println("first: " + expensive)
    println("second: " + expensive)
}

var i = 0
def next(): Int = { i += 1; i }

repeated(next()) // next() будет вызван дважды => печатает first:1 second:2

// Чтобы вызвать только один раз, обернем в lazy val
def repeatedOnce(expensive: => Int): Unit = {
    lazy val cached = expensive
    println("first: " + cached)
    println("second: " + cached)
}

i = 0
repeatedOnce(next()) // next() вызван один раз => first:1 second:1
```

Параметры по-значению (call-by-value) — обычные параметры, вычисляются до входа в функцию. Call-by-name может быть использован для управления вычислениями и создания control-structures (например, собственных `if`/`while`-подобных конструкций)

Далее: [[08 Паттерн Matching]]

#Scala