
> **Лямбда выражение** — это анонимная функция, которая может быть определена в месте её использования и передана как аргумент другим функциям или сохранена в переменную

Лямбда выражения позволяют писать компактный и выразительный код, особенно при работе с алгоритмами стандартной библиотеки и функциональным программированием.

## Синтаксис лямбда выражений

Базовая структура лямбда выражения:

```cpp
[capture](parameters) -> return_type { body }
```

Состав лямбда выражения:

- **Захват (capture)** — список переменных из окружающей области, доступных внутри лямбды
- **Параметры (parameters)** — список параметров, как в обычной функции
- **Тип возвращаемого значения (return_type)** — тип возвращаемого значения (опционально, может быть выведен автоматически)
- **Тело (body)** — код лямбда выражения

```cpp
// Простая лямбда без параметров и без возвращаемого значения
auto printMessage = []() { std::cout << "Hello!"; };
printMessage();

// Лямбда с параметрами
auto add = [](int a, int b) { return a + b; };
int result = add(5, 3); // 8

// Лямбда с явным типом возвращаемого значения
auto multiply = [](int a, int b) -> int { return a * b; };

// Сокращенная запись (если в теле одна строка кода)
auto subtract = [](int a, int b) { return a - b; };
```

## Захват переменных

> Захват — это механизм, позволяющий лямбде получать доступ к переменным из окружающей области видимости

### Захват по значению

При захвате по значению переменная копируется в момент создания лямбды. Изменения внутри лямбды не влияют на оригинальную переменную.

```cpp
int x = 10;
int y = 20;

// Захват конкретных переменных по значению
auto func1 = [x, y]() { 
    std::cout << x << " " << y; // 10 20
};

// Захват всех переменных по значению
auto func2 = [=]() { 
    std::cout << x << " " << y; // 10 20
};

x = 100;
func1(); // 10 20 (x не изменилась в лямбде)
func2(); // 10 20 (x не изменилась в лямбде)
```

### Захват по ссылке

При захвате по ссылке лямбда получает доступ к оригинальной переменной. Изменения внутри лямбды влияют на оригинальную переменную.

```cpp
int x = 10;
int y = 20;

// Захват конкретных переменных по ссылке
auto func1 = [&x, &y]() { 
    x += 5;
    y += 5;
};

// Захват всех переменных по ссылке
auto func2 = [&]() { 
    x += 10;
    y += 10;
};

func1();
std::cout << x << " " << y; // 15 25

func2();
std::cout << x << " " << y; // 25 35
```

### Смешанный захват

Можно комбинировать захват по значению и по ссылке:

```cpp
int x = 10;
int y = 20;
int z = 30;

// Захват x и y по значению, z по ссылке
auto func = [x, y, &z]() { 
    // x и y — копии, z — ссылка
    z = x + y;
};

func();
std::cout << z; // 30
```

### Захват с инициализацией (C++14)

Можно инициализировать переменные захвата с новыми значениями:

```cpp
int x = 10;

// Захват x по значению и создание новой переменной y
auto func = [x, y = x * 2]() { 
    std::cout << x << " " << y; // 10 20
};

x = 100;
func(); // 10 20
```

## Модификаторы параметров

Лямбда выражения поддерживают те же модификаторы параметров, что и обычные функции.

```cpp
// Параметр по значению
auto func1 = [](int x) { x += 10; };

// Параметр по ссылке (редко используется в лямбдах)
auto func2 = [](int& x) { x += 10; };

// Параметр-константная ссылка
auto func3 = [](const int& x) { std::cout << x; };

// Параметры с типом auto (шаблонная лямбда, C++14)
auto func4 = [](auto a, auto b) { return a + b; };
```

## Изменяемые лямбды (mutable)

По умолчанию лямбда, захватившая переменные по значению, не может их изменять. Модификатор `mutable` позволяет изменять захваченные по значению переменные внутри лямбды (изменяются только копии).

```cpp
int x = 10;

// Ошибка компиляции: нельзя изменять захваченные по значению переменные
auto func1 = [x]() { x += 5; };

// Правильно: используем mutable
auto func2 = [x]() mutable { 
    x += 5;
    std::cout << x; // 15
};

std::cout << x; // 10 (оригинальная переменная не изменилась)
```

## Типы возвращаемого значения

Тип возвращаемого значения обычно выводится автоматически, но может быть указан явно:

```cpp
// Автоматический вывод типа
auto func1 = [](int a, int b) { return a + b; };

// Явное указание типа
auto func2 = [](int a, int b) -> double { return a + b; };

// Лямбда без возвращаемого значения (void)
auto func3 = [](int x) -> void { std::cout << x; };

// Лямбда с условным возвращаемым типом (требует явного указания)
auto func4 = [](int x) -> int { 
    if (x > 0) return x;
    return -x;
};
```

## Использование лямбд с алгоритмами STL

Лямбда выражения часто используются с алгоритмами стандартной библиотеки:

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// std::sort с лямбдой
std::sort(numbers.begin(), numbers.end(), 
    [](int a, int b) { return a > b; }); // сортировка по убыванию

// std::find_if с лямбдой
auto it = std::find_if(numbers.begin(), numbers.end(),
    [](int x) { return x > 3; });

// std::for_each с лямбдой
std::for_each(numbers.begin(), numbers.end(),
    [](int x) { std::cout << x << " "; });

// std::transform с лямбдой
std::vector<int> squared(numbers.size());
std::transform(numbers.begin(), numbers.end(), squared.begin(),
    [](int x) { return x * x; });
```

## Рекурсивные лямбды

Для создания рекурсивной лямбды необходимо захватить саму лямбду по ссылке:

```cpp
// Вычисление факториала рекурсивно
std::function<int(int)> factorial = [&factorial](int n) -> int {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
};

int result = factorial(5); // 120
```

> Для рекурсивных лямбд необходимо использовать `std::function`, так как в момент определения лямбды она ещё не полностью сформирована

## Возвращаемое значение по ссылке

Лямбда может возвращать значение по ссылке, но это требует особой осторожности:

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// Возврат по ссылке
auto getElement = [&numbers](int index) -> int& {
    return numbers[index];
};

getElement(2) = 100; // numbers[2] теперь равно 100
```

> Возвращение ссылки на локальные переменные лямбды может привести к ошибкам и неопределённому поведению, так как ссылка будет недействительна после выхода из лямбды

## Обобщённые лямбды (шаблонные лямбды, C++14)

Параметры лямбды могут быть типа `auto`, что делает лямбду шаблонной:

```cpp
// Шаблонная лямбда, работающая с любыми типами
auto add = [](auto a, auto b) { return a + b; };

int result1 = add(5, 3);           // 8
double result2 = add(5.5, 3.2);    // 8.7
std::string result3 = add("Hello", " World"); // "Hello World"
```

## Сравнение с обычными функциями

```cpp
// Обычная функция
int regularAdd(int a, int b) {
    return a + b;
}

// Лямбда выражение
auto lambdaAdd = [](int a, int b) { return a + b; };

// Использование одинаково
int result1 = regularAdd(5, 3);
int result2 = lambdaAdd(5, 3);
```

Преимущества лямбд:

- Определяются в месте использования, что улучшает читаемость
- Имеют доступ к переменным окружающей области через захват
- Удобны для передачи в функции высшего порядка и алгоритмы STL
- Могут быть встроены компилятором для оптимизации

Недостатки лямбд:

- Сложнее отлаживать
- Могут усложнить код при чрезмерном использовании
- Требуют понимания механизма захвата переменных

#C-Plus-Plus #GENERATED
