> **Регулярные выражения** – это язык поиска и замены подстроки в тексте

> Строка поиска со специальным синтаксисом регулярных выражений называется _**паттерном**_

Существуют различные реализации (версии) этого языка (Python, .NET, JavaScript и т. д.), которые отличаются дополнительными операторами и возможностями. Все эти версии основаны на единой универсальной версии регулярных выражений. Существуют, также, отдельные версии регулярных выражений, к примеру, в операторе SQL `like` используется упрощенный язык регулярных выражений

Регулярные выражения очень тяжело воспринимаются, если оно имеет хотя бы немного внушительный размер, поэтому, практически всегда, следует тестировать создаваемое регулярное выражение на подготовленном тексте с вариантами строк, которые как соответствуют, так и не соответствуют паттерну. Сам процесс тестирования максимально прост, достаточно иметь подготовленное выражение и набор тестируемых строк. Существуют специальные сервисы для тестирования:

- [regex101.com](https://regex101.com/)
- Visual Stuido Code: нажатием комбинации клавиш `Ctrl + F` можно открыть окно поиска, которое поддерживает поиск по регулярному выражению в текущем текстовом файле

## Синтаксис

| Синтаксис | Описание                                                               |
| --------- | ---------------------------------------------------------------------- |
| `ara`     | точное совпадение в тексте                                             |
| `[Ii]`    | список допустимых символов для данной позиции (`[Ii]t`): `It`; `it`    |
| `[a-y]`   | любой символ из диапазона (`[a-zA-Z]`, `[0-6]`). Важно, чтобы символы в диапазоне шли в порядке возрастания кода. Например, `[a-z]` корректен, а `[z-a]` — нет. В диапазонах можно использовать любые символы Unicode, если эта кодировка поддерживается парсером регулярных выражений (`[А-Я]`, `[А-ЯЁ]`). Для кириллицы использовать диапазоны можно, но надо учитывать конкретную реализацию и дополнять диапазоны символами ё и Ё, если они нужны |
| `^`       | поиск совпадения в начале строки                                       |
| `$`       | поиск совпадения в конце строки (до `\n`)                              |
| `[^a]`    | любой символ, кроме а ( `[^a-z]` – любой не из диапазона)              |
| `.`       | любой символ                                                           |
| `\d`      | любая цифра                                                            |
| `\D`      | любой символ – не цифра                                                |
| `\s`      | пробельный символ (`\t`, `\v`, `\n`, `\r`, `\f`)                       |
| `\S`      | любой НЕпробельный символ                                              |
| `\w`      | любая буква или цифра                                                  |
| `\W`      | любой символ – не буква и не цифра                                     |
| `\b`      | граница слова, обозначает, что после указанного символа должен идти разделитель (сам разделитель не учитывается). Разделителем считается любой пробельный символ |
| `\B`      | обозначает отсутствие разделителя, после предыдущего символа не должен идти разделитель |

### Квантификаторы

| Квантификатор | Тип     | Описание                                           |
| ------------- | ------- | -------------------------------------------------- |
| `A{n}`        | Жадный  | поиск символов “A” `n` раз подряд                  |
| `A{n,m}`      | Жадный  | поиск от `n` вхождений символа “A” до `m`          |
| `A{n,}`       | Жадный  | поиск от `n` и более вхождений                     |
| `A*`          | Жадный  | поиск любого количества символа “A”                |
| `A+`          | Жадный  | поиск 1 и более вхождений                          |
| `A?`          | Жадный  | поиск 0 или 1 вхождения                            |
| `A*?`         | Ленивый | 0 и более вхождений "A", но как можно меньше       |
| `A+?`         | Ленивый | 1 и более вхождений "A", но как можно меньше       |
| `A??`         | Ленивый | 0 или 1 вхождение, но предпочтительно 0            |
| `A{n,m}?`     | Ленивый | поиск от `n` до `m` вхождений, но как можно меньше |


- Любой специальный символ можно экранировать, чтобы парсер воспринимал этот символ как обычный текст

`a+b` и `a\+b`

Строки для паттерна `a+b`:

```text
ab
aab
aaaaab
```

Строки для паттерна `a\+b`:

```text
a+b
```

### Выражение группировки

`Т|\s` – символ **`Т`** или **пробел** для данной позиции
`фиджи|fidzhi`

Оператор `|` распространяется на всю текущую группу. Чтобы ограничить область действия оператора, нужно использовать круглые скобки:

`location:(фиджи|fidzhi)`

Строки, удовлетворяющие паттерну:

```text
location:фиджи
location:fidzhi
```

## Механизм парсинга регулярных выражений

Регулярное выражение — это строка, задающая шаблон для поиска. Чтобы сравнить этот шаблон со строкой, сначала нужно проанализировать (спарсить) сам шаблон, превратив его в более удобное для обработки внутреннее представление.

### Основные этапы парсинга регулярных выражений

#### 1 Лексический анализ

На этом этапе строка регулярного выражения разделяется на лексемы (токены) — отдельные элементы, например, символы, квантификаторы (`*`, `+`), операторы (`|`), скобки для группировки, диапазоны в квадратных скобках и т.д.

#### 2 Синтаксический анализ

Токены собираются в структурированное представление — часто в виде дерева разбора (синтаксического дерева), где узлы — операции регулярного выражения (конкатенация, альтернативы, квантификаторы, группы), а листья — конкретные символы или классы символов.

При этом учитывается приоритет операторов:

1. Квантификаторы (`*`, `+`, `?`) имеют более высокий приоритет

2. Конкатенация символов идёт после квантификаторов

3. Альтернатива (`|`) обрабатывается последней

#### 3 Построение конечного автомата

Из дерева разбора создаётся конечный автомат (наиболее часто — недетерминированный конечный автомат, NFA), который можно использовать для эффективного сопоставления шаблона с текстом

#### 4 Сопоставление (матчинг)

Конечный автомат «ходит» по входной строке, переходя между состояниями в зависимости от символов. Если он достигает конечного состояния, значит строка соответствует регулярному выражению

### Важные моменты

- Парсинг регулярных выражений — это процесс преобразования текстового описания шаблона в структуру, пригодную для дальнейшей обработки

- Для реализации парсинга часто используют рекурсивные методы или парсер-комбинаторы

- В разных реализациях регулярных выражений (например, Perl, Python, .NET, JavaScript) механизмы парсинга могут немного отличаться, добавляя поддержку расширенных возможностей (обратные ссылки, условные выражения, квантификаторы с жадностью и ленивостью и т.д.)

- Исторически одним из первых механизмов парсинга и исполнения регулярных выражений был алгоритм Кена Томпсона (1968), основанный на построении недетерминированного конечного автомата

Таким образом, парсинг регулярных выражений — это этап, когда исходный шаблон разбирается на элементы, структурируется в виде дерева, а потом преобразуется в машину состояний для последующего поиска соответствий в тексте

## Примеры регулярных выражений с тестовой базой

| Regex     | Description                                    |
| --------- | ---------------------------------------------- |
|  |  |

### Поиск любых символов вплоть до последней точки

```regex
^(.*)\.
```

Примеры для тестирования:

```text
.
.123
abcd.
a b c   d.
abcd.efg.
1234.
1234.5678.
1234..abc..
abcd.efgh
abcd .efgh
abcd. efgh
abcd,
abcd
```

### Телефонные номера

#### Любые международные номера телефонов

```regex
^\+?\d{1,4}[-.\s]?$$?\d{1,3}$$?[-.\s]?\d{1,4}[-.\s]?\d{1,4}[-.\s]?\d{1,9}$
```

#### Номера российского региона

Опционально допускаются скобки, дифисы и пробелы, а также начало номера на `8` или `+7`:

```regex
^(\+7|8)\s?(?:\((\d{3})\)|(\d{3}))\s?\d{3}[-\s]?\d{2}[-\s]?\d{2}$|^(\+7|8)\s?(?:\((\d{3})\)|(\d{3}))\s?\d{3}[-\s]?\d{4}$
```

Примеры для тестирования:

```text
Корректные номера общего плана:

+1 234 567 8900
(495) 123-45-67
123-456-7890
+44 20 7946 0958

Некорректные номера общего плана:

+7 926 123 45 67890
123-45-678
+7-926-123-45-67-
+7 926 12 3456 7890 1234
12345abc678
123_456_7890

Корректные российские номера:

+79044402117
89044402117
+7(904)440-21-17
8(904)440-21-17
+7904440-21-17
8904440-21-17
+7(904)4402117
8(904)4402117
8 (904) 440-21-17
+7 904 440-21-17
8 904 440-21-17
+7 (904) 4402117
8 (904) 4402117
+7 (904) 440 2117
8 (904) 440 2117

Некорректные российские номера:

+7 (904 440 2117
8 904) 440 2117
```

### Email-адрес

Только латинские буквы:

```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

```text
Корректные примеры:

simple@example.com
user.name+tag+sorting@example.com
user_name@example.co.uk
user-name@example.org
user123@example123.com

Некорректные:

plainaddress
@missingusername.com
username@.com
username@com
username@site..com
username@site,com
username@site!com
user name@example.com
username@ example.com
username@example.com.
username@-example.com
username@example.c
```

### IP-адрес

IPv4 адрес:

```regex
^(\d{1,3}\.){3}\d{1,3}$
```

```text
Корректные примеры:

192.168.0.1
127.0.0.1
8.8.8.8
255.255.255.255

Некорректные примеры:

256.100.50.25
192.168.1
192.168.0.1.1
192.168.0.a
192..168.0.1
```

### URL-адрес

```regex
^(https?://)?([\w.-]+)\.([a-z.]{2,6})([/\w .-]*)*/?$
```

Тестирование:

```text
Корректные примеры:

http://example.com
https://www.example.com
example.com
https://sub.domain.co.uk/path/to/page
http://localhost:8000/

Некорректные примеры:

htt://example.com
example
http://example.c
http://exam_ple.com
http:/example.com
```

### Пароль

Пароль минимум 8 символов, буквы и цифры

```regex
^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$
```

Тестирование:

```text
Корректные примеры:

password1
Pass1234
abcdefgh9

Некорректные примеры:

password
12345678
pass1
pass word1
```

### Логин

От 3 до 16 символов, буквы, цифры, `_`, `-`

```regex
^[a-zA-Z0-9_-]{3,16}$
```

Тестирование:

```text
Корректные:

user_1
user-name
Username123

Некорректные:

Us
user!name
user name
user$name
```

[[Регулярные выражения в C-Sharp]]

#Regex
