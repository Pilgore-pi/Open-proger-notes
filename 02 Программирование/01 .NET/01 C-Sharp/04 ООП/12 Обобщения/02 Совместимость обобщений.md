> По умолчанию, обобщенные типы не являются совместимыми с такими же обобщенными типами, но разными типами универсальных параметров. Это явление называется ***Инвариантностью***.

```csharp
// Список объектов и список строк несовместимы между собой

List<object> objs = new List<string>(); // compile error

List<string> strs = new List<object>(); // compile error
```

Однако, можно специфицировать, что универсальные параметры могут быть преобразованы в более общий или более узкий тип.

> Вид совместимости, когда обобщенный тип с более **общим** универсальным параметром совместим с типом с более **узким** типом параметра, называется ***Ковариантностью***

> Вид совместимости, когда обобщенный тип с более **узким** универсальным параметром совместим с типом с более **общим** типом параметра, называется ***Контрвариантностью***

Встроенный интерфейс `IEnumerable<T>` поддерживает коваринтность, то есть коллекция более общих типов может быть инициализирована коллекцией более конкретных типов:

```csharp
// модификатор out указывает на то, что IEnumerable<T> совместим с IEnumerable<U> where U : T
public interface IEnumerable<out T> : System.Collections.IEnumerable { ... }

IEnumerable<string> strings = new List<string>();

IEnumerable<object> objects = strings; // OK
```

Ковариантность типа `IEnumerable<T>` обуславливается его ограничениями — элементы коллекции доступны только для чтения

```csharp
public delegate TResult MyDelegate<in T, out TResult>(T arg);

MyDelegate<object, ArgumentException> fn1 = null;
// Явного приведения типа не требуется 
MyDelegate<string, Exception> fn2 = fn1;
Exception e = fn2(""); 
```
Резюмируя виды совместимости обобщений, можно выделить следующие термины:

* Инвариантность — несовместимость обобщенных типов
* Ковариантность (out) — допускается upcast — возможно привести к базовому типу
* Контрвариантность (in) — допускается downcast —  возможно привести к производному типу
* Вариантность = ковариантность или контрвариантность

> Обобщенные типы не могут быть и ковариантыми и контрвариантными одновременно (недопустимо совмещение модификаторов `in` и `out`)

Если бы тип-параметр был и ковариантным, и контрвариантным одновременно, это противоречило бы логике наследования, и нарушило бы типобезопасность: нельзя одновременно требовать, чтобы можно было подставлять как базовые, так и производные типы — это приведет к ошибкам исполнения:

```cs
interface IExample<T>
{
    T Get();
    void Set(T value);
}
```

Если сделать `T` одновременно и `out`, и `in`:

- `T` используется на выводе (Get) — нужна ковариантность

- `T` используется на вводе (Set) — нужна контрвариантность

CLR не сможет безопасно обработать такой тип-параметр, последствия будут непредсказуемы

> Все классы и структуры инвариантны

> Вариантными могут быть только универсальные параметры интерфейсов и делегатов

Вариантность возможна только для интерфейсов и делегатов, потому что:

- **Класс** — это конкретная реализация, там хранятся данные, изменение логики ковариантности/контравариантности может привести к нарушению инкапсуляции и ошибкам времени выполнения

- **Интерфейсы и делегаты** описывают только сигнатуры методов, не содержат реализации и состояния, поэтому CLR может гарантировать безопасное использование вариантности

```cs
IEnumerable<out T> // ковариантность (только на вывод)
Action<in T>       // контрвариантность (только на ввод)
```

Обобщенные методы, чисто технически, не могут поддерживать вариантность, так как механизм наследования для них недоступен

[[03 Наследование обобщений|Наследование обобщений]]

#C-Sharp #OOP #OOP/Generics #C-Sharp/Generics 
