
Назад: [UPDATE - Изменение данных](08%20UPDATE%20-%20Изменение%20данных.md)
Далее: [Язык DDL](01%20Язык%20DDL.md)

В PostgreSQL существует 3 подхода сопоставления с образцом:

- Операторы `LIKE` (`~~`), `ILIKE` (`~~*`)
- Оператор `SIMILAR TO`
- Регулярные выражения стандарта POSIX (`~`, `~*`, `regex_matches()`, `regex_replace()`)

Что такое регулярные выражения можно узнать здесь

## Операторы сопоставления с образцом

| Оператор | Описание | Пример |
| `~` | соответствует регулярному выражению POSIX, чувствителен к регистру | `'thomas' ~ '.*thomas.*'` |
| `~*` | соответствует регулярному выражению POSIX, не чувствителен к регистру | `'thomas' ~* '.*Thomas.*'` |
| `!~` | не соответствует регулярному выражению POSIX, чувствителен к регистру | `'thomas' !~ '.*Thomas.*'` |
| `!~*` | не соответствует регулярному выражению POSIX, не чувствителен к регистру | `'thomas' !~* '.*vadim.*'` |
| `~~` или `LIKE` | соответствует регулярному выражению, не чувствителен к регистру | `'thomas' !~* '.*vadim.*'` |
| `!~~` или `NOT LIKE` | не соответствует регулярному выражению, не чувствителен к регистру | `'thomas' !~* '.*vadim.*'` |
| `~~*` или `ILIKE` | соответствует регулярному выражению, не чувствителен к регистру | `'thomas' !~* '.*vadim.*'` |
| `!~~*` или `NOT ILIKE` | не соответствует регулярному выражению, не чувствителен к регистру | `'thomas' !~* '.*vadim.*'` |
| `SIMILAR TO` | соответствует регулярному выражению **SQL** | |

### `LIKE` и `ILIKE`

Синтаксис

```sql
string LIKE pattern [ESCAPE escape-character]

string ILIKE pattern [ESCAPE escape-character]

string NOT LIKE pattern [ESCAPE escape-character]

string NOT ILIKE pattern [ESCAPE escape-character]
```

Операторы `LIKE` и `ILIKE` возвращают значение типа `boolean` (`true`, если строка соответствует регулярному выражению, `false` в противном случае)

Регулярное выражения, используемое в операторе `LIKE` подразумевает совпадение сначала строки и до ее конца, то есть, если строка в середине текста, то совпадения не будет

- Знак подстановки (wildcard) `_` означает любой символ в текущей позиции (аналог `.` в POSIX)
- Знак подстановки `%` означает любое количество любых символов (аналог `.*` в POSIX)

Чтобы выполнять поиск самих символов `_` и `%`, нужно применять экранирующий символ, по умолчанию — это `\`. Чтобы указать другой экранирующий символ, применяется оператор `ESCAPE '<эранирующая строка>'`

> Оператор `ILIKE` специфичен для PostgreSQL. В других СУБД используются другие языковые конструкции, такие как `COLLATE NOCASE`

### `SIMILAR TO`

Оператор SIMILAR TO возвращает `true` или `false` в зависимости от того, соответствует ли данная строка шаблону или нет. Он работает подобно оператору `LIKE`, только его шаблоны соответствуют определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют собой гибрид синтаксиса `LIKE` с синтаксисом обычных регулярных выражений (POSIX)

Как и `LIKE`, условие `SIMILAR TO` истинно, только если шаблон соответствует всей строке; это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки. Также подобно `LIKE`, `SIMILAR TO` воспринимает символы `_` и `%` как знаки подстановки, подменяющие любой один символ или любую подстроку, соответственно (в регулярных выражениях POSIX им аналогичны символы `.` и `.*`)

> Оператор `SIMILAR TO` отсутствует в других популярных СУБД (MySQL, Oracle, MS SQL Server, SQLite)

Помимо средств описания шаблонов, позаимствованных от `LIKE`, `SIMILAR TO` поддерживает следующие метасимволы, унаследованные от регулярных выражений POSIX:

- `|` означает выбор (одного из двух вариантов).

- `*` означает повторение предыдущего элемента 0 и более раз.

- `+` означает повторение предыдущего элемента 1 и более раз.

- `?` означает вхождение предыдущего элемента 0 или 1 раз.

- `{m}` означает повторяет предыдущего элемента ровно `m` раз.

- `{m,}` означает повторение предыдущего элемента `m` или более раз.

- `{m,n}` означает повторение предыдущего элемента не менее чем `m` и не более чем `n` раз.

Скобки () объединяют несколько элементов в одну логическую группу.

Квадратные скобки `[...]` обозначают класс символов так же, как и в регулярных выражениях POSIX.

- **Точка (.) не является метасимволом для оператора `SIMILAR TO`**

Как и с `LIKE`, обратная косая черта отменяет специальное значение любого из этих метасимволов. Предложение `ESCAPE` позволяет выбрать другой спецсимвол, а запись `ESCAPE ''` — **отказаться от использования спецсимвола**

### Регулярные выражения POSIX

Регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем операторы `LIKE` и `SIMILAR TO`. Во многих командах Unix, таких как `egrep`, `sed` и `awk` используется язык шаблонов, похожий на описанный здесь

> Другие СУБД могут не поддерживать регулярные выражения POSIX или иметь другой синтаксис (например `REGEXP` в SQLite или `REGEX_LIKE` в Oracle)

Регулярное выражение — это последовательность символов, представляющая собой краткое определение набора строк (регулярное множество). Строка считается соответствующей регулярному выражению, если она является членом регулярного множества, описываемого регулярным выражением. Как и для `LIKE`, символы шаблона непосредственно соответствуют символам строки, за исключением специальных символов языка регулярных выражений. При этом спецсимволы регулярных выражений отличается от спецсимволов `LIKE`. В отличие от шаблонов `LIKE`, регулярное выражение может совпадать с любой частью строки, если только оно не привязано явно к началу и/или концу строки.

Несколько примеров:

```sql
'abcd' ~ 'bc'     true
'abcd' ~ 'a.c'    true — точке соответствует любой символ
'abcd' ~ 'a.*d'   true — * обозначает повторение предыдущего элемента шаблона
'abcd' ~ '(b|x)'  true — | означает ИЛИ для группы в скобках
'abcd' ~ '^a'     true — ^ привязывает шаблон к началу строки
'abcd' ~ '^(b|c)' false — совпадение не найдено по причине привязки к началу
```

### Поиск подстроки `substring()`

Функция `substring()` **с тремя параметрами** производит извлечение подстроки, соответствующей шаблону **регулярного выражения SQL**. Эту функцию можно вызвать в стандартном синтаксисе SQL:

```sql
substring(строка similar шаблон escape спецсимвол)
```

или используя синтаксис уже устаревшего стандарта SQL:1999:

```sql
substring(строка from шаблон for спецсимвол)
```

или в виде обычной функции с тремя аргументами:

```sql
substring(строка, шаблон, спецсимвол)
```

Как и с `SIMILAR TO`, указанному шаблону должна соответствовать вся строка; в противном случае функция не найдёт ничего и вернёт `NULL`. Для выделения в шаблоне границ подстроки, которая представляет интерес в соответствующей этому шаблону входной строке, шаблон может содержать два спецсимвола с кавычками (") после каждого. В случае успешного обнаружения шаблона эта функция возвращает часть строки, заключённую между этими разделителями.

Разделители «спецсимвол + кавычки» фактически разделяют шаблон `substring` на три независимых регулярных выражения, так что, например, вертикальная черта (`|`) в любой из этих трёх частей действует только в рамках этой части. Кроме того, в случае неоднозначности в выборе подстрок, соответствующих этим частям, первое и третье регулярные выражения считаются захватывающими наименьшие возможные подстроки. (На языке POSIX можно сказать, что первое и третье регулярные выражения — «нежадные»)

В качестве расширения стандарта SQL в PostgreSQL допускается указание только одного разделителя, в этом случае третье регулярное выражение считается пустым; также разделители могут отсутствовать вовсе, в этом случае пустыми считаются первое и третье регулярные выражения.

Несколько примеров с маркерами `#"`, выделяющими возвращаемую строку:

```sql
substring('foobar' similar '%#"o_b#"%' escape '#')   oob
substring('foobar' similar '#"o_b#"%' escape '#')    NULL
```

Функция `substring()` **с двумя параметрами**, `substring(строка from шаблон)`, извлекает подстроку, соответствующую шаблону **регулярного выражения POSIX**. Она возвращает первый фрагмент текста, подходящий шаблону, если таковой находится в строке, либо `NULL` в противном случае. Но если шаблон содержит скобки, она возвращает первое подвыражение, заключённое в скобки (то, которое начинается с самой первой открывающей скобки). Если вы хотите использовать скобки, но не в таком особом режиме, можно просто заключить в них всё выражение. Если же вам нужно включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это можно сделать, используя группы без захвата, которые будут описаны ниже.

Несколько примеров:

```sql
substring('foobar' from 'o.b')     oob
substring('foobar' from 'o(.)b')   o
```

Функция regexp_count подсчитывает количество мест, где шаблон регулярного выражения POSIX соответствует строке. Она имеет синтаксис regexp_count(строка, шаблон [, начало [, флаги]]). Шаблон ищется в строке обычно с начала строки, но если указан параметр начало, то начиная с этого индекса. В параметре флаги может передаваться текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Например, буква i во флагах выбирает регистронезависимый режим поиска. Поддерживаемые флаги описаны в Таблице 9.24.

Несколько примеров:

```sql
regexp_count('ABCABCAXYaxy', 'A.')          3
regexp_count('ABCABCAXYaxy', 'A.', 1, 'i')  4
```

#### Функция `regexp_instr()`

Функция `regexp_instr()` возвращает начальную или конечную позицию N-го вхождения шаблона регулярного выражения POSIX в строке или ноль, если такого вхождения нет. Она имеет синтаксис:

```sql
regexp_instr(строка, шаблон [, начало [, N [, выбор_конца [, флаги [, подвыражение]]]]])
```

Шаблон ищется в строке обычно с начала строки, но если указан параметр начало, то начиная с этого индекса. Если указано N, то ищется N-е вхождение шаблона, иначе ищется первое вхождение. Если параметр выбор_конца опущен или равен нулю, функция возвращает позицию первого символа вхождения. Иначе `выбор_конца` должен быть равен одному и функция возвращает позицию символа, следующего за вхождением. В параметре флаги может передаваться текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Например, буква i во флагах выбирает регистронезависимый режим поиска. Для шаблона, содержащего подвыражения в скобках, подвыражение — целое число, которое выбирает представляющее интерес подвыражение: в результате выдаётся позиция подстроки, соответствующей этому подвыражению. Подвыражения нумеруются по порядку открывающих их скобок. Когда подвыражение опущено или равно нулю, в результате выдаётся позиция всего вхождения независимо от подвыражений в скобках.

Несколько примеров:

```sql
regexp_instr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   23
regexp_instr(string=>'ABCDEFGHI', pattern=>'(c..)(...)', start=>1, "N"=>1, endoption=>0, flags=>'i', subexpr=>2)
                                   6
```

#### Функция `regexp_like()`

Функция `regexp_like()` проверяет, встречается ли в строке вхождение шаблона регулярного выражения POSIX, возвращая логическое значение `true` или `false`. Она имеет синтаксис `regexp_like(строка, шаблон [, флаги])`. В параметре флаги передаётся необязательная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Если флаги не указаны, эта функция выдаёт те же результаты, что и оператор `~`. Если указан только флаг `i`, она выдаёт те же результаты, что и оператор `~*`

Несколько примеров:

```sql
regexp_like('Hello World', 'world')       false
regexp_like('Hello World', 'world', 'i')  true
```

#### Функция `regexp_match()`

Функция `regexp_match()` возвращает текстовый массив с совпавшими подстроками из первого вхождения шаблона регулярного выражения POSIX в строке. Она имеет синтаксис `regexp_match(строка, шаблон [, флаги])`. Если вхождение не находится, результатом будет `NULL`. Если вхождение находится и шаблон не содержит подвыражений в скобках, результатом будет текстовый массив с одним элементом, содержащим подстроку, которая соответствует всему шаблону. Если вхождение находится и шаблон содержит подвыражения в скобках, результатом будет текстовый массив, в котором n-м элементом будет n-е заключённое в скобки подвыражение шаблона (не считая «незахватывающих» скобок; подробнее см. ниже). В параметре флаги передаётся необязательная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Допустимые флаги [описаны здесь](https://postgrespro.ru/docs/postgresql/current/functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE)

Несколько примеров:

```sql
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
```

Более подробно о регулярных выражениях [можно почитать здесь](https://postgrespro.ru/docs/postgresql/current/functions-matching)

Далее: [Язык DDL](01%20Язык%20DDL.md)

#DB #SQL/DML #Regex
