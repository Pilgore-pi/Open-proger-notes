
**Исключение** — это объект, который представляет ошибку или необычную ситуацию, возникшую во время выполнения программы. Когда интерпретатор Python встречает ошибку, он создает объект исключения. Если программа не обработает это исключение, выполнение программы будет прервано и выведено сообщение об ошибке

Обработка исключений позволяет перехватывать ошибки, предотвращать аварийное завершение программы и выполнять необходимые действия для восстановления после ошибки

## Иерархия исключений

Python имеет встроенную иерархию исключений, где все исключения наследуются от базового класса `BaseException`. Наиболее часто используемые исключения наследуются от класса `Exception`

Основные встроенные исключения:

- `Exception` — базовый класс для всех обрабатываемых исключений
- `TypeError` — возникает при операции с неправильным типом данных
- `ValueError` — возникает при передаче аргумента неправильного значения
- `KeyError` — возникает при обращении к несуществующему ключу словаря
- `IndexError` — возникает при обращении к несуществующему индексу последовательности
- `AttributeError` — возникает при обращении к несуществующему атрибуту объекта
- `ZeroDivisionError` — возникает при делении на ноль
- `FileNotFoundError` — возникает при попытке открыть несуществующий файл
- `NameError` — возникает при обращении к несуществующей переменной
- `RuntimeError` — возникает при возникновении ошибок во время выполнения

```python
# Примеры исключений
x = 1 / 0  # ZeroDivisionError: division by zero

my_list = [1, 2, 3]
print(my_list[10])  # IndexError: list index out of range

my_dict = {"name": "Alice"}
print(my_dict["age"])  # KeyError: 'age'

int("abc")  # ValueError: invalid literal for int() with base 10: 'abc'

obj = object()
print(obj.name)  # AttributeError: 'object' object has no attribute 'name'
```

## Блок try-except

Блок `try-except` позволяет перехватывать исключения и выполнять код обработки ошибок вместо прерывания программы

```python
try:
    # Код, который может вызвать исключение
    x = 1 / 0
except ZeroDivisionError:
    # Код, который выполнится, если возникнет ZeroDivisionError
    print("Ошибка: деление на ноль")
```

Можно перехватывать несколько типов исключений:

```python
try:
    user_input = input("Введите число: ")
    number = int(user_input)
    result = 10 / number
except ValueError:
    print("Ошибка: введено не число")
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
```

Можно обрабатывать несколько типов исключений в одном блоке `except`:

```python
try:
    user_input = input("Введите число: ")
    number = int(user_input)
    result = 10 / number
except (ValueError, ZeroDivisionError):
    print("Ошибка: неверный ввод или деление на ноль")
```

Можно использовать общий блок `except` для перехвата всех исключений, но это не рекомендуется, так как может скрыть неожиданные ошибки:

```python
try:
    # Некоторый код
    pass
except Exception:
    print("Произошла ошибка")
```

## Получение информации об исключении

Можно получить доступ к объекту исключения и извлечь информацию об ошибке:

```python
try:
    x = 1 / 0
except ZeroDivisionError as e:
    print(f"Тип ошибки: {type(e)}")
    print(f"Сообщение об ошибке: {e}")
    print(f"Аргументы: {e.args}")
```

Объект исключения содержит полезную информацию, которую можно использовать для логирования или отладки:

```python
try:
    my_list = [1, 2, 3]
    print(my_list[10])
except IndexError as e:
    print(f"Произошла ошибка индекса: {e}")
    print(f"Тип исключения: {type(e).__name__}")
```

## Блок else

Блок `else` выполняется, если в блоке `try` не возникло никакого исключения:

```python
try:
    user_input = input("Введите число: ")
    number = int(user_input)
except ValueError:
    print("Ошибка: введено не число")
else:
    print(f"Вы ввели число: {number}")
    print("Обработка успешно завершена")
```

Блок `else` полезен для отделения кода, который может вызвать исключение, от кода, который должен выполниться только при успешном выполнении блока `try`:

```python
try:
    file = open("data.txt", "r")
except FileNotFoundError:
    print("Файл не найден")
else:
    data = file.read()
    print(f"Прочитано {len(data)} символов")
    file.close()
```

## Блок finally

Блок `finally` выполняется всегда, независимо от того, возникло ли исключение или нет. Этот блок используется для выполнения кода очистки ресурсов.

```python
try:
    file = open("data.txt", "r")
    data = file.read()
except FileNotFoundError:
    print("Файл не найден")
finally:
    print("Блок finally выполнен")
```

Блок `finally` гарантирует, что определенный код будет выполнен, даже если возникнет исключение:

```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
finally:
    print("Очистка ресурсов")
```

Полная структура обработки исключений:

```python
try:
    # Код, который может вызвать исключение
    file = open("data.txt", "r")
    data = file.read()
    number = int(data)
except FileNotFoundError:
    print("Файл не найден")
except ValueError:
    print("Ошибка: данные не являются числом")
except Exception as e:
    print(f"Неожиданная ошибка: {e}")
else:
    print(f"Число успешно прочитано: {number}")
finally:
    print("Завершение работы с файлом")
```

## Создание пользовательских исключений

Можно создавать собственные классы исключений, наследуя их от встроенного класса `Exception` или его подклассов:

```python
class CustomError(Exception):
    pass

try:
    raise CustomError("Произошла пользовательская ошибка")
except CustomError as e:
    print(f"Перехвачено пользовательское исключение: {e}")
```

Пользовательские исключения могут содержать дополнительную информацию:

```python
class ValidationError(Exception):
    def __init__(self, message, field):
        self.message = message
        self.field = field
        super().__init__(self.message)

try:
    age = -5
    if age < 0:
        raise ValidationError("Возраст не может быть отрицательным", "age")
except ValidationError as e:
    print(f"Ошибка валидации поля '{e.field}': {e.message}")
```

Можно создавать иерархию пользовательских исключений:

```python
class ApplicationError(Exception):
    pass

class DatabaseError(ApplicationError):
    pass

class ConnectionError(DatabaseError):
    pass

try:
    raise ConnectionError("Не удалось подключиться к базе данных")
except DatabaseError as e:
    print(f"Ошибка базы данных: {e}")
```

## Оператор raise

Оператор `raise` используется для явной генерации исключения:

```python
def validate_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным")
    if age > 150:
        raise ValueError("Возраст не может быть больше 150")
    return True

try:
    validate_age(-5)
except ValueError as e:
    print(f"Ошибка валидации: {e}")
```

Можно переиспользовать текущее исключение с помощью `raise` без аргументов:

```python
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Произошла ошибка деления на ноль")
    raise  # Переиспользует текущее исключение
```

Можно создавать цепочки исключений, используя `raise ... from ...`:

```python
try:
    try:
        x = 1 / 0
    except ZeroDivisionError as e:
        raise ValueError("Неверное значение") from e
except ValueError as e:
    print(f"Исходная ошибка: {e.__cause__}")
    print(f"Текущая ошибка: {e}")
```

## Контекстные менеджеры ПЕРЕМЕСТИТЬ ИЛИ ОСТАВИТЬ?

Контекстные менеджеры обеспечивают удобный способ управления ресурсами и гарантируют их правильное освобождение. Они используют оператор `with`:

```python
with open("data.txt", "r") as file:
    data = file.read()
    print(data)
# Файл автоматически закрывается, даже если возникнет исключение
```

Контекстный менеджер гарантирует, что ресурс будет освобожден, независимо от того, возникнет ли исключение:

```python
try:
    with open("data.txt", "r") as file:
        data = file.read()
        x = 1 / 0  # Исключение возникнет, но файл всё равно закроется
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
```

Можно использовать несколько контекстных менеджеров одновременно:

```python
with open("input.txt", "r") as input_file, open("output.txt", "w") as output_file:
    data = input_file.read()
    output_file.write(data.upper())
```

Можно создавать собственные контекстные менеджеры, определив методы `__enter__` и `__exit__`:

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        if exc_type is not None:
            print(f"Произошла ошибка: {exc_val}")
        return False  # Исключение не будет подавлено

with FileManager("data.txt", "r") as file:
    data = file.read()
    print(data)
```

Альтернативно, можно использовать декоратор `@contextmanager`:

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()

with file_manager("data.txt", "r") as file:
    data = file.read()
    print(data)
```

## Лучшие практики обработки исключений

**Ловите конкретные исключения**, а не все исключения сразу:

```python
# Плохо
try:
    result = 10 / number
except:
    print("Произошла ошибка")

# Хорошо
try:
    result = 10 / number
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
```

**Не подавляйте исключения молча**. Всегда логируйте или обрабатывайте ошибки:

```python
# Плохо
try:
    result = 10 / number
except ZeroDivisionError:
    pass

# Хорошо
try:
    result = 10 / number
except ZeroDivisionError:
    print("Ошибка: деление на ноль")
    # или логируйте ошибку
```

**Используйте контекстные менеджеры** для управления ресурсами вместо блока `finally`:

```python
# Менее удобно
try:
    file = open("data.txt", "r")
    data = file.read()
finally:
    file.close()

# Более удобно
with open("data.txt", "r") as file:
    data = file.read()
```

**Создавайте пользовательские исключения** для специфичных ошибок вашего приложения:

```python
class InsufficientFundsError(Exception):
    pass

def withdraw(account, amount):
    if amount > account.balance:
        raise InsufficientFundsError("Недостаточно средств")
    account.balance -= amount
```

**Предоставляйте полезную информацию** в сообщениях об ошибках:

```python
# Плохо
raise ValueError("Ошибка")

# Хорошо
raise ValueError(f"Возраст {age} не может быть отрицательным")
```

#Python #GENERATED
