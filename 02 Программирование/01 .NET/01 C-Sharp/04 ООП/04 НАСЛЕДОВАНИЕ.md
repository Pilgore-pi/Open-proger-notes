
Назад: [[03.5 Ключевое слово readonly|Ключевое слово readonly]]
Далее: [[05 System.Object. Упаковка и распаковка]]

> Классы могут перенимать **черты** от других классов, этот механизм называется **наследованием**

> **Наследование** — это один из важнейших принципов ООП, позволяющий избежать повторения кода и поддерживать целостность типов

Логически, наследование недоступно для структур, но, фактически, структуры в CLR представлены как **запечатанные** классы (`sealed class`), то есть классы, которые не могут иметь потомков:

Простой пример наследования:

```csharp
// Базовый класс "Горожанин"
public class Citizen {
    
    public string Name { get; set; }
    
    // Метод "Говорить()"
    public void Speak() {
        Console.WriteLine("Speaking...");
    }
}

// Производный класс "Преступник"
public class Criminal : Citizen {
    
    // Неявно определен метод Speak()
    
    // Добавочный метод "Украсть()", которого нет в базовом классе
    public void Steal(object item) {
        // stealing logic
    }
}
```

В этом примере `Criminal` наследуется от `Human`. Это означает, что у `Criminal` есть все свойства и методы `Citizen`, плюс свои собственные

Иерархию наследуемых классов, относящимся к самому верхнему по иерархии типу будем называть **семейством**. В приведенном примере было построено простое семейство типа `Citizen`

> Можно запретить возможность наследования от класса, пометив его модификатором `sealed`. Такие классы называются **запечатанными**

> В CLR Структуры, на самом деле, являются запечатанными классами, которые компилятор пытается располагать на стеке, если это возможно

### Оператор base (ссылка на базовый класс)

Ключевое слово `base` используется для обращения к членам базового класса из производного класса.

```csharp
public class Criminal : Citizen {
    
    // Добавочный метод "Представиться()"
    public void Represent() {
        Console.WriteLine($"{base.Name} is barking...");
    }
}
```

### Переопределение методов

Иногда необходимо изменить поведение метода базового класса в производном классе. Для этого используется ключевое слово `override`

```csharp
public class Citizen {
    
    public virtual void GoHome() {
        Console.WriteLine("Went to home");
    }
}

public class Criminal : Citizen {
    
    // Метод "ПойтиДомой" изменен под реалии преступника
    // Преступники живут в тюрьме
    public override void GoHome() {
        Console.WriteLine("Went to prison");
    }
}
```

#### Сокрытие

Можно не переопределяя метод базового типа, подменить его на новый метод с тем же именем. В таком случае оригинальный метод базового типа будет скрыт и перестанет быть доступным в производном типе.

Такие методы помечаются специальным ключевым словом `new`

```cs
public class Citizen {
    
    public virtual void GoHome() {
        Console.WriteLine("Went to home");
    }
}

public class Criminal : Citizen {
    
    // механизм похожий на virtual-override методы
    public new void GoHome() {
        Console.WriteLine("Went to prison");
    }
}
```

Синтаксически, ключевое слово `new` необязательно, но настоятельно рекомендуется его применять, чтобы избежать неднозначности

Механизм сокрытия происходит при указании метода в производном классе с таким же именем и сигнатурой, независимо от применения ключевого слова `new`

### Абстрактные классы и методы

Абстрактный класс представляет собой нечто, что не является логически достаточно конкретным, чтобы существовать. Нельзя создать объект абстрактного класса. Аналогично существуют абстрактные методы и свойства. Вся идея использования абстрактных классов заключается в наследовании от них и реализации конкретной логики уже в производных классах.

```csharp
// Абстрактный класс "МутныйТип"
public abstract class ShadyGuy {
    
    public abstract void MakeSound(); // нельзя определять реализацию
    
    // никакого скрытого поля не создается
    public abstract string Name { get; set; }
}

public class Dog : Animal {
    
    public override void MakeSound() {
        Console.WriteLine("Bark");
    }
    private string name;
    public string Name => name;
}
```

### Интерфейсы

Интерфейсы определяют контракт, который должны соблюдать классы. Класс может реализовать несколько интерфейсов. Под контрактом подразумевается унифицированный набор возможностей как самого объекта, так и возможностей выполнять действия над объектом, выполняющий контракт.

Экземпляром интерфейса может быть только класс, который **реализует** интерфейс

```csharp
// Интерфейс "Акустический"
public interface IAcoustic {
    // воспроизвести звук
    void MakeSound();
}

// Класс "Горожанин" поддерживающий воспроизведение звука
public class Citizen : IAcoustic {
    
    private void Speak() {
        Console.WriteLine("Hi");
    }
    
    public void MakeSound() {
        Speak();
    }
}

// Класс "Динамик" поддерживающий воспроизведение звука
public class Speaker : IAcoustic {
    
    public bool MusicMode { get; set; } = true;
    
    private void PlayMusic() { }
    private void PlaySound() { }
    
    public void MakeSound() {
        if (MusicMode)
            PlayMusic();
        else
            PlaySound();
    }
}
```

Интерфейс описывает "стандарт", которому классы должны соответствовать, при этом стандарт может быть очень простым без каких-либо конкретных нормативов. По этой причине интерфейсы могут быть пустыми и служить только в качестве флага "этот класс соблюдает такой-то стандарт (контракт)"

### Множественное наследование

> В C\# класс может наследоваться только от **одного базового класса**, но может реализовывать **несколько интерфейсов**

```csharp
// Человек
public interface IHuman {
    void Speak();
}

// Товар
public interface IProduct {
    void Sell();
}

// Класс "Раб" реализующий логику товара и человека
public class Slave : IHuman, IProduct {
    
    public void Speak() {
        Console.WriteLine("yes master...");
    }
    
    public void Sell() {
        Console.WriteLine("Selling slave...");
    }
}
```

Множественное наследование классов запрещено из-за проблемы неоднозначности реализации.

**РАСПИСАТЬ ПРОБЛЕМУ МНОЖЕСТВЕННОГО НАСЛЕДОВАНИЯ**

Интерфейсы, в свою очередь, не имеют конкретной реализации, поэтому, даже если методы из разных интерфейсов повторяются в классе-реализаторе, то CLR может однозначно проанализировать безопасность типов

## Отличия интерфейса от абстрактного класса

| Интерфейс | Абстрактный класс |
| :-- | :-- |
| **Множественная реализация**. Класс может реализовывать множество интерфейсов | Класс может наследоваться только от одного абстрактного класса |
| Используется для определения контракта | Используется для определения базового функционала, который может быть частично реализован |
| Не может содержать конструкторы | Может содержать конструкторы |
| Не может иметь состояния (не содержит полей) | Может иметь состояние (может содержать поля) |
| Члены не могут быть приватными, так как интерфейс имеет ценность только как участник иерархии наследования | Члены могут иметь разный уровень доступа, в том числе и `private` |
| Обобщенные интерфейсы могут быть вариантными (см. [[Совместимость обобщенных типов|02 Совместимость обобщений]]) | Обобщенные классы инвариантны |

Абстрактные классы уже могут содержать часть данных и структуры объекта, они используются, когда часто приходится использовать одно и тоже ядро.

Интерфейс — это то, как сущность может взаимодействовать с миром, например, змея может видеть свет через интерфейс, называемый "зрение", чувствовать запахи через интерфейс "обоняние", питаться через интерфейс "ротовой аппарат".

Интерфейс не имеет предопределенной логики и состояния, он просто требует, чтобы сущность могла определенным образом взаимодействовать с другими объектами.

Можно считать, что интерфейс — это очень абстрактный класс, но никогда нельзя считать абстрактный класс интерфейсом

Далее: [[05 System.Object. Упаковка и распаковка]]

#C-Sharp #OOP
