# ПЛОХАЯ СТАТЬЯ, найти другие источники

> **Индексы** в базе данных — это специальные структуры данных, которые ускоряют поиск и извлечение информации из таблиц, подобно содержательному оглавлению или алфавитному указателю в книге. Без индексов поиск нужных данных означал бы полный просмотр всей таблицы, что занимает очень много времени при больших объемах данных

Индексы хранят значения одного или нескольких столбцов таблицы вместе с указателями на сами строки с этими значениями. Благодаря этому СУБД может быстро переходить к нужной информации, минуя ненужные данные.

Преимущества индексов:

- Значительное ускорение операций SELECT с условиями (фильтрация, сортировка, соединения).
- Возможность быстрого доступа по ключу.

Недостатки индексов:

- 

Но индексы занимают дополнительное место в памяти/на диске и чуть замедляют операции вставки, обновления и удаления, потому что надо поддерживать структуру индекса.

Типичные виды индексов:

- **B-дерево** — самый распространенный, обеспечивает быстрое сортированное хранение и поиск.
- **Хэш-индексы** — для быстрых точных совпадений.
- **Bitmap**
- **GiST**, SP-GiST и др. — специальные индексы для разных типов данных и запросов.
- Полнотекстовый индекс

## B-дерево

B-дерево — это структура данных самобалансирующегося дерева, которая часто используется в качестве алгоритма индексирования в базах данных. Каждый узел дерева состоит из набора ключей и указателей на дочерние узлы; хранение данных осуществляется в иерархической структуре. Деревья B-узлов упорядочены таким образом, что позволяют быстро выполнять поиск, вставку и удаление данных

[Больше о деревьях можно узнать здесь](../../02%20Программирование/Алгоритмы%20и%20структуры%20данных/Деревья.md)

Самое большое преимущество алгоритма B-дерева заключается в минимизации количества дисковых операций ввода-вывода, необходимых для доступа к данным, потому что в B-дереве все узлы-листья находятся на одном уровне, а каждый узел может хранить множество ключей и указателей. Количество ключей и указателей, которое может храниться в узле, определяется параметром, называемым «порядок» дерева

Алгоритм B-дерева работает следующим образом:

1. **Инициализация**: при создании B-дерева создаётся пустой корневой узел. Параметр, задающий максимальное количество ключей («порядок»), которые могут храниться в каждом узле, управляет B-порядком дерева.

2. **Вставка**: при добавлении нового узла в B-дерево алгоритм сначала подыскивает подходящий узел-лист, в который нужно вставить ключ. B-дерево разделяет заполненный узел-лист на два новых узла и перемещает медианный ключ в родительский узел. Пока не достигнут корневой узел, процесс разделения может распространяться по дереву. Благодаря этой процедуре дерево остаётся сбалансированным, а узлы-листья находятся на одинаковой высоте.

3. **Удаление**: когда ключ удаляется из B-дерева, алгоритм ищет узел, который изначально хранил ключ. Если узел-лист хранил ключ, то ключ извлекается и узел может нуждаться в перебалансировке. Алгоритм удаляет предшествующий или последующий лист после листа-узла, удалив ключ с ним, если ключ обнаружен не в узле-листе.

4. **Поиск**: в процессе поиска ключа в B-дереве алгоритм начинает с корневого узла и рекурсивно движется к веткам, пока не найдёт нужный узел-лист. Метод поиска сравнивает искомый ключ с ключами, содержащимися в каждом узле, а затем использует соответствующий указатель для перехода к дочернему узлу, в котором может находиться ключ. Этот процесс продолжается, пока не будет найден искомый ключ или пока не будет определено, что он отсутствует в дереве.

Однако B-деревья обладают некоторыми недостатками:

Излишняя трата ресурсов: B-деревья задействуют большой объём излишнего пространства, поскольку каждый узел в B-дереве содержит указатель на родительский и дочерний узлы.
Сложность: алгоритмы, используемые для вставки, удаления и поиска данных в B-дереве, сложнее по сравнению с другими структурами данных. Это усложняет реализацию и поддержку B-деревьев.
Медленные обновления: обновление данных в B-дереве может быть относительно медленным по сравнению с другими структурами данных. Каждая операция обновления требует множества операций доступа к диску, и этот процесс может быть медленным для больших B-деревьев.

## Bitmap-индексирование

Bitmap-индексирование — это методика индексирования данных, использующая битовые карты (bitmap) для обозначения наличия или отсутствия значения в таблице. Это успешная техника индексирования для таблиц с низкой кардинальностью, где количество уникальных значений в столбце довольно мало по сравнению с общим количеством строк.

Bitmap-индексирование может быть очень эффективным для столбцов с низкой кардинальностью, поскольку битовые карты крайне компактны и их можно быстро сканировать для извлечения данных. Bitmap-индексы очень удобны для применения в хранилищах данных, где необходимо быстро сканировать огромные объёмы данных. Кроме того, они полезны для баз данных, в которых много операций чтения, но мало обновлений или вставок

**Как это работает**

- Для создания bitmap-индекса столбца для каждого уникального значения столбца создаётся отдельный bitmap. Каждый bitmap имеет длину, равную количеству строк в таблице.

- Если значение присутствует в строке, соответствующему биту в bitmap присваивается значение 1, а если оно отсутствует, то присваивается значение 0. (Представьте таблицу, где столбец «Gender» имеет два уникальных значения, например, «Male» и «Female». Если этот столбец имеет bitmap-индекс, можно создать два bitmap, длина каждого из которых равна количеству строк в таблице. Когда в строке встречается «Male» или «Female», соответствующий бит в bitmap «Male» или «Female» получает значение 1, и наоборот. В случае отсутствия значения «Male» или «Female» соответствующему биту присваивается значение 0.)

- Чтобы выполнить запрос при помощи bitmap-индекса, соответствующие в запросе значения bitmap комбинируются при помощи побитовых операторов AND, OR и NOT. (например, если мы хотим найти все строки, где «Gender» равно «Male» И «Age» больше 30, нам сначала нужно получить bitmap «Male» и bitmap «Age > 30» из соответствующих индексов. Затем мы комбинируем эти два bitmap при помощи побитового оператора AND и получаем окончательный bitmap только с единицами в тех позициях, где оба условия истинны. Затем окончательный bitmap используется для получения из таблицы строк, удовлетворяющих запросу.)

Bitmap-индексы имеют множество недостатков, и в том числе:

- **Большой размер**: Bitmap-индексы могут быть большими, особенно при работе с крупными датасетами. Из-за этого они могут оказаться менее эффективными, чем другие методики индексирования.

**Столбцы с высокой кардинальностью**: Bitmap-индексы неэффективны для столбцов с высокой кардинальностью, где количество уникальных значений очень высоко. В таких случаях bitmap-индексы могут становиться очень большими и не помещаться в памяти.

**Смещённое распределение данных**: если данные смещены, у нескольких значений может быть гораздо более высокая частота, чем у других, и bitmap-индексы окажутся неэффективными. Это вызвано тем, что bitmap для наиболее частых значений становятся очень большими и могут доминировать в индексе.

https://habr.com/ru/companies/ruvds/articles/724066/

Создаются индексы следующей командой:

```sql
CREATE INDEX index_name ON table_name (column1, column2, ...);
```

Для уникальных значений:

```sql
CREATE UNIQUE INDEX index_name ON table_name (column);
```

Индексы — это фундаментальная технология для повышения производительности баз данных, особенно при работе с большими объемами данных.[2][3][5][6]

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/collection_627b3c00-c396-41fd-a55f-f68a88616c9a/cb41afc1-9cd2-4b02-8181-49f6b73b6bf5/DLL.csv)
[2](https://sql-ex.ru/blogs/?%2FTipy_indeksov_rukovodstvo_dlJa_nachinajuwih.html)
[3](https://wiki.merionet.ru/articles/indeksy-v-reliacionnoi-baze-dannyx)
[4](https://app.incidenta.tech/library/terms/database/database-indexes/)
[5](https://habr.com/ru/companies/ruvds/articles/724066/)
[6](https://practicum.yandex.ru/blog/indeksy-v-sql-kak-rabotayut-zachem-nuzhny/)
[7](https://informatecdigital.com/ru/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81-%D0%B2-%D0%B1%D0%B0%D0%B7%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%3F/)
[8](https://skyeng.ru/it-industry/programming/indeksy-v-bd-ponyatie-preimushchestva-i-primenenie/)

#DB #DB/Indexes #GENERATED
