
**Метод** — это именованный участок кода, который может быть выполнен несколько раз в различных участках программы

Методы могут иметь **параметры** и могут возвращать результат своей работы, в таком случае метод будет являться **функцией**, метод, который ничего не возвращает называется **процедурой**. В Python оба эти понятия обобщаются под термином "функция", так как функция, которая не возвращает значение явно, автоматически возвращает `None`

Состав методов:

- Сигнатура — совокупность атрибутов, которые идентифицируют метод:
    - Имя метода
    - Состав параметров
        - Количество
        - Имя каждого параметра
        - Значение по умолчанию (опционально)
    - Тип возвращаемого значения (опционально, указывается в аннотации типа)
- Тело метода — код, который ассоциирован с именем метода

```python
# Функция без параметров и без возвращаемого значения (процедура)
def show_message():
    print("Who are you?")

# Функция с параметром без возвращаемого значения
def show_message(text):
    print(text)

# Сокращенная запись через lambda. Используется для простых выражений
show_message = lambda text: print(text)

# Функция с параметрами, возвращающая сумму чисел (функция)
def get_sum(n1, n2, n3, n4):
    result = n1 + n2 + n3 + n4
    return result

# Функция с аннотацией типов
def get_sum(n1: int, n2: int, n3: int, n4: int) -> int:
    result = n1 + n2 + n3 + n4
    return result
```

## Передача параметров

В Python все параметры передаются по значению для неизменяемых типов и по ссылке для изменяемых типов. То есть для типов значений (int, str, tuple) создается копия, а для ссылочных типов (list, dict, set, пользовательские классы) передается ссылка на объект.

Таким образом через ссылку на изменяемый тип можно редактировать его непосредственно в функции, но если мы попытаемся создать совершенно новый объект и поместим его в переменную параметра, то оригинальная ссылка будет продолжать указывать на старые данные.

```python
def change_value(number):
    number *= 2

def change_list(lst):
    lst.append(100)

number = 90
change_value(number)
print(number)  # 90 (не изменилось)

my_list = [1, 2, 3]
change_list(my_list)
print(my_list)  # [1, 2, 3, 100] (изменилось)
```

Однако, если попытаться переассоциировать переменную параметра с новым объектом, то в исходной переменной ничего не поменяется

```python
def change_list_with_recreation(lst):
    lst = [999]  # переменная параметра теперь указывает на другой объект
    lst.append(55)

my_list = [1, 2, 3]
change_list_with_recreation(my_list)
print(my_list)  # [1, 2, 3] (не изменилось)
```

Тип `str` является неизменяемым типом (**Immutable**), то есть при попытке редактирования такой переменной значение не изменяется, а создается новый объект, в который копируется новое значение. Такая особенность этого типа приводит к тому, что строка передаваемая в функцию не может быть изменена.

```python
text = "ABC"
text = text + "DEFG"  # создание нового объекта str
```

## Необязательные параметры

В функциях можно объявлять необязательные параметры, которые имеют значение по умолчанию

```python
def sum_numbers(n1, n2=0):
    return n1 + n2

result1 = sum_numbers(5)        # 5
result2 = sum_numbers(5, 10)    # 15
```

Чтобы интерпретатор мог однозначно определить, какой параметр мы передаем в функцию при её вызове, необходимо в объявлении этой функции необязательные параметры задавать последними в списке параметров.

```python
# Правильно
def func(a, b, c=10, d=20):
    pass

# Ошибка: обязательный параметр после необязательного
def func(a, b=10, c, d=20):
    pass
```

## Параметры переменной длины

### Модификатор `*args`

Модификатор `*args` позволяет передавать неограниченное количество позиционных аргументов в функцию. Внутри функции `args` представляет собой кортеж переданных значений.

```python
def calculate_average(*values):
    if len(values) == 0:
        return 0
    
    return sum(values) / len(values)

avg1 = calculate_average(1.1, 1.5, 2.7, 3)      # 2.075
avg2 = calculate_average(1.1)                    # 1.1
avg3 = calculate_average()                       # 0
```

### Модификатор `**kwargs`

Модификатор `**kwargs` позволяет передавать неограниченное количество именованных аргументов в функцию. Внутри функции `kwargs` представляет собой словарь переданных пар ключ-значение.

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30, city="New York")
# name: Alice
# age: 30
# city: New York
```

### Комбинирование `*args` и `**kwargs`

Можно использовать оба модификатора в одной функции. Порядок должен быть: обычные параметры, затем `*args`, затем `**kwargs`.

```python
def process_data(required, *args, **kwargs):
    print(f"Required: {required}")
    print(f"Args: {args}")
    print(f"Kwargs: {kwargs}")

process_data(1, 2, 3, 4, name="Alice", age=30)
# Required: 1
# Args: (2, 3, 4)
# Kwargs: {'name': 'Alice', 'age': 30}
```

> Модификаторы `*args` и `**kwargs` должны быть последними в списке параметров, чтобы интерпретатор мог однозначно понимать, какие значения соотносятся с какими параметрами

## Именованные параметры

Можно передавать значения параметров в функцию в любом порядке, задав имя параметра, для которого задается значение

```python
def multiply(a, b):
    return a * b

result1 = multiply(b=50, a=4)      # 200
result2 = multiply(4, b=50)        # 200
result3 = multiply(a=4, b=50)      # 200
```

## Перегрузка функций

В Python не существует встроенного механизма перегрузки функций в классическом смысле. Если определить несколько функций с одним именем, то последняя определение перезапишет предыдущие.

```python
def merge(a, b):
    return a + b

def merge(a, b, c):  # Это переопределяет предыдущую функцию
    return a + b + c

# Вызов merge(1, 2) вызовет ошибку TypeError
merge(1, 2, 3)  # 6
```

Однако, можно имитировать перегрузку, используя необязательные параметры или `*args`:

```python
def merge(a, b, c=0):
    return a + b + c

result1 = merge(1, 2)        # 3
result2 = merge(1, 2, 3)     # 6
```

Или с использованием `*args`:

```python
def merge(*args):
    return sum(args)

result1 = merge(1, 2)           # 3
result2 = merge(1, 2, 3)        # 6
result3 = merge(1, 2, 3, 4)     # 10
```

Для более сложных случаев можно использовать проверку типов:

```python
def merge(a, b):
    if isinstance(a, str) and isinstance(b, str):
        return a + b
    elif isinstance(a, int) and isinstance(b, int):
        return a + b
    else:
        raise TypeError("Unsupported types")

result1 = merge("Hello", " World")  # "Hello World"
result2 = merge(5, 10)              # 15
```

## Рекурсия

> **Рекурсия** — это вызов функции внутри этой же функции

> **Глубиной рекурсии** называется количество вложенных вызовов рекурсивной функции

> Любая рекурсия может быть преобразована в цикл, обратное утверждение тоже верно

```python
# Рекурсивное вычисление факториала
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

fact = factorial(6)  # 720
```

```python
# Циклическое вычисление факториала
def factorial(n):
    result = 1
    for i in range(2, n + 1):
        result *= i
    
    return result
```

**Хвостовая рекурсия** — это разновидность рекурсии, при которой вызов функции из этой же функции является последним действием в функции

Хвостовые рекурсии могут быть оптимизированы, благодаря этому факту. Стек вызовов функций может быть минимальным (1 фрейм), так как не нужно хранить контекст вышестоящей функции, потому что эта функция уже не будет выполнять никаких операций после.

В Python оптимизация хвостовой рекурсии не выполняется. Создатель Python Гвидо ван Россум намеренно отказался от этой оптимизации, чтобы облегчить отладку программ, так как полный стек вызовов помогает при анализе ошибок.

```python
# Хвостовая рекурсия (не оптимизируется в Python)
def factorial_tail(n, accumulator=1):
    if n == 1:
        return accumulator
    return factorial_tail(n - 1, n * accumulator)

fact = factorial_tail(6)  # 720
```

## Возвращаемое значение

Функция может возвращать одно значение или несколько значений одновременно в виде кортежа

```python
def get_coordinates():
    return 10, 20  # Возвращает кортеж (10, 20)

x, y = get_coordinates()
print(x, y)  # 10 20
```

Функция может возвращать значения разных типов

```python
def process_data(value):
    if value > 0:
        return True, value * 2
    else:
        return False, 0

success, result = process_data(5)
print(success, result)  # True 10
```

> Если функция не содержит явного оператора `return`, то она автоматически возвращает `None`

```python
def show_message():
    print("Hello")

result = show_message()
print(result)  # None
```

Функция может возвращать другую функцию (функции являются объектами первого класса в Python)

```python
def create_multiplier(factor):
    def multiplier(x):
        return x * factor
    return multiplier

multiply_by_3 = create_multiplier(3)
result = multiply_by_3(10)  # 30
```

## Аннотации типов

Python поддерживает аннотации типов, которые помогают документировать код и использоваться инструментами статического анализа

```python
def add(a: int, b: int) -> int:
    return a + b

def greet(name: str) -> None:
    print(f"Hello, {name}!")

def process(data: list[int]) -> dict[str, int]:
    return {"count": len(data), "sum": sum(data)}
```

Аннотации типов не являются обязательными и не влияют на выполнение кода. Они используются для документации и инструментами типизации, такими как `mypy`.

```python
# Это работает, несмотря на аннотацию типа
result = add("5", "10")  # "510"
```

## Декораторы

**Декоратор** — это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, расширяющую или изменяющую поведение исходной функции

```python
def my_decorator(func):
    def wrapper():
        print("Something before the function call")
        func()
        print("Something after the function call")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Something before the function call
# Hello!
# Something after the function call
```

Декоратор с параметрами:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"Result: {result}")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

add(5, 10)
# Calling add with args=(5, 10), kwargs={}
# Result: 15
```

Декоратор с собственными параметрами:

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Hello!")

say_hello()
# Hello!
# Hello!
# Hello!
```

#Python #GENERATED
