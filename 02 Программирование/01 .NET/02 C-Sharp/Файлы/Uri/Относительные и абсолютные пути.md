В программе для взаимодействия с файлом требуется путь. Этот путь, в большинстве случаев, стоит приводить к абсолютному типу.

~ Вот почему рекомендуется использовать вычисляемые абсолютные пути, в отличие от относительных:

- Из различных контекстов среды выполнения, относительный URI может интерпретироваться по-разному. Например, в зависимости от типа приложения (Windows Service, Web-приложение, контейнеризация и т.д.)
- 

Адрес каталога с файлом сборки -- `.exe` или `.dll` (Debug/Release):

```csharp
string path = AppDomain.CurrentDomain.BaseDirectory;
//OR
path = AppContext.BaseDirectory;
```

Данный адрес зависит от используемой конфигурации (Debug/Release) и может измениться в Runtime. Для Portable-приложения базовым каталогом будет тот, в котором находится приложение.

Переход на уровень выше:

```csharp
string path = AppContext.BaseDirectory;
string parent = Directory.GetParent(path);
```

Показатели путей сборки и базовой папки portable-приложения, находящегося в папке `D:\Andrey`.

```
AppContext.BaseDirectory -- D:\Andrey\
AppDomain.CurrentDomain.BaseDirectory -- D:\Andrey\
Assembly.GetEntryAssembly().Location --
Assembly.GetExecutingAssembly().Location --
```

Те же показатели для приложения в виде проекта Visual Studio:

```
AppContext.BaseDirectory:
C:\...\MyApp\bin\Debug\net7.0\

AppDomain.CurrentDomain.BaseDirectory:
C:\...\MyApp\bin\Debug\net7.0\

Assembly.GetEntryAssembly().Location:
C:\...\MyApp\bin\Debug\net7.0\MyApp.dll

Assembly.GetExecutingAssembly().Location:
C:\...\MyApp\bin\Debug\net7.0\MyApp.dll
```

Еще есть вот это, но оно, похоже, не работает с пробелами и символом `#`:

```cs
public static string GetCurrentDirectory()
{
    var codeBase = Assembly.GetExecutingAssembly().CodeBase;
    var uri = new UriBuilder(codeBase);
    var path = Uri.UnescapeDataString(uri.Path);
    return Path.GetDirectoryName(path);
}
```

#C-Sharp #Files #C-Sharp/Uri
