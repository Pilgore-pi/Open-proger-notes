## Оператор break

> Оператор `break` совершает выход из цикла или знаменует окончание блоков `case` или `default`

```csharp
switch (choice) {
    case 1: Console.WriteLine(a + b); break; // завершает блок case
    case 2:  // break отсутствует, поэтому управление переходит далее к case 3
        case 3: Console.WriteLine("Неподдерживаемая операция"); break;
    default: Console.WriteLine(0); break;
}
```

```csharp
for (int i = 0; i < 10; i++) {
    string choice = Console.ReadLine();
    if (choice == "5") break; // если "5", то прерываем цикл и идем дальше
    
    Console.WriteLine($"your choice is {choice}");
}
```

### Прерывание по метке

Стандартное поведение оператора `break` во вложенных циклах — это прерывание текущего, самого внутреннего цикла, где располагается оператор `break`

```cs
for (int i = 0; i < 3; i++) {
    Console.WriteLine($"Внешний цикл i = {i}");
    
    for (int j = 0; j < 5; j++) {
        if (j == 2)
            break; // прервать только внутренний цикл
        Console.WriteLine($"  Внутренний цикл j = {j}");
    }
}

Console.WriteLine("Циклы завершены");
```

```cs
for (int i = 0; i < 3; i++)        // внешний    цикл 1
for (int j = 0; j < 5; j++) {      // внутренний цикл 2
    
    if (j == 3) break; // если j == 3, то цикл с `k` даже не начнется
    
    for (int k = 0; k < 5; k++) {  // внутренний цикл 3
        Console.WriteLine($"i={i}, j={j}, k={k}");
    }
}
```

С версии C\# 8.0 появилась возможность объявлять метки для блоков кода, чтобы по ним можно было обращаться этим к блокам

```cs
outer:
for (int i = 0; i < 3; i++)        // внешний    цикл 1
for (int j = 0; j < 5; j++) {      // внутренний цикл 2
    
    if (j == 3) break outer; // если j == 3, то прерывает цикл с `i`
    
    for (int k = 0; k < 5; k++) {  // внутренний цикл 3
        Console.WriteLine($"i={i}, j={j}, k={k}");
    }
}
```

## Оператор continue

> **Оператор `continue`** аналогичен оператору `break` в контексте циклов (в операторе `switch-case` не используется), но вместо прерывания и завершения цикла, оператор `continue` немедленно переходит к следующей итерации цикла

Оператор `continue` не поддерживает использование меток для указания, к какому именно циклу перейти. Оператор `continue` всегда действует на ближайший внешний цикл в котором он находится, и его задача — пропустить оставшуюся часть текущей итерации этого цикла и перейти к следующей итерации именно этого цикла

```cs
for (int i = 0; i < 3; i++)        // внешний    цикл 1
for (int j = 0; j < 5; j++) {      // внутренний цикл 2
    
    if (j == 3) continue; // если j == 3, то цикл с `k` даже не начнется
    
    for (int k = 0; k < 5; k++) {  // внутренний цикл 3
        Console.WriteLine($"i={i}, j={j}, k={k}");
    }
}
```

## Оператор return

> Оператор `return` совершает немедленное завершение текущего метода и передает управление далее. Использование оператора допустимо только внутри какого-либо метода

```cs
int GetSum(int n1, int n2) {
    var result = n1 + n2;
    return result;
}

void Print(string srt) {
    if (str == null)
        return;          // прерывание текущего метода
    
    Console.WriteLine(str);
}
```

## Оператор throw

> **Оператор `throw`** используется для _явного создания (выбрасывания)_ исключения в программном коде

- С его помощью программа сообщает о возникшей ошибке или необычной ситуации, прерывая нормальный поток выполнения и переходя к обработчику исключений `catch`, если он существует

- После оператора `throw` обычно указывается объект исключения `Exception`, который содержит информацию о возникшей ошибке

- В блоке `catch` можно использовать `throw;` без выражения для повторного выбрасывания текущего перехваченного исключения, сохраняя при этом исходную трассировку стека (stack trace)

```cs

```

## Оператор goto

> **Оператор `goto`** позволяет передать управление на другую строку в пределах текущего метода, оператора switch/case или внутри блока кода по имени метки.

- В C\# использование `goto` **не рекомендуется** в большинстве случаев, так как он ухудшает читаемость и поддерживаемость кода. Однако бывают сценарии, где применение оправдано.

```cs
int i = 0;

start:
Console.WriteLine(i);
i++;

if (i < 3)
    goto start;

// Вывод: 0, 1, 2

// Аналог с циклом:
for (int i = 0; i < 3; i++)
    Console.WriteLine(i);
```

Как видно из примера, использование цикла на порядок легче воспринимать и анализировать, чем переход по меткам.

Пример с оператором `switch-case`

```cs
int value = 2;
switch (value) {
    case 1:
        Console.WriteLine("Один");
        break;
    case 2:
        Console.WriteLine("Два");
        goto case 3; // Переход к метке case 3
    case 3:
        Console.WriteLine("Три");
        break;
    default:
        Console.WriteLine("Другое");
        break;
}
// Вывод: Два, Три
```

Выход из вложенных циклов:

```cs
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1)
            goto end; // Выход из обоих циклов
        Console.WriteLine($"{i}, {j}");
    }
}

end:
Console.WriteLine("Вышел из циклов");
// Вывод: 0,0 ... 1,0 ... Вышел из циклов
```

- **Метки** объявляются как: `имя_метки:`

- Метка должна находиться **в пределах текущего блока** метода (нельзя переходить между методами, невозможно перейти на строку в другой функции).

- Использование `goto` внутри `switch`: допустимо только `goto case ...` и `goto default;`, переход к обычной метке, находящейся снаружи `switch` приведет к ошибке компиляции.

#C-Sharp