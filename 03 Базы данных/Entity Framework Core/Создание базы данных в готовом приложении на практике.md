
Здесь будет пошаговое руководство по наладке базы данных с использованием фреймворка EF Core

Общий алгоритм дальейшей практической работы можно описать следующими шагами:

1. Установка пакетов Nuget для EF Core
2. Создание моделей SQL таблиц в коде C#
3. Создание и запуск миграции, на основе описанных моделей данных


## 1. Начальные условия

Допустим, что мы уже имеем готовое приложение с пользовательским интерфейсом, которое взаимодействует с простенькой базой данных, представленной в виде одного файла Excel, где определены 2 таблицы (по одной на каждой странице). Данные считываются и записываются непосредственно в файл Excel, который может открыть любой пользователь ОС, что нарушает ограничения доступа к данным

**User (Пользователь приложения):**

- `string Name`: Имя пользователя приложения
- `string PasswordHash`: Хэш-значение пароля пользователя
- `enum Role`: Роль пользователя, разграничивающая его права в приложении. `enum Role { ReadOnly, Admin }`, роль `ReadOnly` позволяет пользователю только читать данные, роль `Admin` позволяет выполнять **CRUD** (Create, Read, Update, Delete) операции
- `DateTime Changed`: Временная метка, показывающее дату и время последнего изменения данных пользователя

**Employee (Информация о сотруднике):**

Это основная таблица БД, с которой взаимодействует пользователь

- `string PhoneNumber`: Номер телефона
- `string FullName`: Полное имя
- `string Division`: Подразделение организации, к которому относится сотрудник
- `string Post`: Должность работника
- `string Building`: Корпус (где работает сотрудник)
- `int Floor`: Этаж
- `DateTime Changed`: Временная метка, показывающее дату и время последнего изменения

### Структура проекта

В гепотетическом проекте нашего приложения есть 3 каталога:

- `Models`: Модели приложения, классы-обертки над сущностями `User` и `Employee`:
    - `User.cs`
    - `Employee.cs`
- `Services`: Сервисные API для упрощенного доступа к файлу Excel
    - `DataApi.cs`: Логика взаимодействия с Excel
- `Views`
    - `AuthView.xaml`: Форма авторизации и регистрации пользователя
    - `WorkView.xaml`: Основная форма работы с данными о сотрудниках организации

### Пример заполненного файла Excel

Первая страница (Employee):

| Подразделение | ФИО | Должность | Номер телефона | Корпус | Этаж |
|:-|:-|:-|:-|:-|:-|
| Отдел управления | Иванов Сергей Владимирович | начальник управления по безопасности | 6004 | 55 | 1 |
| Отдел управления | Смирнова Анна Петровна | ЗГД по кадрам и соц. вопросам | 6006 | 96 | 1 |
| Отдел управления | Кузнецов Алексей Иванович | ЗГД - управляющий делами | 6017 | 128 | 2 |
| Отдел управления | Попова Марина Александровна | главный инженер | 6020 | 128 | 2 |
| Отдел управления | Волков Дмитрий Сергеевич | зам. главного инженера | +79008002030 | 128 | 2 |
| Отдел информационной безопасности | Лебедева Светлана Викторовна | Главный специалист по безопасности | 6301 | 128 | 1 |
| Отдел строительства | Новиков Михаил Андреевич | зам. начальника управления по стр-ву | 6302 |  |  |
|  | Морозова Елена Николаевна | аудитор | 6303 | 128 | 3 |
| Отдел управления | Федоров Олег Юрьевич | первый зам. директора | 6306 | 128 | 4 |
| Отдел безопасности труда | Васильева Наталья Борисовна | ЗГД по безопасности труда | 6307 | 128 | 4 |
| Отдел информационной безопасности | Соколов Павел Дмитриевич | Специалист по инф. безопасности | 6304 | 128 | 4 |
| Отдел информационной безопасности | Павлова Ирина Владимировна |  | 6308 |  |  |
| 13 цех | Михайлов Виктор Сергеевич | начальник участка | 6007 | 19 | 4 |
| 13 цех | Григорьева Татьяна Ивановна | начальник тех. бюро | 60071 | 19 | 4 |

Вторая страница (User):

| Имя | Хэш-пароль | Роль |
|:-|:-|:-|
| adm | 柂꾇⑨ሡ㑟鶰䴀뷉囆㴤׈鲐迦혳ᲅ | Admin |
| user | 柂꾇⑨ሡ㑟鶰䴀뷉囆㴤׈鲐迦혳ᲅ | ReadOnly |

Пароль у пользователей одинаковый: `123qweasd`

## 2. Цель

Целью работы является перенести существующие данные в SQL базу данных и обеспечить программное взаимодействие с этой базой. Так как пользователи могут продолжать предоставлять данные в Excel формате, нужно написать конвертер Excel файлов в записи SQL базы данных

## 3. Подготовка проекта

Для использования EF Core потребуется установить несколько пакетов Nuget:

- **`Microsoft.EntityFrameworkCore`:** Основной пакет для EF Core с базовой функциональностью
- **`Microsoft.EntityFrameworkCore.Sqlite`:** Провайдер базы данных, мы будем использовать SQL Lite, так как это легковесная СУБД, подходящая для нашего маленького приложения. Можно использовать других провайдеров: `Microsoft.EntityFrameworkCore.SqlServer`, `Npgsql.EntityFrameworkCore.PostgreSQL` (от стороннего поставщика)
- **`Microsoft.EntityFrameworkCore.Tools`:** Для поддержки миграций и командной строки в разработке (опционально)

Установить пакеты можно через:

- Менеджер пакетов Nuget в используемой IDE (самый простой вариант)
- Консоль диспетчера пакетов:

```powershell
Install-Package Microsoft.EntityFrameworkCore
Install-Package Microsoft.EntityFrameworkCore.SqlServer
Install-Package Microsoft.EntityFrameworkCore.Tools
```

- .NET CLI:

```bash
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
```

## 4. Создание структуры базы данных

Для создания структуры БД нужно выполнить следующие шаги:

1. Создать модели SQL таблиц в коде C#
2. Создать контекст БД (`DbContext`)
3. Создать и выполнить миграцию


### 4.1 Описание моделей

Существующие модели `User.cs` и `Employee.cs` могут не подходить для создания миграции, поэтому изменим эти классы или создадим свои аналоги

#### Особенности использования классов для маппинга с таблицами SQL

- EF Core использует рефлексию и сгенерированные прокси для отслеживания изменений и загрузки данных

- Свойство может содержать пользовательскую логику в `get`/`set`, при этом EF Core будет корректно сохранять и загружать значение из базы данных

Необходимо, чтобы:

- Свойство было публичным (или имело соответствующий уровень доступа);

- Был корректный тип (совместимый с базой);

- Логика в сеттере не делала что-то, что нарушает целостность данных при загрузке;

Для некоторых сценариев можно использовать так называемые "backing fields" (приватные поля, к которым привязано свойство), а EF Core настроить на работу с ними, чтобы скрыть сложную логику из сеттера

Пример валидного свойства, которое EF Core корректно обработает:

```cs
private string _passwordHash;

public string PasswordHash {
    get => _passwordHash;
    private set {
        // Можно добавить логику валидации или модификации
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("PasswordHash не может быть пустым");
        _passwordHash = value;
    }
}
```

#### Код моделей БД

```cs
public enum Role {
    ReadOnly,
    Admin
}

public class User {
    public int Id { get; set; }  // ORM воспринимает свойство, оканчивающееся на "Id" как первичный ключ

    [Required, MinLength(3), MaxLength(50)]
    public string Name { get; set; }

    [Required, MinLength(6)]
    public string PasswordHash { get; set; }

    [Required]
    public Role Role { get; set; }

    public DateTime Changed { get; set; }
}

public class Employee {

    public int Id { get; set; }  // Первичный ключ

    // Номер телефона: 11 цифр с или без специальных символов ИЛИ простая последовательность цифр длиной от 4 до 11
    [Required, RegularExpression(@"^((\+7|8)\s?(?:\((\d{3})\)|(\d{3}))\s?\d{3}[-\s]?\d{2}[-\s]?\d{2}$|^(\+7|8)\s?(?:\((\d{3})\)|(\d{3}))\s?\d{3}[-\s]?\d{4})|((\s*\d\s*){4,11})$")]
    public required string PhoneNumber { get; set; }
    
    public string? FullName { get; set; }
    
    public string? Division { get; set; }
    
    public string? Post { get; set; }
    
    public string? Building { get; set; }
    
    public int? Floor { get; set; }
    
    public DateTime Changed { get; set; }
}
```

Здесь используются [специальные аннотации](), которые задают ограничения целостности данных

* Регулярные выражения не поддерживаются провайдером БД SQL Lite. Атрибут `[RegularExpression]` создает ограничение только на уровне приложения

##### Валидация по регулярному выражению

Вопрос, что лучше, определить сеттер, где будет описана логика валидации номера телефона по регулярному выражению или использовать специальный атрибут `[RegularExpression]`?

-- Лучше применять атрибут, это обосновывается следующими причинами:

- Сеттер должен быть простым, а валидация — явной и вызываемой отдельно
- Атрибуты из пространства имен System.ComponentModel.DataAnnotations создают декларативные правила валидации, что проще поддерживать и интегрировать с фреймворками валидации, например, в WPF, ASP.NET или Xamarin
- Можно легко задать сообщение об ошибке через свойство `ErrorMessage`
- Валидация через атрибут отделяет логику проверки данных от сеттера свойства, что повышает читаемость и разделение ответственности

Если свойство помечено атрибутом `[RegularExpression]` и при этом само свойство может быть `null`, то ошибка из-за несоответствия регулярному выражению не возникнет

Это связано с тем, что реализация `RegularExpressionAttribute` в .NET автоматически пропускает валидацию, если значение свойства равно `null` или пустой строке `""`. То есть, валидация регулярным выражением применяется только когда значение не пустое

##### Совместимость атрибута Required и модификатора required

Атрибут `[Required]` и модификатор `required` не взаимозаменяемы и дополняют друг друга. Модификатор `required` обязует компилятор проверять инициализировано ли свойство при создании объекта, в то время как атрибут работает на уровне EF Core

### 4.2 Описание контекста БД

Существует 2 способа построения контекста данных:

1. **Вручную**: вариант только для небольших приложений
2. **Через внедрение зависимостей (Dependency Injection, DI)**: применяется для всех современных приложений, использующих EF Core. Считается стандартной практикой, поэтому инструменты фреймворка для создания миграций по умолчанию приспособлены для Dependency Injection

Далее будет описан вариант без **DI**

Управление БД в EF Core происходит через `DbContext`, поэтому необходимо описать контекст для нашего приложения

```cs
internal class AppDbContext : DbContext {

    public AppDbContext(DbContextOptions<AppDbContext> options, string dbLocation) : base(options) {
        DatabaseLocation = dbLocation;
    }

    // Все модели БД (у нас 2 модели)
    public DbSet<Employee> Employees { get; private set; }
    public DbSet<User> Users { get; private set; }
    
    public string DatabaseLocation { get; private init; }
    
    /// <summary> Происходит один раз при создании контекста данных. Служит для
    /// задания параметров подключения и других опций контекста, если они не были заданы извне.
    /// В этом методе обычно указывают строку подключения и базовую настройку провайдера базы</summary>
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {
        if ( ! optionsBuilder.IsConfigured) {
            // Задаем путь к файлу базы данных (.db)
            optionsBuilder.UseSqlite($"Data Source={DatabaseLocation}");
        }
    }
}
```

CRUD операции с сущностями базы выполняются через язык LINQ to Entities. Тип `DbSet<T>` реализует `IQueryable<T>`, что дает возможность применять язык LINQ к таблицам БД

Пример того, как происходит работа с моделями через `AppDbContext`:

```cs
using var context = new AppDbContext(options);

var allEmployees = context.Employees.ToList();
var specificUser = context.Users.FirstOrDefault(u => u.Name == "user1");
```

### 4.3 Выполнение миграции

#### 4.3.1 Подготовка миграций

Если мы не используем **DI**, то нужно дополнительно установить Nuget пакет `SQLitePCLRaw.bundle_green`

```powershell
Install-Package SQLitePCLRaw.bundle_green
```

Миграции выполняются независимо от основного приложения. EF Core анализирует код проекта и ищет реализации `DbContext`. EF Core ожидает внедрение зависимостей, но так как у нас его нет, то возникнет ошибка, так как EF Core не понимает, как запускать миграцию и какие параметры передавать в `DbContext`. По этой причине, необходимо определить класс-фабрику, которая содержит логику создания `DbContext`.

Если этого не сделать, то при выполнении миграции возникнет ошибка:

```text
Unable to create a 'DbContext' of type 'RuntimeType'. The exception 'Unable to resolve service for type 'Microsoft.EntityFrameworkCore.DbContextOptions`1[PhoneCatalog.Services.AppDbContext]' while attempting to activate 'PhoneCatalog.Services.AppDbContext'.
```

Код фабрики:

```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;

namespace PhoneCatalog.Services;

internal class AppDbContextFactory : IDesignTimeDbContextFactory<AppDbContext> {
    public AppDbContext CreateDbContext(string[] args) {
        
        // Инициализация поставщика SQL Lite
        SQLitePCL.Batteries.Init();

        var optionsBuilder = new DbContextOptionsBuilder<AppDbContext>();
        optionsBuilder.UseSqlite("Data Source=app.db");

        return new AppDbContext(optionsBuilder.Options);
    }
}
```

Расположение класса-фабрики в проекте не регламентируется, движок EF Core самостоятельно сканирует файлы проекта и находит реализации `IDesignTimeDbContextFactory<T>`

Далее нужно вручную инициализировать поставщика нативной библиотеки SQLite. Обычно, при использовании **DI**, это происходит автоматически. Именно для этого нам нужен пакет `SQLitePCLRaw.bundle_green`. Инициализация поставщика должна выполняться как при запуске приложения, так и при запуске миграций, так как они запускаются независимо (`SQLitePCL.Batteries.Init();`)

Если не инициализировать нативную библиотеку, то возникнет ошибка при выполнении миграции:

```text
You need to call SQLitePCL.raw.SetProvider(). If you are using a bundle package, this is done by calling SQLitePCL.Batteries.Init().
```

Инициализация при запуске приложения (на примере WPF):

```cs
public partial class App : Application {

    //...

    protected override void OnStartup(StartupEventArgs e) {
        SQLitePCL.Batteries.Init();
        base.OnStartup(e);
    }
}
```

Только после этих манипуляций, в ручном варианте без DI, можно запускать миграции

#### 4.3.2 Запуск миграций

```powershell
Add-Migration InitialCreate
```

Ожидаемый вывод:

```text
Build started...
Build succeeded.
To undo this action, use Remove-Migration.
```

```powershell
Update-Database
```

Ожидаемый вывод:

```text
Build started...
Build succeeded.
Acquiring an exclusive lock for migration application. See https://aka.ms/efcore-docs-migrations-lock for more information if this takes too long.
Applying migration '20250904051254_InitialCreate'.
Done.
```

После этих действий должен появиться файл БД `app.db` в папке с проектом. При желании, можно просматривать содержимое этого файла через приложение _SQL Browser for SQL Lite_. Файл будет содержать схему БД, но самих данных еще нет. Так как данные хранятся в файле Excel, то нужно написать метод загрузки данных из Excel

Кроме самого файла БД, был сгенерирован класс `InitialCreate` в каталоге проекта `Migrations`:

```cs
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace PhoneCatalog.Migrations;

/// <inheritdoc />
public partial class InitialCreate : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "Employees",
            columns: table => new
            {
                Id = table.Column<int>(type: "INTEGER", nullable: false)
                    .Annotation("Sqlite:Autoincrement", true),
                PhoneNumber = table.Column<string>(type: "TEXT", nullable: true),
                FullName = table.Column<string>(type: "TEXT", nullable: true),
                Division = table.Column<string>(type: "TEXT", nullable: true),
                Post = table.Column<string>(type: "TEXT", nullable: true),
                Building = table.Column<string>(type: "TEXT", nullable: true),
                Floor = table.Column<string>(type: "TEXT", nullable: true),
                Changed = table.Column<DateTime>(type: "TEXT", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Employees", x => x.Id);
            });

        migrationBuilder.CreateTable(
            name: "Users",
            columns: table => new
            {
                Id = table.Column<int>(type: "INTEGER", nullable: false)
                    .Annotation("Sqlite:Autoincrement", true),
                Name = table.Column<string>(type: "TEXT", maxLength: 50, nullable: false),
                PasswordHash = table.Column<string>(type: "TEXT", nullable: false),
                Role = table.Column<int>(type: "INTEGER", nullable: false),
                Changed = table.Column<DateTime>(type: "TEXT", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Users", x => x.Id);
            });
    }

    /// <inheritdoc />
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(
            name: "Employees");

        migrationBuilder.DropTable(
            name: "Users");
    }
}
```

## 5 Заполнение данных

Так как API доступа к базе -- это `AppDbContext`, то метод загрузки из Excel мы определим в этом классе

```cs
using Microsoft.EntityFrameworkCore;
using PhoneCatalog.Models;

namespace PhoneCatalog.Services;

internal class AppDbContext : DbContext {

    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

    public enum TableNames {
        Employees,
        Users
    }

    public DbSet<Employee> Employees { get; private set; }
    public DbSet<User> Users { get; private set; }

    #region Public API

    // Метод получения данных из Excel и заполнение SQL базы данных
    public void AppendExcelData(TableNames table, bool ignoreRepetitiveEntries = false) {
        switch (table) {
            case TableNames.Employees:
                Employees.AddRange(
                    ExcelApi
                    .SelectEmployeesVer2()
                    .Select(e => new Employee {
                        PhoneNumber = e.PhoneNumber,
                        Division    = e.Division,
                        FullName    = e.FullName,
                        Post        = e.Post,
                        Building    = e.Building,
                        Floor       = e.Stage,
                        Changed     = e.Changed
                    })
                    .Where(e => ignoreRepetitiveEntries
                        ? Employees.Any(emp => emp == e)
                        : true)
                );
                break;
            case TableNames.Users:
                Users.AddRange(
                    ExcelApi
                    .SelectUsers()
                    .Select(u => new User {
                        Name         = u.Name,
                        PasswordHash = u.PasswordHash,
                        Role         = u.Role,
                        Changed      = u.Changed,
                    })
                    .Where(u => ignoreRepetitiveEntries
                        ? Users.Any(user => user == u)
                        : true)
                );
                break;
            default: throw new NotSupportedException();
        }
    }

    #endregion

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {
        if ( ! optionsBuilder.IsConfigured) {
            optionsBuilder.UseSqlite($"Data Source=app.db");
        }
    }
}
```

#MERGE_NOTES
