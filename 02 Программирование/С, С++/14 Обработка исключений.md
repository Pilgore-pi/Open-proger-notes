
> **Исключение** — это событие, которое нарушает нормальный ход выполнения программы и требует специальной обработки

Исключения возникают при возникновении ошибочных или непредвиденных ситуаций во время выполнения программы. Обработка исключений позволяет корректно реагировать на такие ситуации и предотвращать аварийное завершение программы.

## Типы ошибок

Ошибки в программах можно разделить на несколько категорий:

- **Ошибки компиляции** — выявляются компилятором до запуска программы
- **Ошибки времени выполнения** — возникают во время работы программы
  - **Исключительные ситуации** — предсказуемые ошибки, которые можно обработать
  - **Критические ошибки** — непредсказуемые ошибки, приводящие к краху программы

## Обработка исключений в C++

В C++ встроена поддержка исключений через механизм `try-catch-throw`

### Базовая структура

```cpp
try {
    // Код, который может выбросить исключение
    
    // искусственно выбрасываем исключение
    throw std::runtime_error("Произошла ошибка"); 
}
catch (const std::runtime_error& e) {
    // Обработка исключения типа std::runtime_error
    std::cout << "Поймано исключение: " << e.what() << std::endl;
}
catch (const std::exception& e) {
    // Обработка других исключений, наследующих std::exception
    std::cout << "Неизвестное исключение: " << e.what() << std::endl;
}
catch (...) {
    // Обработка любых других исключений
    std::cout << "Поймано неизвестное исключение" << std::endl;
}
```

### Выброс исключений

Исключение можно сгенерировать специально с помощью оператора `throw`:

```cpp
void DivideNumbers(int a, int b) {
    if (b == 0) {
        throw std::invalid_argument("Деление на ноль");
    }
    std::cout << a / b << std::endl;
}

try {
    DivideNumbers(10, 0);
}
catch (const std::invalid_argument& e) {
    std::cout << "Ошибка: " << e.what() << std::endl;
}
```

### Иерархия стандартных исключений

```
std::exception
├── std::logic_error
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   └── std::out_of_range
├── std::runtime_error
│   ├── std::range_error
│   ├── std::overflow_error
│   └── std::underflow_error
└── std::bad_alloc
```

### Создание собственных исключений

Требуются знания ООП

```cpp
class CustomException : public std::exception {
private:
    std::string message;

public:
    CustomException(const std::string& msg) : message(msg) { }
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

try {
    throw CustomException("Пользовательское исключение");
}
catch (const CustomException& e) {
    std::cout << e.what() << std::endl;
}
```

### Множественные обработчики

Блоки `catch` проверяются по порядку. Первый подходящий обработчик выполняется:

```cpp
try {
    // Код, который может выбросить исключение
}
catch (const std::invalid_argument& e) {
    std::cout << "Ошибка аргумента: " << e.what() << std::endl;
}
catch (const std::runtime_error& e) {
    std::cout << "Ошибка времени выполнения: " << e.what() << std::endl;
}
catch (const std::exception& e) {
    std::cout << "Общая ошибка: " << e.what() << std::endl;
}
```

> Порядок блоков `catch` имеет значение. Более специфичные исключения должны обрабатываться перед более общими

```cpp
try {
    throw std::invalid_argument("Ошибка");
}
catch (const std::exception& e) {
    // Этот блок поймает исключение, даже если он идет первым
    std::cout << e.what() << std::endl;
}
catch (const std::invalid_argument& e) {
    // Этот блок никогда не будет выполнен
    std::cout << e.what() << std::endl;
}
```

### Блок finally (RAII вместо finally)

В C++ нет явного блока `finally`, но используется паттерн **RAII (Resource Acquisition Is Initialization)** для гарантированной очистки ресурсов:

```cpp
class FileHandler {
private:
    std::ofstream file;

public:
    FileHandler(const std::string& filename) {
        file.open(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Не удалось открыть файл");
        }
    }
    
    ~FileHandler() {
        if (file.is_open()) {
            file.close(); // Гарантированно вызывается при выходе из области видимости
        }
    }
};

try {
    FileHandler handler("file.txt");
    // Работа с файлом
    throw std::runtime_error("Ошибка при обработке");
} // Деструктор FileHandler вызовется автоматически
catch (const std::exception& e) {
    std::cout << "Ошибка: " << e.what() << std::endl;
}
```

> **Особенность C++**: Деструкторы вызываются автоматически при выходе из области видимости, даже если было выброшено исключение. Это гарантирует освобождение ресурсов

### Спецификация исключений (deprecated в C++11)

В старых версиях C++ можно было указывать, какие исключения может выбросить функция:

```cpp
// C++98 синтаксис (не рекомендуется)
void SafeFunction() throw(std::invalid_argument, std::runtime_error) {
    // Функция может выбросить только эти исключения
}

void NoExceptionFunction() throw() {
    // Функция не выбрасывает исключений
}
```

> **Внимание**: Спецификации исключений были объявлены устаревшими в C++11 и удалены в C++17. Вместо них используется `noexcept`

### Модификатор noexcept (C++11 и позже)

```cpp
void SafeFunction() noexcept {
    // Функция гарантирует, что не выбросит исключение
    // Если исключение все же возникнет, программа завершится
}

аналог оператора `throws` в Java
void MayThrowFunction() noexcept(false) {
    // Функция может выбросить исключение
}

// Условное использование
template<typename T>
void Process(T& value) noexcept(std::is_nothrow_move_constructible_v<T>) {
    // noexcept зависит от типа T
}
```

### Переброс исключений

Исключение можно перехватить, обработать и затем переброситься дальше:

```cpp
try {
    try {
        throw std::runtime_error("Оригинальная ошибка");
    }
    catch (const std::runtime_error& e) {
        std::cout << "Внутренняя обработка: " << e.what() << std::endl;
        throw; // Переброс того же исключения
    }
}
catch (const std::runtime_error& e) {
    std::cout << "Внешняя обработка: " << e.what() << std::endl;
}
```

Можно также выбросить новое исключение вместо оригинального:

```cpp
try {
    try {
        throw std::runtime_error("Оригинальная ошибка");
    }
    catch (const std::runtime_error& e) {
        throw std::logic_error("Преобразованная ошибка");
    }
}
catch (const std::logic_error& e) {
    std::cout << e.what() << std::endl;
}
```

### Цепочка исключений (C++11 и позже)

```cpp
try {
    try {
        throw std::runtime_error("Оригинальная ошибка");
    }
    catch (const std::runtime_error& e) {
        std::throw_with_nested(
            std::logic_error("Новая ошибка с контекстом")
        );
    }
}
catch (const std::exception& e) {
    std::cout << "Ошибка: " << e.what() << std::endl;
    
    // Получение оригинального исключения
    try {
        std::rethrow_if_nested(e);
    }
    catch (const std::exception& nested) {
        std::cout << "Причина: " << nested.what() << std::endl;
    }
}
```

## Обработка ошибок в C

В C нет встроенной поддержки исключений. Вместо этого используются следующие подходы:

### 1. Возврат кодов ошибок

```c
#include <stdio.h>

#define SUCCESS 0
#define ERROR_DIVISION_BY_ZERO 1
#define ERROR_INVALID_INPUT 2

int DivideNumbers(int a, int b, int* result) {
    if (b == 0) {
        return ERROR_DIVISION_BY_ZERO;
    }
    *result = a / b;
    return SUCCESS;
}

int main() {
    int result;
    int error = DivideNumbers(10, 0, &result);
    
    if (error == ERROR_DIVISION_BY_ZERO) {
        printf("Ошибка: деление на ноль\n");
    }
    else if (error == SUCCESS) {
        printf("Результат: %d\n", result);
    }
    
    return 0;
}
```

### 2. Использование переменной errno

```c
#include <errno.h>
#include <string.h>
#include <stdio.h>

void ProcessFile(const char* filename) {
    FILE* file = fopen(filename, "r");
    
    if (file == NULL) {
        printf("Ошибка: %s\n", strerror(errno));
        return;
    }
    
    // Работа с файлом
    fclose(file);
}
```

### 3. Использование setjmp/longjmp (низкоуровневая обработка)

```c
#include <setjmp.h>
#include <stdio.h>

jmp_buf jump_buffer;

void ErrorHandler() {
    printf("Произошла ошибка\n");
    longjmp(jump_buffer, 1); // Переход в точку setjmp
}

int main() {
    if (setjmp(jump_buffer) == 0) {
        // Нормальное выполнение
        printf("Начало программы\n");
        ErrorHandler(); // Не достигнет следующей строки
        printf("Эта строка не выполнится\n");
    }
    else {
        // Выполнение после longjmp
        printf("Восстановление после ошибки\n");
    }
    
    return 0;
}
```

> **Внимание**: `setjmp/longjmp` — это низкоуровневый механизм, который может привести к утечкам ресурсов и сложному коду. Следует использовать этот механизм только если это необходимо

### 4. Обработка сигналов (для критических ошибок)

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void SignalHandler(int signal) {
    if (signal == SIGSEGV) {
        printf("Ошибка: нарушение доступа к памяти\n");
        exit(1);
    }
    else if (signal == SIGABRT) {
        printf("Ошибка: аварийное завершение\n");
        exit(1);
    }
}

int main() {
    signal(SIGSEGV, SignalHandler);
    signal(SIGABRT, SignalHandler);
    
    // Код программы
    
    return 0;
}
```

> **Особенность C**: Обработчики сигналов имеют ограниченный функционал и не должны вызывать большинство функций библиотеки.

## Сравнение подходов C и C++

| Аспект | C | C++ |
|--------|---|-----|
| **Встроенная поддержка** | Нет | Да (try-catch-throw) |
| **Типизация ошибок** | Нет | Да (иерархия исключений) |
| **Автоматическая очистка** | Нет | Да (RAII, деструкторы) |
| **Производительность** | Выше (нет overhead) | Ниже (механизм исключений) |
| **Безопасность** | Ниже (легко забыть проверку) | Выше (гарантированная обработка) |
| **Сложность кода** | Выше (много проверок) | Ниже (явная обработка) |

## Производительность исключений

> **Важно**: Механизм исключений в C++ имеет накладные расходы. Исключения следует использовать для обработки исключительных ситуаций, а не для управления нормальным потоком выполнения

```cpp
// Плохая практика - использование исключений для управления потоком
try {
    for (int i = 0; i < 1000000; i++) {
        if (i == 999999) throw std::runtime_error("Конец");
    }
}
catch (const std::runtime_error& e) {
    std::cout << e.what() << std::endl;
}

// Использование обычного управления потоком
for (int i = 0; i < 1000000; i++) {
    if (i == 999999) {
        std::cout << "Конец" << std::endl;
        break;
    }
}
```

> **Особенность**: В режиме "zero-cost exception handling" (по умолчанию в большинстве компиляторов) исключения не имеют накладных расходов, если они не выбрасываются. Выброс исключения имеет значительные накладные расходы

#C #C-Plus-Plus #GENERATED
