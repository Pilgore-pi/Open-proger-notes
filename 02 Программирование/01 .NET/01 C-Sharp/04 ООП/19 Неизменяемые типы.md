В C# **нет стандартного встроенного интерфейса или базового типа, который описывал бы неизменяемый (immutable) тип по образцу `string`**, просто как контракт или интерфейс. Тип `string` является неизменяемым по дизайну, но его неизменяемость обеспечена им самим, а не через некий общий интерфейс.

Однако есть несколько важных нюансов и связанных моментов:

1. **Immutable как шаблон проектирования и концепция**  
    Неизменяемый объект — такой, у которого нельзя изменить состояние после создания. Это достигается:
    
    - Созданием типа с только readonly полями/свойствами.
    - Отсутствием методов, которые меняют состояние.
    - Чаще всего — использованем `record` или `readonly struct` в C#.
    
2. **Отсутствие интерфейса "IImmutable" для общего неизменяемого типа**  
    В .NET нет интерфейса, вроде `IImmutable` или `IImmutableObject`, который бы гарантировал неизменяемость. Это потому, что неизменяемость — это более семантическое свойство, а не просто набор методов.
    
3. **Immutable коллекции — специальные интерфейсы**  
    В пространстве имён `System.Collections.Immutable` есть набор интерфейсов и классов для неизменяемых коллекций, например:
    
    - `IImmutableList<T>`
        
    - `IImmutableSet<T>`
        
    - `IImmutableDictionary<TKey,TValue>`
        
    
    Эти интерфейсы гарантируют, что коллекция сама по себе неизменяема (модифицирующие методы возвращают новый экземпляр), но это не общее описание неизменяемого типа.
    
4. **Замена механизма через интерфейсы: пример из практики**  
    Можно создать собственный интерфейс без методов изменения, чтобы гарантировать, что состояние не меняется (аналогично Java-примеру из поиска):
    
```csharp
public interface IImmutablePoint
{
    int X { get; }
    int Y { get; }
}

public class Point : IImmutablePoint
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}

```

Здесь `IImmutablePoint` обеспечивает "неизменяемый интерфейс" — никакого метода изменения состояния нет.
   
5. **Типы record и readonly struct в C#**  
    Они наиболее удобны для создания собственных неизменяемых типов. Например, записи (record) имеют встроенную семантику неизменяемости.


## Кратко:

- **Нет стандартного интерфейса, описывающего все неизменяемые типы (как `string`).**
    
- **Есть интерфейсы для неизменяемых коллекций в `System.Collections.Immutable`** (например, `IImmutableList<T>`).
    
- **Все остальные неизменяемые типы обычно создаются с помощью `record`, `readonly struct` или своими собственными классами с только геттерами и без сеттеров.**
    
- Если нужна явная система типов для неизменяемости, её нужно создавать самостоятельно через интерфейсы без методов изменения.
    

Если интересно, могу привести пример кода с созданием собственного интерфейса для неизменяемого типа.

(VPN): https://www.linkedin.com/pulse/c-creating-immutable-class-suryanshu-singh#:~:text=Creating%20Immutable%20Objects%20in%20C,in%20constructors%20or%20while%20declaration.

> Может создать полезный инструмент "`Immutable<T>`", который позволит защитить данные от изменения. По идее присвоение одного массива другому не повлечет никаких изменений в исходном массиве.

#C-Sharp #C-Sharp/Immutable