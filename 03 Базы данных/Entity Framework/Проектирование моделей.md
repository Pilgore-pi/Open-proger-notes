
## Внешние ключи

# Как правильно задать внешний ключ из таблицы Cell, ссылающийся на таблицу CellModifier:

  

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    [ForeignKey(nameof(Modifier))]
    public CellModifier? Modifier { get; set; }
}

public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // status
    
    [Range(0, double.MaxValue)]
    public          double Work  { get; set; }
    
}
```

Правильное задание внешнего ключа в EF Core предполагает наличие в зависимой сущности (в твоём случае — `Cell`) отдельного свойства для хранения значения внешнего ключа, которое ссылается на первичный ключ связанной сущности (`CellModifier`), а также навигационного свойства для удобства работы с объектом.

В твоём примере класс `Cell` содержит навигационное свойство `Modifier` типа `CellModifier`, но нет свойства, которое бы хранило значение внешнего ключа (например, `ModifierTitle`), ссылающееся на ключ `Title` в `CellModifier`.

## Как правильно задать внешний ключ

1. Добавь в класс `Cell` свойство для внешнего ключа, совпадающее по типу с ключом в `CellModifier`:

```cs
public sealed class Cell {
    
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }  // внешний ключ
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
    
}

```

  

2. В классе `CellModifier` ключ `Title` уже определён:

```cs
public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // первичный ключ
    
    [Range(0, double.MaxValue)]
    public double Work { get; set; }
}

```

3. EF Core по соглашению сопоставит `ModifierTitle` как внешний ключ, ссылающийся на `Title` в `CellModifier`.

4. При необходимости можно дополнительно настроить связь в методе `OnModelCreating`:

```cs
modelBuilder.Entity<Cell>()
    .HasOne(c => c.Modifier)
    .WithMany() // или .WithMany(m => m.Cells), если навигация есть и в CellModifier
    .HasForeignKey(c => c.ModifierTitle)
    .HasPrincipalKey(m => m.Title);
```


  ### Почему так
  

- Внешний ключ — это обычно скалярное свойство (например, `string`, `int`), которое хранит значение ключа связанной сущности.

- Навигационное свойство (`Modifier`) — это объект, позволяющий работать с объектом `CellModifier` напрямую.

- Атрибут `[ForeignKey(nameof(ModifierTitle))]` указывает, что `ModifierTitle` — внешний ключ для навигационного свойства `Modifier`.

- Если не добавить отдельное свойство для внешнего ключа, EF Core не сможет корректно сопоставить связь и сгенерирует ошибку или создаст теневой внешний ключ, что усложнит работу.

  
  

## Итог

  

Твой исправленный класс `Cell` должен выглядеть так:

  

```cs

public sealed class Cell {

    [Key]

    public DateOnly Date { get; set; }

  

    public string? ModifierTitle { get; set; }

  

    [ForeignKey(nameof(ModifierTitle))]

    public CellModifier? Modifier { get; set; }

}

```

  

Это классический и правильный способ задания внешнего ключа в EF Core[^1][^2][^5].

  

<div style="text-align: center">⁂</div>

  

[^1]: https://metanit.com/sharp/entityframeworkcore/3.1.php

  

[^2]: https://learn.microsoft.com/ru-ru/ef/core/modeling/relationships/foreign-and-principal-keys

  

[^3]: https://learn.microsoft.com/ru-ru/ef/core/change-tracking/relationship-changes

  

[^4]: https://www.reddit.com/r/dotnet/comments/1da6vvb/foreign_keys_in_ef_core_8/?tl=ru

  

[^5]: https://metanit.com/sharp/efcore/3.1.php

  

[^6]: https://dir.by/developer/entity_framework/foreign_key/?lang=rus%3Ffknohdjecbaiekfk

  

[^7]: https://ru.stackoverflow.com/questions/628915/Не-понимаю-как-расставить-внешние-ключи-entity-framework

  

[^8]: https://andrey.moveax.ru/post/mvc3-in-depth-entity-framework-03-code-first-conventions