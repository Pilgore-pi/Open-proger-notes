
# Конспект по функциям в C/C++

> **Функция** — это именованный участок кода, который может быть выполнен несколько раз в различных участках программы

Функции могут иметь **параметры** и могут возвращать результат своей работы. Функция, которая ничего не возвращает, имеет тип возвращаемого значения `void` и называется **процедурой**. В C/C++ эти термины часто используются для различия между функциями, возвращающими значение, и функциями, возвращающими `void`

Состав функций:

- Сигнатура — совокупность атрибутов, которые идентифицируют функцию:
    - Имя функции
    - Тип возвращаемого значения
    - Состав параметров
        - Количество
        - Тип каждого параметра
        - Модификатор каждого параметра (только C++)
- Тело функции — код, который ассоциирован с именем функции

```c
// Функция без параметров и без возвращаемого значения (процедура)
void ShowMessage() {
    printf("Who are you?\n");
}

// Функция с параметром без возвращаемого значения
void ShowMessage(const char* text) {
    printf("%s\n", text);
}

// Функция с параметрами, возвращающая сумму чисел
int GetSum(int n1, int n2, int n3, int n4) {
    int result = n1 + n2 + n3 + n4;
    return result;
}
```

> Любая функция должна быть объявлена до ее использования. Этого можно добиться двумя способами:

- Полноценное объявление функции с телом
- Объявление прототипа функции до использования функции и объявление тела функции в другом месте

```c
// Прототип функции (объявление)
int GetSum(int n1, int n2, int n3, int n4);

int main() {
    int sum = GetSum(1, 2, 3, 4);
    return 0;
}

// Определение тела функции
int GetSum(int n1, int n2, int n3, int n4) {
    return n1 + n2 + n3 + n4;
}
```

> **Особенность C++**: В C++ 11 и позже можно использовать синтаксис с автоматическим выводом типа возвращаемого значения `auto` (только если определение находится перед использованием)

## Модификаторы параметров

> В данном разделе требуется понимание различий между типами значений и указателями. Если вы не обладаете достаточными знаниями, пропустите этот раздел

Все параметры, которые передаются в функции по умолчанию передаются по значению. То есть значения копируются.

```c
void ChangeValue(int number) {
    number *= 2;
}

int number = 90;
ChangeValue(number);
printf("%d\n", number); // 90 (не изменилось)
```

### Передача по указателю (C и C++)

Для передачи по ссылке на данные используются указатели. Это позволяет изменять исходные значения внутри функции.

```c
void ChangeValue(int* number) {
    *number *= 2;
}

int number = 90;
ChangeValue(&number);
printf("%d\n", number); // 180 (изменилось)
```

При передаче указателя на объект можно изменять его содержимое, но если переназначить сам указатель, исходный указатель не изменится:

```c
typedef struct {
    int value;
} NumberHolder;

void ChangeValueWithRecreation(NumberHolder* holder) {
    // holder теперь указывает на новый объект (локальный)
    NumberHolder newHolder = {55};
    holder = &newHolder;
    holder->value *= 2; // 110
    // После выхода из функции newHolder перестанет существовать
}

NumberHolder holder = {55};
ChangeValueWithRecreation(&holder);
printf("%d\n", holder.value); // 55 (не изменилось)
```

### Передача по ссылке (только C++)

В C++ существует синтаксис ссылок, который более удобен, чем указатели:

```cpp
void ChangeValue(int& number) {
    number *= 2;
}

int number = 90;
ChangeValue(number);
std::cout << number << std::endl; // 180
```

Ссылки автоматически разыменовываются, что делает код более читаемым. Ссылки не могут быть переназначены на другой объект после инициализации

```cpp
void ChangeValueWithRecreation(NumberHolder& holder) {
    // Попытка переназначить ссылку просто изменит содержимое объекта
    NumberHolder newHolder = {55};
    holder = newHolder; // Копирует содержимое newHolder в holder
}
```

### Константные указатели и ссылки (C и C++)

Для передачи данных по ссылке без возможности их изменения используется модификатор `const`:

```c
// C
void PrintValue(const int* number) {
    // *number = 100; // Ошибка компиляции
    printf("%d\n", *number);
}
```

```cpp
// C++
void PrintValue(const int& number) {
    // number = 100; // Ошибка компиляции
    std::cout << number << std::endl;
}
```

> **Особенность C++**: Константные ссылки часто используются для передачи больших объектов без копирования и без возможности их изменения. Это особенно полезно для структур и классов

```cpp
void ProcessLargeStruct(const LargeStruct& data) {
    // Нет копирования, но данные защищены от изменений
}
```

### Указатели на указатели (C и C++)

Для получения полного контроля над указателем (аналог `ref` в C#) используются указатели на указатели:

```c
void ChangePointer(int** ptr) {
    *ptr = malloc(sizeof(int));
    **ptr = 42;
}

int* number = NULL;
ChangePointer(&number);
printf("%d\n", *number); // 42
free(number);
```

## Необязательные параметры (только C++)

В C++ можно объявлять необязательные параметры, которые имеют значение по умолчанию:

```cpp
int Sum(int n1, int n2 = 0) {
    return n1 + n2;
}

int sum1 = Sum(5);      // 5
int sum2 = Sum(5, 3);   // 8
```

Необязательные параметры должны идти последними в списке параметров.

> **Особенность C**: В C нет встроенной поддержки необязательных параметров. Требуется использовать другие техники, такие как передача `NULL` или использование макросов

## Перегрузка функций (только C++)

В C++ разные функции могут иметь одно и то же имя, но разный состав параметров. Такие функции называются **перегрузками**

```cpp
int Merge(int a, int b) {
    return a + b;
}

int Merge(int a, int b, int c) {
    return a + b + c;
}

std::string Merge(std::string a, std::string b) {
    return a + b;
}

int Merge(int& a, int& b) {
    return a + b;
}

int Merge(const int& a, int& b) {
    return a + b;
}
```

Перегрузки должны отличаться одним из следующих показателей:

- Количество параметров
- Типы параметров
- Наличие модификатора `const` для ссылок и указателей

> **Особенность C**: В C нет перегрузки функций

> Перегрузка функций является проявлением **ad-hoc (специального) полиморфизма**

## Рекурсия

> **Рекурсия** — это вызов функции внутри этой же функции

> **Глубиной рекурсии** называется количество вложенных вызовов рекурсивной функции

> Любая рекурсия может быть преобразована в цикл, обратное утверждение тоже верно

```c
// Рекурсивное вычисление факториала
int Factorial(int n) {
    if (n == 1) return 1;
    return n * Factorial(n - 1);
}

int fact = Factorial(6);
```

```c
// Циклическое вычисление факториала
int Factorial(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++)
        result *= i;
    
    return result;
}
```

**Хвостовая рекурсия** — это разновидность рекурсии, при которой вызов функции из этой же функции является последним действием в функции

Хвостовые рекурсии могут быть оптимизированы компилятором, благодаря этому факту. Стек вызовов функций может быть минимальным, так как не нужно хранить контекст вышестоящей функции

> Оптимизация хвостовой рекурсии зависит от флагов компилятора (например, `-O2` или `-O3` в GCC). При оптимизации хвостовая рекурсия преобразуется в цикл, что значительно снижает использование стека

## Возвращаемое значение

В C и C++ функция может возвращать значение по значению или по указателю/ссылке

### Возврат по значению

```c
int GetValue() {
    int value = 42;
    return value; // Копирование значения
}
```

### Возврат по указателю (C и C++)

```c
int* GetPointer() {
    static int value = 42; // Используется статическая переменная
    return &value;
}

int* ptr = GetPointer();
printf("%d\n", *ptr); // 42
```

> **Внимание**: Возврат указателя или ссылки на локальную переменную приводит к неопределённому поведению, так как переменная перестанет существовать после выхода из функции

```c
int* GetPointerBad() {
    int value = 42;
    return &value; // ОШИБКА! Указатель на локальную переменную
}
```

### Возврат по ссылке (только C++)

```cpp
int& GetReference() {
    static int value = 42;
    return value;
}

int& ref = GetReference();
ref = 100; // Изменяет статическую переменную
std::cout << ref << std::endl; // 100
```

```cpp
int& GetReferenceBad() {
    int value = 42;
    return value; // ОШИБКА! Ссылка на локальную переменную
}
```

Использование возврата по ссылке может улучшить производительность, особенно при работе с большими объектами. Вместо создания копий больших структур или классов можно возвращать ссылки на них, что снижает накладные расходы на память и ускоряет выполнение кода

> **Особенность C++17 и позже**: Введена оптимизация **Return Value Optimization (RVO)** и **Named Return Value Optimization (NRVO)**, которые автоматически избегают копирования при возврате временных объектов

```cpp
std::string GetString() {
    std::string result = "Hello";
    return result; // Компилятор оптимизирует и избегает копирования
}
```

> Если функция возвращает значение (не `void`), то в каждом ответвлении кода функция должна возвращать значение или генерировать исключение (в C++ через `throw`). В C используется возврат кода ошибки или глобальная переменная `errno`

```cpp
int Divide(int a, int b) {
    if (b == 0) throw std::invalid_argument("Division by zero");
    return a / b;
}
```

```c
// В C
int Divide(int a, int b, int* result) {
    if (b == 0) {
        return -1; // Код ошибки
    }
    *result = a / b;
    return 0; // Успех
}
```

## Переменное количество аргументов (C и C++)

В C и C++ можно создавать функции с переменным количеством аргументов, используя `...` (многоточие):

```c
#include <stdarg.h>

double CalculateAverage(int count, ...) {
    if (count == 0) return 0;
    
    va_list args;
    va_start(args, count);
    
    double sum = 0;
    for (int i = 0; i < count; i++) {
        sum += va_arg(args, double);
    }
    
    va_end(args);
    return sum / count;
}

double avg1 = CalculateAverage(4, 1.1, 1.5, 2.7, 3.0);
double avg2 = CalculateAverage(1, 1.1);
```

> **Особенность C++**: В современном C++ (C++11 и позже) рекомендуется использовать **variadic templates** вместо `...` для большей типобезопасности:

```cpp
template<typename... Args>
double CalculateAverage(Args... args) {
    std::vector<double> values = {static_cast<double>(args)...};
    if (values.empty()) return 0;
    
    double sum = 0;
    for (double val : values) sum += val;
    
    return sum / values.size();
}

double avg1 = CalculateAverage(1.1, 1.5, 2.7, 3.0);
double avg2 = CalculateAverage(1.1);
```

## Встроенные функции (только C++)

В C++ можно использовать модификатор `inline`, который явно указывает компилятору на то, что код данной функции нужно вставить вместо вызова этой самой функции:

```cpp
inline int Square(int a) {
    return a * a;
}

// Исходный код:
int result = Square(5);

// Встраивание компилятором:
int result = 5 * 5;

```

> **Особенность**: Слово `inline` — это только подсказка компилятору. Компилятор может игнорировать это указание и наоборот встраивать функции без этого модификатора при оптимизации

## Указатели на функцию

#C #C-Plus-Plus #GENERATED
