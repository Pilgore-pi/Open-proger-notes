
```cs
F MakeAdder(double delta)
{
    return x => x + delta;
}//x – double, так как был объявлен делегат delegate double F(double x);
```

```cs
var inc = MakeAdder(1);

var dec = MakeAdder(-1);

inc(5);//6

dec(5);//4
```

Где хранится delta?

Параметры метода храняться в стеке, пока функция не завершена.

//В приведенном случае ошибки не происходит, так как параметр

Когда время жизни функции превосходит время жизни отдельных переменных, используемых внутри этой функции, то такие переменные захватываются функцией в специальный контекст. Этот механизм называется захват переменной или замыкание. Поэтому в любом ЯП с наличием функциональых типов содержится не только ссылки на функции, но и специальный контекст.

```cs
Обобщенный делегат Func<R>       R Func();

Func<T,R>       R Func(T t)

Func<T1, … , Tn, R>    R Func(T1 t1, … Tn tn)

Action                 void Action()

Action<T>              void Action(T t)
```

# События

Синтаксис:

```cs
[<access modifier>] event <Delegate> <Name>;
```

# Интерфейсы

Отвечает на вопрос, какой функционал реализуется классом.

Жесткий диск – это не интерфейс SATA, он реализует его, поэтому SATA должен быть интерфейсом, а не базовым классом.

Интерфейс – это стандарт на взаимодействие 2х и более частей.

Синтаксис:

```cs
[<modifier>] interface <Title>{...}
```

◉ модификатор интерфейса – это только модификатор доступа.

Все элементы интерфейса по умолчанию – public

Элементами интерфейса могут быть:

* Константы
* Свойства
* Методы
* События

```cs
interface IPrintable
{
    void Print();
}
```

jjjj

Интерфейс **совметстим** с любым объектом, реализующим этот интерфейс.

Все допустимые **действия над интерфейсом** определены внутри этого интерфейса.

▽ Интерфейс не может быть реализован частично

Реализация интерфейса


```cs
class Cat : Animal, IPrintable
{
    public void Print(){...}  //неявная реализация
}
```


Если в классе есть публичные элементы, которые сопадают по прототипу с членом интерфейса, то они будут восприняты как реализация члена интерфейса, в противном случае нужно будет создать публичный член класса, реализующий член интерфейса.

```cs
var c = Cat();

IPrintable p = c;

c.Print(); //public Print

p.Print(); //public Print

Явная реализация

class Cat : Animal, IPrintable

{

void IPrintable.Print() => Console.WriteLine(“Meow”); //private

//модификатор private явно писать нельзя

}

var c = Cat();

IPrintable p = c;

c.Print(); //Ошибка компиляции

p.Print(); //private Print

///////////////////////////////////////

class Cat : Animal, IPrintable

{

void IPrintable.Print() => Console.WriteLine(“Meow”); //private

public void Print() => Console.WriteLine(“Ruff”);

}

var c = Cat();

IPrintable p = c;

c.Print(); //public Print

p.Print(); //private Print

class Cat : Animal, IPrintable, IWritable

{

//IPrintable.Print(){...}

//Iwritable.Print(){...}

}

...

//Реализация вывода в консоль или в файл по выбору

interface IPrintable

{

void Print(TextWriter w);

void Print() => Print(Console.Output);

}
```

Класс должен реализовать только элементы, которые не реализованы. При этом остальные члены интерфейса добваляются в класс автоматически.

Если метод в интерфейсе является приватным, то он должен объявлять тело.

# Конструкторы

В C# есть деструкторы. В подавляющем большинстве случаев они не используются.

Все конструкторы неявно вызывают метод Initialize. То есть фактически конструкторы – это инициализаторы, деструкторы – финализаторы.

Если в классе не описан ни одни конструктор, то компилятор C# (не .Net) создает конструктор по умолчанию без параметров.

Если описан хотя бы один конструктор, то компилятор больше не вмешивается.

```cs
class Point {

public Point(double x, double y) => ...
    
    ...
    
}

var p = new Point (5, -3);
```
Если единственный конструктор приватный, то объект создать нельзя.

Статический конструктор

```cs
class Point {

static Point(){...} //без модификаторов
    
}
```

Нужен для инициализации статических членов класса.

Статический конструктор вызывается автоматически средой .Net, при этом неизвестно когда. Но система гарантирует, что инициализация произойдет до обращения к статическим полям/свойствам.

#C-Sharp #Functions/Delegates