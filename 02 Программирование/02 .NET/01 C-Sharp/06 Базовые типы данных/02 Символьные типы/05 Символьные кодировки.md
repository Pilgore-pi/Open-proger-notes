
## Кодировка ASCII

> **ASCII** (American Standard Code for Information Interchange), или Американский стандартный код для обмена информацией, — это исторически первая широко распространенная стандартная кодировка символов, разработанная для унификации обмена данными между компьютерами и телекоммуникационными устройствами

Основные характеристики ASCII

- **7-битная кодировка**: ASCII использует 7 двоичных бит для представления каждого символа. Это позволяет закодировать $2^{7}=128$ уникальных символов.

- **Стандартизация**: До появления ASCII каждый производитель компьютеров использовал свой собственный метод кодирования, что приводило к проблемам совместимости. ASCII ввел единый, универсальный стандарт. Основа для других кодировок: Большинство современных наборов символов, включая широко используемые сегодня ISO-8859-1 и UTF-8, построены на базе или частично совместимы с ASCII

Поскольку 7 бит позволяли закодировать только английский алфавит и базовые символы, для поддержки других языков и дополнительных знаков (например, букв с диакритическими знаками, символов валют) была введена расширенная ASCII, которая использовала все 8 бит

Однако расширенная ASCII не была единым стандартом. Существовало множество различных кодовых страниц (например, Windows-1251 для кириллицы, CP437 для IBM PC), что приводило к проблемам с совместимостью при обмене файлами между разными системами

## Кодовые страницы Windows

Существует 2 группы кодовых страниц Windows:

1) OEM — используется для не-юникодных DOS программ (Win32 Console)
2) ANSI — используется для не-юникодных Windows программ

### ANSI

> **ANSI** (American National Standards Institute) — Американский национальный институт стандартов

Исторически Microsoft использовала термин "ANSI" для обозначения тех кодовых страниц Windows, которые были основаны на ранних черновиках стандартов, схожих с ISO 8859, и предназначались для замены старых кодировок MS-DOS (OEM-кодировок, например CP866)

Ключевые особенности "кодировок ANSI":

- **Размер символа** в памяти 8-бит (1 байт): 1 байт позволяет представить 256 различных символов

- **Совместимость с ASCII**: Первые 128 символов (коды от 0 до 127) всегда соответствуют стандартной 7-битной кодировке ASCII (латинский алфавит, цифры, знаки препинания)

- **Региональная зависимость**: Символы с кодами от 128 до 255 различаются в зависимости от конкретной кодовой страницы (языка или региона). Например, в русской кодировке Windows-1251 под этими номерами находятся буквы кириллицы, а в западноевропейской Windows-1252 — символы умляутов, акцентов и значок евро (€)

- "Системная кодировка по умолчанию": В настройках Windows (до широкого внедрения UTF-8) кодировка "ANSI" означала активную системную кодовую страницу для текущей локали

Сегодня эти кодировки считаются устаревшими и активно вытесняются универсальным стандартом Unicode (особенно UTF-8), который может кодировать все мировые языки в одном файле без потери данных

| Кодовая страница (Code Page ID) | Название в .NET | Регион / Язык |
| ------------------------------- | --------------- | ------------- |
| 1250 | windows-1250 | Центральная Европа (польский, чешский, венгерский) |
| 1251 | windows-1251 | Кириллица (русский, украинский, сербский) |
| 1252 | windows-1252 | Западная Европа, Латиница 1 (США, Англия, Германия, Франция, Испания) |
| 1253 | windows-1253 | Греческий |
| 1254 | windows-1254 | Турецкий |
| 1255 | windows-1255 | Иврит |
| 1256 | windows-1256 | Арабский |
| 1257 | windows-1257 | Прибалтика (литовский, латышский, эстонский) |
| 1258 | windows-1258 | Вьетнамский |
| 932 | windows-932 | Японский (Shift-JIS) |
| 936 | windows-936 | Упрощенный китайский (GBK) |

### OEM

> **OEM-кодировки** (Original Equipment Manufacturer, кодировки производителя оборудования), также известные как кодовые страницы DOS, представляют собой набор однобайтовых кодировок, которые исторически использовались в операционных системах MS-DOS и ранних версиях Windows для консольного (текстового) режима

#### Основные характеристики OEM-кодировок

- OEM-кодировки предшествовали "ANSI"-кодировкам Windows и были основным способом отображения символов в текстовых интерфейсах до широкого распространения графических оболочек и Unicode.

- Размер символа 8-бит: Как и ANSI, они используют 8 бит для кодирования до 256 символов

- **Использование псевдографики**: Ключевое отличие от большинства ANSI-кодировок заключается в том, что OEM-кодировки включали в себя специальные символы для псевдографики — рамок, линий и других элементов, которые использовались для рисования интерфейсов программ в текстовом режиме (например, старые программы вроде Norton Commander, Volkov Commander или интерфейс установки Windows)

**Региональная зависимость**: Символы с кодами от 128 до 255 также менялись в зависимости от региона, но набор символов отличался от аналогичных ANSI-кодировок

Консольный стандарт: Терминалы и старые консольные приложения Windows по умолчанию используют OEM-кодировку, а не системную ANSI-кодировку

#### Кодовые страницы OEM

Ниже приведены некоторые из наиболее известных OEM-кодовых страниц:

| Кодовая страница (Code Page ID) | Название в .NET | Регион / Язык |
| ------------------------------- | --------------- | ------------- |
| 437 | IBM437 | США (стандартная для США) — очень распространена, включает базовую псевдографику |
| 850 | IBM850 | Западная Европа (многоязычная версия 437) |
| 852 | IBM852 | Центральная/Восточная Европа (польский, чешский и др.) |
| 855 | IBM855 | Кириллица (старый стандарт) |
| 866 | IBM866 | Кириллица (основная для России и СНГ в DOS) |
| 862 | IBM862 | Иврит |
| 737 | IBM737 | Греческий |
| 932 | IBM932 | Японский (аналогично ANSI 932) |

## Кодовые страницы Linux

В Linux не было единого понятия "OEM-кодировки", но были свои региональные стандарты:
1. ISO/IEC 8859 (Семейство ISO-8859)
Это семейство стандартов, разработанное Международной организацией по стандартизации (ISO), стало основным для операционных систем Unix и Linux в 1990-х и начале 2000-х годов, прежде чем повсеместно был принят Unicode/UTF-8.
Каждый стандарт в этом семействе представлял собой 8-битную кодировку для определенной языковой группы. Они были функциональным аналогом "ANSI" кодировок Windows, но следовали международным стандартам, а не проприетарным разработкам Microsoft.
Ключевые примеры семейства ISO-8859:
ISO 8859-1 (Latin-1): Стандарт для большинства западноевропейских языков (английский, немецкий, французский, испанский и т.д.). Очень близок к Windows-1252.
ISO 8859-2 (Latin-2): Центральная и Восточная Европа (польский, чешский, венгерский).
ISO 8859-5: Кириллица (русский, белорусский, сербский и др.). Это был основной стандарт для русского языка в Unix-системах до появления UTF-8.
ISO 8859-7: Греческий.
2. KOI8-R (и KOI8-U)
Для русскоязычного сегмента в Unix-подобных системах существовала очень популярная и широко распространенная кодировка КОИ-8 (Код Обмена Информацией, 8-битный), чаще всего в версии KOI8-R.
Это был де-факто стандарт для кириллицы в русскоязычном сегменте Интернета и Unix-систем в России и СНГ на протяжении многих лет.
Особенности KOI8-R:
Преимущество: Она была разработана таким образом, что если отбросить старший бит (превратив ее в 7-битную кодировку для передачи по старым каналам связи), кириллические буквы превращались в соответствующие им по звучанию латинские буквы (транслитерация). Это позволяло читать текст, пусть и на латинице, даже на системах без поддержки кириллицы.
Конкуренция: KOI8-R конкурировала с ISO 8859-5 и Windows-1251.
3. EUC (Extended Unix Code)
Это семейство многобайтовых кодировок использовалось преимущественно для сложных азиатских языков (китайский, японский, корейский), которые не умещались в однобайтовые стандарты.
EUC-JP: Стандарт для японского языка в Unix.
EUC-KR: Стандарт для корейского языка.
Переход к Unicode (UTF-8)
Все эти исторические кодировки были региональными и страдали от той же проблемы несовместимости, что и OEM/ANSI в Windows.
В конце 1990-х и начале 2000-х годов сообщество Linux/Unix стало пионером в массовом переходе на Unicode и, в частности, на кодировку UTF-8

## Схема кодирования Base64

> Base64 — это схема кодирования (encoding scheme), предназначенная для преобразования бинарных данных (например, изображений, исполняемых файлов или любых других последовательностей байтов) в текстовый формат

Многие старые протоколы (например, SMTP для электронной почты, ранние версии HTTP) были разработаны для передачи 7-битного текста ASCII и могли повредить или некорректно интерпретировать байты с определенными значениями (например, управляющие символы или символы с установленным старшим битом).

### Принцип работы

Base64 берет произвольные бинарные данные и переводит их в последовательность печатных символов из строго определенного набора.

**Алфавит Base64**: Используются 64 безопасных символа:

- Заглавные латинские буквы: `A–Z` (26 символов)

- Строчные латинские буквы: `a–z` (26 символов)

- Цифры: `0–9` (10 символов)

- Два специальных символа: `+` (плюс) и `/` (слэш)

- Символ `=` (знак равенства) используется для дополнения (padding)

### Процесс кодирования

Исходные данные разбиваются на блоки по 3 байта (24 бита)

Эти 24 бита затем делятся на четыре группы по 6 бит.
Каждая 6-битная группа может принимать одно из 64 значений, которые и преобразуются в соответствующий символ из алфавита Base64

### Дополнение (Padding)

Так как Base64 кодирует каждые 3 байта исходных данных в 4 символа, выполняется выравнивание:

- Если остается 2 байта, добавляется один символ `=` в конце.
- Если остается 1 байт, добавляются два символа `==` в конце.

### Преимущества и недостатки Base64

**Преимущества**

- **Универсальность**: Позволяет безопасно передавать любые бинарные данные по текстовым каналам связи (email, JSON, XML).

- **Стандартизация**: Является общепринятым, надежным стандартом.

**Недостатки**

- **Увеличение размера данных**: Самый главный недостаток. Поскольку каждые 3 байта превращаются в 4 символа, размер закодированных данных увеличивается примерно на 33%

**Нечитаемость**: Закодированный текст не предназначен для чтения человеком

### Примеры использования

С кодированием Base64 сталкивается практически любой пользователь интернета:

- **Email-вложения**: Все файлы, прикрепляемые к письмам, кодируются в Base64 перед отправкой

- **Data URI в вебе**: Изображения или шрифты, встроенные прямо в HTML или CSS-код, начинаются с `data:image/png;base64,....`

- **API и токены**: Многие ключи доступа, токены аутентификации (например, JWT) и данные, передаваемые в JSON, используют Base64

### Base64 в C#

В C# реализована нативная и эффективная поддержка кодирования и декодирования Base64 через встроенные классы.

```csharp
string originalText = "Привет, мир! Это Base64.";

// 1. Преобразование строки в массив байтов (используя UTF-8)
byte[] bytes = System.Text.Encoding.UTF8.GetBytes(originalText);

// 2. Кодирование байтов в строку Base64
string base64Encoded = Convert.ToBase64String(bytes);
Console.WriteLine($"Закодировано: {base64Encoded}");
// Пример вывода: 0KHQuNC00LXRgNC+LCDQtNCw0YjQutCwINCU0LXRhNC+0LwgQmFzZTY0Lg==

// 3. Декодирование обратно из Base64
byte[] decodedBytes = Convert.FromBase64String(base64Encoded);
string decodedText = System.Text.Encoding.UTF8.GetString(decodedBytes);
Console.WriteLine($"Декодировано: {decodedText}");
```

## Класс Encoding

Абстрактный класс, предоставляющий возможности создавать объекты для кодирования и декодирования данных в заданных кодировках.

```csharp
string text = "Hi there!"

Encoding encodingUTF8 = Encoding.UTF8;

// Кодирование в массив байтов:
byte[] encodedBytes;
encodingUTF8.GetBytes(text);

// Показываем значение закодированных байтов
Console.WriteLine("Encoded bytes: " + BitConverter.ToString(encodedBytes));

String decodedString = encodingUTF8.GetString(encodedBytes);
```

```csharp
// Возвращает исходную строку
encodingUTF8.GetString(encodingUTF8.GetBytes("my LITTLE pony"));
```

Другие классы Encoding:

* `Encoding.ASCII`. Поддерживается только 7-битная версия кодировки
* `Encoding.UTF7`;
* `Encoding.UTF8`;
* `Encoding.Unicode` — little endian UTF-16;
* `Encoding.BigEndianUnicode` — big endian UTF-16;
* `Encoding.UTF32`;
* `Encoding.Default` — кодировка согласно настройкам ОС. Не рекомендуется использовать

Кодировки ANSI, OEM и 8-битная ANSI не поддерживаются базовыми средставами управления кодировками

Все эти классы стоит использовать из абстрактного класса Encoding, таким образом не создаются лишние экземпляры уже созданных классов.

Полезные методы классов кодирования:

* `Encoding.Convert(srcEncoding, destEncoding, bytes)`
* `конкретная_кодировка.GetHashCode()` — номер кодовой страницы

Если данные передаются порциями, нужно следить за их целостностью и не вызывать методы обработки к части данных. Если программа получит порцию 5 байт, то она декодирует только 2 символа и все полетит. Для этого существуют классы семейства (abstract) Decoder. Данные классы декодируют только те байты, которые можно декодировать, остальные сохраняются в памяти до следующего вызова метода.

Для кодирования аналогично используется Encoder

### Использование дополнительных кодировок

Множество кодировок не входит в стандартную сборку .NET, для использования дополнительных кодировок нужно подключить пакет `System.Text.Encoding.CodePages` из менеджера Nuget

Для использования дополнительных кодировок нужно зарегестрировать провайдер кодовых страниц (статический метод) до использования доп. кодировок

```csharp
using System.Text;

// Регистрация провайдера CodePagesEncodingProvider для включения
// поддержки дополнительных кодовых страниц
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

// Создание экземпляра Encoding по номеру кодовой
// страницы Windows-1252 (code page 1252)
Encoding windows1252 = Encoding.GetEncoding(1252);

// Получение доступа к кодировке CP866
Encoding cp866 = Encoding.GetEncoding(866);
```

#C-Sharp #Char_types
