Назад: [[08 Стек и очередь|Стек и очередь]]
Далее: [[01 Методы|Методы]]

> **Кортежи** — это упорядоченные наборы объектов. Кортежи всегда имеют фиксированную длину. Нельзя пересоздать кортеж с другим количеством параметров, так как считается, что это будет уже другой тип. В действительности, кортежи — это обобщенные классы и структуры.

> Количество элементов кортежа неограничено, однако в старых версиях .NET максимальное число элементов кортежа было `8`

## Именование элементов

По умолчанию элементы кортежа именуются согласно шаблону: `Item<N>`, где `N` начинается с `1`

Имена можно задавать при объявлении:

```cs
(string str, int num) pair = ("One", 13);
pair.num = 30;
pair.str += "-Two";

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
(long, int, float) nums = (big: 40465501, ordinary: 93, single: 51.1f);
nums.num = 30;
```

Вывод из имен соответствующих переменных:

```cs
double sum = 4.5;
int count  = 3;

var tuple = (sum, count);
tuple.sum += 10;
```

Можно комбинировать любые способы именования полей кортежа

Имена по умолчанию (`ItemN`) всегда доступны для использования, независимо от того, были ли заданы кастомные имена

```cs
var a = 1;
var t = (a, b: 2, 3);
t.Item1 = 3;
t.b = 4;
t.Item3 = 5;
```

> Имена полей не учитываются при присваивании кортежа и сравнении кортежей на равенство

## Сравнение кортежей

Сравнение кортежей происходит поэлементно с использованием операторов `==` и `!=`. При этом:

- **Сравниваются элементы на соответствующих позициях в кортеже**, а не их имена полей. Например, два кортежа считаются равными, если все элементы с одинаковыми индексами равны, несмотря на различия в именах элементов.
- Оба кортежа должны содержать **одинаковое количество элементов**, иначе сравнение не компилируется.
- Операция прерывается при обнаружении первой неравной пары элементов, но все элементы кортежей вычисляются перед сравнением

Пример:

```csharp
(int a, byte b) left = (5, 10);
(long a, int b) right = (5, 10);

Console.WriteLine(left == right); // Вывод: True
Console.WriteLine(left != right); // Вывод: False

var t1 = (A: 5, B: 10);
var t2 = (B: 5, A: 10);

Console.WriteLine(t1 == t2); // Вывод: True (имена игнорируются)
Console.WriteLine(t1 != t2); // Вывод: False
```

Также пример с побочным эффектом вычисления элементов:

```csharp
Console.WriteLine((Display(1), Display(2)) == (Display(3), Display(4)));

int Display(int s)
{
    Console.WriteLine(s);
    return s;
}

// Вывод:
// 1
// 2
// 3
// 4
// False
```

Это означает, что все элементы вычисляются, затем начинается поэлементное сравнение[^1][^2].

[^1]: https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/value-tuples
[^2]: https://habr.com/ru/articles/573088/
[^3]: https://www.cyberforum.ru/csharp-beginners/thread2423956.html
[^4]: https://ru.stackoverflow.com/questions/1172775/Кортежи-в-c-Их-плюсы-и-минусы
[^5]: https://habr.com/ru/articles/345376/
[^6]: https://learn.microsoft.com/ru-ru/dotnet/csharp/tour-of-csharp/tutorials/tuples-and-types
[^7]: https://metanit.com/sharp/tutorial/3.56.php
[^8]: https://www.reddit.com/r/ProgrammingLanguages/comments/18245pc/question_comparing_tuple_array/?tl=ru
[^9]: https://nuancesprog.ru/p/16549/

## Декомпозиция кортежа

Это операция, которая позволяет извлекать из кортежа все элементы за одну операцию. Существует несколько видов деконструкции (декомпозиции) кортежей:

1) С явным указанием типов:

```csharp
(double R, double Phi) = ToPolar(10, 20);
R *= 2;
Phi /= 4;
```

2) С использованием ключевого слова var:

```csharp
var (R, Phi) = ToPolar(10, 20);
```

3) Инициализация объявленных переменных:

```csharp
string city = "Raleigh";
int population = 458880;
double area = 144.8;

(city, population, area) = QueryCityData("New York City");
```

4) Смешанный способ (C# 10):

```csharp
string city = "Raleigh";
int population = 458880;

(city, population, double area) = QueryCityData("New York City");
```

### Декомпозиция с отбрасыванием

```csharp
var (_, _, pop1, _, pop2) = GetData("New York City", 1960, 2010);
```

## Перегрузка декомпозиции

Для пользовательских типов можно переопределить метод декомпозиции, который должен возвращать `void` и все его параметры должны быть с модификатором `out`, а имя метода должно быть "`Deconstruct`".

```csharp
class Person
{
	//...
	public void Deconstruct(
      out string fname, out string mname, out string lname)
	{
		fname = FirstName;
		mname = MiddleName;
		lname = LastName;
	}
}
```

Далее: [[01 Методы|Методы]]

#C-Sharp #C-Sharp/Collections