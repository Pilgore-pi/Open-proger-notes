
## Аннотации целостности

Все атрибуты целостности определены в пространства имен [System.ComponentModel.DataAnnotations](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=net-9.0) и [System.ComponentModel.DataAnnotations.Schema](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.schema)

Поведение системы ORM EF Core по умолчанию:

- Все публичные свойства с геттером и сеттером включаются в модель данных EF Core
- Имена колонок SQL совпадают со свойствами сопоставляемых классов
- Все текстовые атрибуты закодированы в Unicode
- При включенном контексте`#nullable enable`, свойства, допускающие значение `null` считаются **необязательными** (`string?`, `int?`). Свойства, не допускающие `null` считаются обязательными (`string`, `int`). Если контекст отключен, то все ссылочные типы, которые могут хранить значение `null` считаются необязательными

[__1__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes)
[__2__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/navigations?source=recommendations)
[One-to-one relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-one?source=recommendations)
[One-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-many?source=recommendations)
[Many-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/many-to-many?source=recommendations)

Далее будет использоваться термин "поле данных", которое обозначает поле таблицы SQL базы данных

| Аннотация | Область применения | Описание |
|--------------------|-------------------|----------|
| `[NotMapped]` | Класс, cвойство, поле | Исключает объект из сопоставления в базе данных |
| `[Table(name)]` | Класс | Задает имя соответствующей SQL таблицы |
| `[Column(propName)]` | Свойство, поле, параметр | Явно задает сопоставляемое имя поля данных SQL |
| `[Column(Order = index)]` | Свойство, поле | Задает порядок поля данных в таблице SQL |
| `[Key]` | Свойство, поле, параметр | Объявляет поле данных как первичный ключ |
| `[PrimaryKey(propertyList)]` | Свойство, поле | Объявляет первичный ключ для объекта. В атрибут передаются все имена полей данных, формирующих составной или простой первичный ключ |
| `[ForeignKey(propName)]` | Свойство, поле, параметр |  |
| `[Keyless]` | Класс | Говорит о том, что объект не содержит ключей |
| `[Range(min, max)]` | Свойство, поле, параметр | Определяет диапазон допустимых значений |
| `[Precision(precision, scale)]` | Свойство, поле | Определяет разрядность числового свойства |
| `[MinLength(value)]` | Свойство, поле, параметр | Указывает минимальную допустимую границу значений. Большинство БД поддерживают это ограничение для типов SQL `decimal`, `DateTime` |
| `[MaxLength(value)]` | Свойство, поле, параметр | Указывает максимальную допустимую границу значений |
| `[DeniedValues(object[])]` | Свойство, поле, параметр | Определяет список недопустимых значений для свойства |
| `[Required]` | Свойство, поле, параметр | Аналог SQL `NOT NULL`. Не имеет эффекта, если применять к Non-nullable типам в nullable-контексте |
| `[Index(propName)]` (устаревший) | Класс | Объявляет индекс БД. Индекс может быть простым (1 поле даных) или составным (несколько полей данных) |
| `[DatabaseGenerated(enum)]` | Свойство, поле | Указывает на то, что значение поля данных должно генерироваться автоматически. В атрибут передается перечисление `enum DatabaseGeneratedOption {`</br>`    None = 0, // База данных не создает значений`</br>`    Identity = 1, // База данных создает значение при вставке строки`</br>`    Computed = 2 // База данных создает значение при вставке или обновлении строки`</br>`}` |
| `[Unicode(flag)]` | Свойство, поле (`string`) | Определяет, будет ли применяться кодировка Unicode к текстовому полю данных |
| `[Base64String]` | Свойство, поле, параметр (`string`) | Помечает поле данных как строку в кодировке Base64 |
| `[Comment(commentString)]` | Класс, свойство, поле | Задает комментарий для таблицы или колонки SQL на уровне схемы |
| `[RegularExpression(pattern)]` | Свойство, поле, параметр | Задает валидацию на основе регулярного выражения. Валидация пропускается, если атрибут `Required` не применяется и строка равна `string.Empty` или `null` |
| `[EmailAddress]` | Свойство, поле, параметр | Помечает поле данных для простой проверки на соответствие формату e-mail адреса (проверяется, является ли символ `@` единственным и непоследним в строке) |
| `[Url]` | Свойство, поле, параметр (`string`) | Проверяет, начинается ли значение на `http://`, `https://`, `ftp://` |
| `[ComplexType]` | Класс | Помечает класс как "сложный тип". Сложные типы - это нескалярные свойства типов сущностей, которые позволяют организовать скалярные свойства внутри сущностей. Сложные типы не имеют ключей и не могут управляться Entity Framework отдельно от родительского объекта |
| `[InverseProperty]` | Свойство, поле |  |
| `[DeleteBehavior]` | Свойство | Определяет механизм каскадного удаления, применяемого к навигационному свойству |

### InverseProperty

used to connect a navigation with its inverse. For example, in the following entity types, there are two relationships between Blog and Post. Without any configuration, EF conventions cannot determine which navigations between the two types should be paired. Adding `[InverseProperty]` to one of the paired navigations resolves this ambiguity and allows EF to build the model

```cs
public class Blog {
    public int Id { get; set; }

    [InverseProperty("Blog")]
    public List<Post> Posts { get; } = new();

    public int FeaturedPostId { get; set; }
    public Post FeaturedPost { get; set; }
}

public class Post {
    public int Id { get; set; }
    public int BlogId { get; set; }

    public Blog Blog { get; init; }
}
```

 Important

`[InverseProperty]` is only needed when there is more than one relationship between the same types. With a single relationship, the two navigations are paired automatically.

### Подробно об аннотации Column

```cs
public class Blog
{
    public int BlogId { get; set; }

    [Column(TypeName = "varchar(200)")]
    public string Url { get; set; }

    [Column(TypeName = "decimal(5, 2)")]
    public decimal Rating { get; set; }
}
```

## Ключи и связи таблиц

### Первичные ключи

> Согласно специальной конвенции EF Core, свойства объектов, которые имеют имя `Id` или `<propertyName>Id` воспринимаются системой ORM как первичные ключи

> По умолчанию, значения первичных ключей генерируются автоматически, но можно явно настроить способ генерации ключей через атрибут `[DatabaseGenerated()]`

```cs
internal class Car
{
    public string Id { get; set; }
    public string Make { get; set; }
    public string Model { get; set; }
}

internal class Truck
{
    public string TruckId { get; set; }
    public string Make { get; set; }
    public string Model { get; set; }
}
```

```cs
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

### Внешние ключи

#### Как правильно задать внешний ключ из таблицы Cell, ссылающийся на таблицу CellModifier:
  

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    [ForeignKey(nameof(Modifier))]
    public CellModifier? Modifier { get; set; }
}

public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // status
    
    [Range(0, double.MaxValue)]
    public          double Work  { get; set; }
}
```

Правильное задание внешнего ключа в EF Core предполагает наличие в зависимой сущности (в твоём случае — `Cell`) отдельного свойства для хранения значения внешнего ключа, которое ссылается на первичный ключ связанной сущности (`CellModifier`), а также навигационного свойства для удобства работы с объектом.

В твоём примере класс `Cell` содержит навигационное свойство `Modifier` типа `CellModifier`, но нет свойства, которое бы хранило значение внешнего ключа (например, `ModifierTitle`), ссылающееся на ключ `Title` в `CellModifier`.

#### Как правильно задать внешний ключ

1. Добавь в класс `Cell` свойство для внешнего ключа, совпадающее по типу с ключом в `CellModifier`:

```cs
public sealed class Cell {
    
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }  // внешний ключ
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

2. В классе `CellModifier` ключ `Title` уже определён:

```cs
public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // первичный ключ
    
    [Range(0, double.MaxValue)]
    public double Work { get; set; }
}
```

3. EF Core по соглашению сопоставит `ModifierTitle` как внешний ключ, ссылающийся на `Title` в `CellModifier`.

4. При необходимости можно дополнительно настроить связь в методе `OnModelCreating`:

```cs
modelBuilder.Entity<Cell>()
    .HasOne(c => c.Modifier)
    .WithMany() // или .WithMany(m => m.Cells), если навигация есть и в CellModifier
    .HasForeignKey(c => c.ModifierTitle)
    .HasPrincipalKey(m => m.Title);
```

##### Почему так

- Внешний ключ — это обычно скалярное свойство (например, `string`, `int`), которое хранит значение ключа связанной сущности.

- Навигационное свойство (`Modifier`) — это объект, позволяющий работать с объектом `CellModifier` напрямую.

- Атрибут `[ForeignKey(nameof(ModifierTitle))]` указывает, что `ModifierTitle` — внешний ключ для навигационного свойства `Modifier`.

- Если не добавить отдельное свойство для внешнего ключа, EF Core не сможет корректно сопоставить связь и сгенерирует ошибку или создаст теневой внешний ключ, что усложнит работу.

##### Итог

Твой исправленный класс `Cell` должен выглядеть так:

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

Это классический и правильный способ задания внешнего ключа в EF Core[^1][^2][^5].


#MERGE_NOTES

#DB #Dotnet #Dotnet/EntityFramework

[^1]: https://metanit.com/sharp/entityframeworkcore/3.1.php
[^2]: https://learn.microsoft.com/ru-ru/ef/core/modeling/relationships/foreign-and-principal-keys
[^3]: https://learn.microsoft.com/ru-ru/ef/core/change-tracking/relationship-changes
[^4]: https://www.reddit.com/r/dotnet/comments/1da6vvb/foreign_keys_in_ef_core_8/?tl=ru
[^5]: https://metanit.com/sharp/efcore/3.1.php
[^6]: https://dir.by/developer/entity_framework/foreign_key/?lang=rus%3Ffknohdjecbaiekfk
[^7]: https://ru.stackoverflow.com/questions/628915/Не-понимаю-как-расставить-внешние-ключи-entity-framework
[^8]: https://andrey.moveax.ru/post/mvc3-in-depth-entity-framework-03-code-first-conventions
