
[Официальная документация](https://learn.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=msvc-170)

Preprocessor directives, such as #define and #ifdef, are used to make source programs easy to change and compile in different execution environments. Directives in the source file tell the preprocessor to take specific actions. For example, the preprocessor can replace tokens in the text, insert the contents of other files into the source file, or suppress compilation of part of the file by removing sections of text

Директивы препроцессора в C и C++ — это специальные команды, начинающиеся с символа решетки (`#`), которые выполняются препроцессором до этапа компиляции. Они служат для предварительной обработки исходного кода, такой как включение файлов, определение макросов, условная компиляция и другие функции управления текстом программы. Ниже приведен подробный конспект основных директив и их применения

> Директивы препроцессора применяются до любых макроподстановок

Препроцессор может распознавать следующие директивы:

- `#if` — оператор `if` на уровне препроцессора
- `#else` — оператор `else` на уровне препроцессора
- `#elif` — оператор `elif` на уровне препроцессора
- `#endif` — оператор `endif` на уровне препроцессора
- `#define` — определяет символ препроцессора или макроподстановку
- `#undef` — отменяет определение символа или макроса
- `#ifdef` — 
- `#ifndef` — 
- `#import` — 
- `#include` — 
- `#using` — (только C++). Импортирует метаданные в программу, скомпилированную в режиме [CLR](https://learn.microsoft.com/en-us/cpp/build/reference/clr-common-language-runtime-compilation?view=msvc-170)
- `#line` — 
- `#pragma` — 
- `#warning` — (только C++)
- `#error` — генерирует ошибку с сообщением, которая останавливает компиляцию программы

Символ `#` должен быть первым печатаемым символом в строке. Между `#` и директивой можно вставлять непечатаемые символы. Под непечатаемым символом подразумеваются такие символы как пробел, табуляция и др.

Некоторые директивы могут включать аргументы или значения

## Определение символов и макросов

### `#define`

Определяет макро или символическую константу. Синтаксис:

```c
#define IDENTIFIER
#define IDENTIFIER TOKEN_STRING
```

- `IDENTIFIER` — символ препроцессора с произвольным названием
- `TOKEN_STRING` (является необязательным) - выражение на языке C/C++, которое будет подставляться вместо символа `IDENTIFIER`

Если просто использовать `#define IDENTIFIER`, то будет объявлен символ препроцессора `IDENTIFIER`, который будет иметь статус "определен" (defined), то есть директива `#ifdef IDENTIFIER` будет возвращать `true`

После определения все вхождения идентификатора в коде будут заменены на указанное значение. Используется для создания макросов и постоянных значений

```c
// Определение макро константы
#define WIDTH       80

// Определение константы через константное выражение
#define LENGTH      ( WIDTH + 10 )

// Macro to define cursor lines
#define CURSOR(top, bottom) (((top) << 8) | (bottom))

// Макроподстановка для получения случайного целого в заданном диапазоне
#define getrandom(min, max) \
    ((rand()%(int)(((max) + 1)-(min)))+ (min))
```

В некоторых версиях компилятора эти 2 макроподстановки могут восприниматься как одинаковые и генерировать ошибку:

```c
#define multiply(f1, f2) (f1 * f2)
#define multiply(a1, a2) (a1 * a2)
```

Компилятор Microsoft C/C++ не генерирует ошибку в этом случае

### `#undef`

Отменяет ранее сделанное определение символа или макроподстановки

Директиву можно применять к символам, которые никогда не были определены. Это не вызовет ошибки и предназначено для гарантированной отмены определения символа, независимо от того, был ли он ранее определен

```c
#define WIDTH 80
#define ADD( X, Y ) ((X) + (Y))


#undef WIDTH
#undef ADD
```

## Условная компиляция

Позволяет включать или исключать части кода на этапе препроцессинга, управляя компиляцией в зависимости от условий.

- `#ifdef IDENTIFIER` — если идентификатор определен, то следующий код компилируется
- `#ifndef IDENTIFIER` — если идентификатор не определен, то следующий код компилируется
- `#if CONSTANT_EXPRESSION` — компилирует код, если выражение истинно (не 0)
- `#else` — альтернатива, если условие не выполняется
- `#elif` — объединение `else` и `if` для проверки другого условия
- `#endif` — завершает блок условной компиляции

`#if CONSTANT_EXPRESSION` — условное выражение `CONSTANT_EXPRESSION` в директиве `#if` имеет ограничения:

- **Выражение должно быть константным**, то есть вычисляться сразу на основе других константных выражений или простых констант
- Может содержать только целые числа, текстовые символы, операторы `defined` и `_has_include`
- Не может использовать оператор `sizeof` и любые преобразования типов
- Выражение не должно никаким образом обращаться к данным среды выполнения или платформы, то есть выражение должно быть изолировано от платформы и ОС

```cpp
#if DLEVEL > 5
    #define SIGNAL  1
    #if STACKUSE == 1
        #define STACK   200
    #else
        #define STACK   100
    #endif
#else
    #define SIGNAL  0
    #if STACKUSE == 1
        #define STACK   100
    #else
        #define STACK   50
    #endif
#endif
```

Условное определение символа:

```cpp
#ifndef test
#define final
#endif
```

### Оператор defined

Оператор `defined` имеет следующий синтаксис:

```cpp
defined(IDENTIFIER)
defined IDENTIFIER
```

Оператор `defined`, фактически, представляет собой константное выражение и является истинным (не равно 0), если указанный символ определен

Если аргументом оператора `defined` будет пустая строка, то он вернет истину

Оператор может использоваться только в рамках директив `#if` и `#elif`

```cpp
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```

### Оператор `__has_include`

Используется только в VisualStudio 2017 и более поздних версиях только для C++. Оператор определяет, доступен ли заголовочный файл для подключения

```cpp
#ifdef __has_include
#  if __has_include(<filesystem>)
#    include <filesystem>
#    define have_filesystem 1
#  elif __has_include(<experimental/filesystem>)
#    include <experimental/filesystem>
#    define have_filesystem 1
#    define experimental_filesystem
#  else
#    define have_filesystem 0
#  endif
#endif
```

## Подключение файлов и библиотек

### `#include`

Вставляет содержимое указанного файла в место вызова директивы. Есть две формы:

- `#include <filename>` — подключение системных/стандартных заголовочных файлов
- `#include "filename"` — подключение файлов из текущей директории проекта или указанных путей

`#include` с кавычками выполняет поиск заголовочных файлов в следующем порядке:

1) Поиск в том же каталоге, что и текущий файл, с директивой `#include`

2) В каталогах, где находятся открытые заголовочные файлы в обратном порядке их открытия. Поиск начинается в каталоге родительского заголовочного файла и продолжается вверх по файловой иерархии

3) Поиск по путям, указанных в аргументах с флагом компилятора `\I`

4) Поиск по путям, указанных в переменной среды INCLUDE

`#include` с угловыми скобками выполняет поиск заголовочных файлов в следующем порядке:

1) Поиск по путям, указанных в аргументах с флагом компилятора `\I`

2) Когда компиляция выполняется через командную строку, поиск выполняется по путям, указанным в переменной среды INCLUDE

[Подробнее здесь](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170)

### `#import`

[Официальная документация](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp?view=msvc-170)

**Только C++**. Предназначена для подключения библиотек типов. Содержимое этих библиотек является сконвертированными C++ классами, в основном, описывающие COM интерфейсы

Синтаксис:

```cpp
#import "filename" [attributes]
#import <filename> [attributes]
```

### [`#using`](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-using-directive-cpp?view=msvc-170)

Синтаксис:

```cpp
#using <FILE> [as_friend]
```

```cpp
#using <MyComponent.dll>
```

```cpp
// using_assembly_B.cpp
// compile with: /clr /LD
#using "using_assembly_A.dll"

public ref class B {
public:
   void Test(A a) {}
   void Test() {}
};
```

## Отладочная информация и генерация ошибок

### `#error`

Выводит сообщение об ошибке и прекращает компиляцию

```c
#if !defined(__cplusplus)
#error C++ compiler required.
#endif
```

### `#warning`

Выводит сообщение текст предупреждения. Не останавливает компиляцию. _Доступно, начиная с версии C++23 и только в C++_

```cpp
#if defined(_LEGACY_FEATURE_FLAG)
#warning "_LEGACY_FEATURE is deprecated and should not be used."
#endif
```

### `#line`

Позволяет переопределить номер строки и имя файла для компилятора и отладчиков, используется для генераторов кода

Синтаксис:

```cpp
#line digit-sequence ["filename"]
```

```c
// line_directive.cpp
// Compile by using: cl /W4 /EHsc line_directive.cpp
#include <stdio.h>

int main() {
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 10
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 20 "hello.cpp"
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
}
```

## Директивы, специфичные для платформы

### `#pragma`

Синтаксис:

```cpp
#pragma TOKEN_STRING
__pragma(TOKEN_STRING)   // расширение от Microsoft
_Pragma(string_literal)  // C99
```

Каждая реализация C и C++ поддерживает специфичные функции, доступные только на определенных платформах или устройствах. Директива `#pragma` является нативной, то есть специфичной для платормы или устройства, но, в целом, поддерживает совместимость с общими стандартами C и C++

`#pragma` директива является категорией нативных директив, полный список которых можно получить из [официальной документации от Microsoft](https://learn.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=msvc-170)

## Предопределенные макросы

https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170

## Операторы препроцессора

https://learn.microsoft.com/en-us/cpp/preprocessor/preprocessor-operators?view=msvc-170

#C #C-Plus-Plus #GENERATED
