
> **Финализатор** — это особый метод класса, который вызывается **автоматически средой выполнения (CLR) перед удалением объекта сборщиком мусора**. Финализатор позволяет выполнить заключительную очистку объекта, например, освободить неуправляемые ресурсы

- В C\# финализатор записывается в виде **деструктора** классa — метода с синтаксисом `~ИмяКласса()`. Например:

```csharp
class Person {
    public string Name { get; }
    public Person(string name) => Name = name;
    
    ~Person() {
        Console.WriteLine($"{Name} deleted");
    }
}
```

- Хотя это называют деструктором, на самом деле C\# компилирует его в метод `Finalize()` — вызов этого метода происходит перед фактическим сбором объекта сборщиком мусора
- В отличие от C++ деструкторов, **время вызова финализатора неопределено** и зависит от работы сборщика мусора; объект может прожить в памяти неопределённое время после того, как на него перестали ссылаться
- Метод `Finalize` нельзя вызвать явно из кода, он вызывается автоматически средой выполнения
- Обычно финализатор используется для освобождения **неуправляемых ресурсов** (например, файловых дескрипторов, сетевых сокетов), которые не покрываются сборщиком мусора
- Если класс реализует финализатор, сборка такого объекта происходит медленнее, так как объект попадает в очередь финализации

## Очередь финализации

**Очередь финализации** (finalization queue) — это специальная внутренняя структура данных, поддерживаемая средой выполнения .NET (CLR), в которую помещаются ссылки на объекты, имеющие финализаторы (деструкторы) [^1]

Когда сборщик мусора обнаруживает, что объект стал недостижимым и готов к удалению из памяти, он проверяет, есть ли у этого объекта финализатор [^5]. Если финализатор присутствует, сборщик мусора не удаляет объект сразу, а вместо этого добавляет его в очередь финализации [^3][^8]

## Пример вызова финализаторов и порядок:

В иерархии наследования финализаторы вызываются в порядке от самого производного класса к базовому:

```csharp
class Base {
    ~Base() { Console.WriteLine("Base finalizer"); }
}

class Derived : Base {
    ~Derived() { Console.WriteLine("Derived finalizer"); }
}
```

При удалении `Derived` сначала вызовется финализатор `Derived`, затем `Base`.

## Связь с паттерном IDisposable и освобождением ресурсов

- В C\# для правильного освобождения ресурсов используется интерфейс `IDisposable` с методом `Dispose()`, вызов которого контролирует разработчик (обычно через `using`)
- Это позволяет **освобождать ресурсы "здесь и сейчас"**, а не в неопределённом времени финализатором.
- Финализаторы обеспечивают "страховку", на случай если `Dispose` не был вызван, но их стоит избегать, так как они снижают производительность и усложняют работу сборщика мусора.


#C-Sharp #Performance