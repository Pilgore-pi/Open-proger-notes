
## Сопоставление свойств. Атрибуты DataAnnotations

```cs
using System.......
```

По умолчанию, все публичные свойства с геттером и сеттером включаются в Модель данных EF Core
По умолчанию, имена колонок SQL совпадают со свойствами сопоставляемых классов
По умолчанию, все текстовые атрибуты закодированы в Unicode
По умолчанию (`#nullable enable`), свойства, допускающие значение `null` считаются необязательными (`string?`, `int?`). Свойства, не допускающие `null` считаются обязательными (`string`, `int`). Если `#nullable disable`, то все ссылочные типы, которые могут хранить значение `null` считаются необязательными

[__1__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes)
[__2__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/navigations?source=recommendations)
[One-to-one relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-one?source=recommendations)
[One-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-many?source=recommendations)
[Many-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/many-to-many?source=recommendations)

| Аннотация | Область применения| Описание |
|--------------------|-------------------|----------|
| `[NotMapped]` | Объект, свойство | Исключает свойство из модели данных EF Core |
| `[Table(name)]` | Свойство | Задает имя соответствующей SQL таблицы |
| `[Column(propName)]` | Свойство | Явно задает сопоставляемое имя атрибута SQL |
| `[Column(Order = index)]` | Свойство | Задает порядок атрибута в таблице SQL |
| `[Key]` | Свойство | Объявляет текущее свойство как первичный ключ |
| `[PrimaryKey(propertyList)]` | Объект | Объявляет первичный ключ для объекта. В атрибут передаются все имена свойств, формирующих составной или простой первичный ключ |
| `[ForeignKey(propName)]` |  |  |
| `[Keyless]` | Объект | Говорит о том, что объект не содержит ключей |
| `[Range(min, max)]` |  | Определяет диапазон допустимых значений |
| `[Precision(precision, scale)]` | Свойство | Определяет разрядность числового свойства |
| `[MinLength(value)]` |  | Указывает минимальную допустимую границу значений. Большинство БД поддерживают это ограничение для типов SQL `decimal`, `DateTime` |
| `[MaxLength(value)]` |  | Указывает максимальную допустимую границу значений |
| `[Required]` |  | Аналог SQL `NOT NULL`. Не имеет эффекта, если применять к Non-nullable типам |
| `[Index(propName)]` | Объект | Объявляет индекс БД. Индекс может быть простым (1 свойство) или составным (более 1 свойства)  |
| `[DatabaseGenerated(enum)]` | Свойство | Указывает на то, что значение текущего свойства должно генерироваться автоматически. В атрибут передается перечисление `enum DatabaseGeneratedOption {`</br>`    None = 0, // База данных не создает значений`</br>`    Identity = 1, // База данных создает значение при вставке строки`</br>`    Computed = 2 // База данных создает значение при вставке или обновлении строки`</br>`}` |
| `[Unicode(flag)]` | Свойство (текстовое) | Определяет, будет ли применяться кодировка Unicode к текстовому свойству |
| `[Comment(commentString)]` | Объект, свойство | Задает комментарий для колонки таблицы SQL на уровне схемы |
| `[RegularExpression(pattern)]` | Свойство, поле, параметр | Задает валидацию на основе регулярного выражения. Валидация пропускается, если атрибут `Required` не применяется и строка равна `string.Empty` или `null` |

## Ограничения целостности

```cs
public class Blog
{
    public int BlogId { get; set; }

    [Column(TypeName = "varchar(200)")]
    public string Url { get; set; }

    [Column(TypeName = "decimal(5, 2)")]
    public decimal Rating { get; set; }
}
```

## Первичные ключи

> Согласно специальной конвенции, свойства объектов, которые имеют имя `Id` или `<propertyName>Id` воспринимаются системой ORM как первичные ключи

> По умолчанию, значения первичных ключей генерируются автоматически, но можно явно настроить способ генерации ключей через атрибут `[DatabaseGenerated()]`

```cs
internal class Car
{
    public string Id { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

internal class Truck
{
    public string TruckId { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

```cs
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

## Внешние ключи

### Как правильно задать внешний ключ из таблицы Cell, ссылающийся на таблицу CellModifier:
  

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    [ForeignKey(nameof(Modifier))]
    public CellModifier? Modifier { get; set; }
}

public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // status
    
    [Range(0, double.MaxValue)]
    public          double Work  { get; set; }
}
```

Правильное задание внешнего ключа в EF Core предполагает наличие в зависимой сущности (в твоём случае — `Cell`) отдельного свойства для хранения значения внешнего ключа, которое ссылается на первичный ключ связанной сущности (`CellModifier`), а также навигационного свойства для удобства работы с объектом.

В твоём примере класс `Cell` содержит навигационное свойство `Modifier` типа `CellModifier`, но нет свойства, которое бы хранило значение внешнего ключа (например, `ModifierTitle`), ссылающееся на ключ `Title` в `CellModifier`.

## Как правильно задать внешний ключ

1. Добавь в класс `Cell` свойство для внешнего ключа, совпадающее по типу с ключом в `CellModifier`:

```cs
public sealed class Cell {
    
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }  // внешний ключ
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

  

2. В классе `CellModifier` ключ `Title` уже определён:

```cs
public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // первичный ключ
    
    [Range(0, double.MaxValue)]
    public double Work { get; set; }
}
```

3. EF Core по соглашению сопоставит `ModifierTitle` как внешний ключ, ссылающийся на `Title` в `CellModifier`.

4. При необходимости можно дополнительно настроить связь в методе `OnModelCreating`:

```cs
modelBuilder.Entity<Cell>()
    .HasOne(c => c.Modifier)
    .WithMany() // или .WithMany(m => m.Cells), если навигация есть и в CellModifier
    .HasForeignKey(c => c.ModifierTitle)
    .HasPrincipalKey(m => m.Title);
```


### Почему так
  

- Внешний ключ — это обычно скалярное свойство (например, `string`, `int`), которое хранит значение ключа связанной сущности.

- Навигационное свойство (`Modifier`) — это объект, позволяющий работать с объектом `CellModifier` напрямую.

- Атрибут `[ForeignKey(nameof(ModifierTitle))]` указывает, что `ModifierTitle` — внешний ключ для навигационного свойства `Modifier`.

- Если не добавить отдельное свойство для внешнего ключа, EF Core не сможет корректно сопоставить связь и сгенерирует ошибку или создаст теневой внешний ключ, что усложнит работу.

### Итог

Твой исправленный класс `Cell` должен выглядеть так:

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

Это классический и правильный способ задания внешнего ключа в EF Core[^1][^2][^5].

## Наследование моделей БД

<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

#### Можно ли в POCO-классах, моделях БД использовать механизм наследования, не нарушает ли это работу ORM?

Да, в POCO-классах для моделей базы данных в Entity Framework Core можно использовать механизм наследования, и это не нарушит работу ORM, если применить корректное сопоставление.

***

### Особенности наследования в EF Core

Entity Framework Core поддерживает три основных стратегии наследования для сопоставления иерархий классов с таблицами базы данных:

1. **Table-per-Hierarchy (TPH)** — все классы иерархии хранятся в одной таблице с дополнительным столбцом, указывающим конкретный тип. Это стратегия по умолчанию и самая простая.
2. **Table-per-Type (TPT)** — каждый класс в иерархии (базовый и наследники) сопоставляется со своей таблицей, наследники содержат только специфичные столбцы и связаны с таблицей базового класса ключом.
3. **Table-per-Concrete-type (TPC)** — для каждого класса создается отдельная таблица со всеми столбцами, включая унаследованные. Т.к. данных о базовом классе как отдельной таблице нет, при запросах к базовому классу выполняются объединения.

***

### Как использовать наследование в моделях

Пример TPH — самое распространенное:

```csharp
public abstract class Person {
    public int Id { get; set; }
    public string Name { get; set; }
}

public class Employee : Person {
    public decimal Salary { get; set; }
}

public class Customer : Person {
    public string Address { get; set; }
}
```

EF Core по умолчанию сохранит все в одну таблицу `People` с колонкой `Discriminator`.

***

### Настройка наследования через Fluent API

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder) {
    modelBuilder.Entity<Person>()
        .HasDiscriminator<string>("Discriminator")
        .HasValue<Employee>("Employee")
        .HasValue<Customer>("Customer");
}
```

Для TPT или TPC обычно требуется дополнительно настраивать, в первую очередь при сложных сценариях.

***

### Важные моменты

- Наследование в моделях позволяет использовать объектно-ориентированные преимущества без потери возможности работы с реляционной БД.
- EF Core отлично поддерживает наследование, нужно лишь правильно выбрать стратегию под задачу.
- Стандартный вариант TPH — наиболее простой и производительный, особенно на старте.
- Если используется SQLite, стоит учитывать, что TPT поддерживается с EF Core 5+, а TPC — с EF Core 7+ с некоторыми ограничениями.

***

### Вывод

Механизм наследования в POCO моделях полностью поддерживается EF Core и не нарушает его работу при правильной настройке моделей и контекста.
<span style="display:none">[^1][^2][^3][^4][^5][^6][^7][^8]</span>

<div style="text-align: center">⁂</div>

[^1]: https://itvdn.com/ru/video/ef-core-essential/imitation-in-models
[^2]: https://learn.microsoft.com/ru-ru/ef/ef6/modeling/code-first/fluent/types-and-properties
[^3]: https://learn.microsoft.com/ru-ru/ef/core/modeling/inheritance
[^4]: https://stackoverflow.com/questions/75218410/creating-poco-classes-for-complex-relationship-scenario-in-ef-core-7
[^5]: https://andrey.moveax.ru/post/mvc3-in-depth-entity-framework-02-working-with-entity-framework
[^6]: https://stackoverflow.com/questions/10295783/poco-inheritance-in-entity-framework
[^7]: https://www.reddit.com/r/dotnet/comments/1gsc0iv/ef_core_model_creating_types_with_inheritance/?tl=ru
[^8]: https://habr.com/ru/articles/47395/

#MERGE_NOTES

#DB #Dotnet #Dotnet/EntityFramework

[^1]: https://metanit.com/sharp/entityframeworkcore/3.1.php
[^2]: https://learn.microsoft.com/ru-ru/ef/core/modeling/relationships/foreign-and-principal-keys
[^3]: https://learn.microsoft.com/ru-ru/ef/core/change-tracking/relationship-changes
[^4]: https://www.reddit.com/r/dotnet/comments/1da6vvb/foreign_keys_in_ef_core_8/?tl=ru
[^5]: https://metanit.com/sharp/efcore/3.1.php
[^6]: https://dir.by/developer/entity_framework/foreign_key/?lang=rus%3Ffknohdjecbaiekfk
[^7]: https://ru.stackoverflow.com/questions/628915/Не-понимаю-как-расставить-внешние-ключи-entity-framework
[^8]: https://andrey.moveax.ru/post/mvc3-in-depth-entity-framework-03-code-first-conventions
