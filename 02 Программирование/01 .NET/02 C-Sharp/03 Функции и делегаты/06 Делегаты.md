Назад: [[05 Сопоставление с образцом|Сопоставление с образцом]]

> Для того, чтобы понимать, о чем идет речь в этой статье, необходимо знать, что такое [[01 Обобщения|обобщенные типы]] и как с ними работать

**Делегат** — это набор указателей на методы. Выполнение делегата означает выполнение всех методов, на которые указывает делегат. При этом порядок выполнения методов неизвестен.

> Делегат не должен указывать на группу методов, котрые должны выполняться последовательно

Делегат — это класс в мире функций, у классов есть объекты, а у делегатов методы.

В системе .NET делегат — это:

```cs
public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable;
```

абстрактный класс, предоставляющий необходимый интерфейс для взаимодействия с набором ссылок на методы.
Все производные типы от `Delegate` запечатаны. Программист самостоятельно не может создавать производные типы от `Delegate` и `MulticastDelegate`, это берет на себя компилятор. Программист может создавать делегатные типы опосредовано, через специальный синтаксис

Сам тип `Delegate`, как ни странно, делегатом не считается

- Тип `Delegate` представляет собой единственную ссылку на метод
- Тип `MulticastDelegate` представляет собой список ссылок на методы

Создание делегатного типа:

```csharp
delegate double F(double x);

F function = Math.Sin; // без скобок
```

> Обращение к методу без указания скобок возвращает ссылку на этот метод

Все делегаты содержат метод `Invoke()`, который явно вызывает все методы в **списке вызовов**, однако, этот метод использовать в по

## Лямбда-выражения

Как для примитивных типов, как для экземпляров класса, так и для делегатов можно использовать литералы.

**Лямбды** — это функциональные литералы, тип которых выводится по контексту

Условно, функциональные типы можно обозначать следующим образом:

```scala
(int, int) => int
//параметры => результат
```

Синтаксис лямбда-выражения очень похож на такое обозначение

Инициализация лямбдой:

```csharp
Action action = () => Console.WriteLine("Hello world");
```

Варианты синтаксиса лямбд:

| Лямбда-выражение         | Совместимый метод                                                                    |
| :----------------------- | :----------------------------------------------------------------------------------- |
| `() => 5`                | `int Method() { return 5; }`                                                         |
| `x => 2*x`               | `int Method(int x) { return 2*x; }` <br/>`decimal Method(decimal x) { return 2*x; }` |
| `(x) => 2*x`             | `int Method(int x) { return 2*x; }` <br/>`decimal Method(decimal x) { return 2*x; }` |
| `(double x) => 2*x`      | `double Method(double x) { return 2*x; }`                                            |
| `(x, y, z) => x + y - z` | `int Method(int x, int y, int y) { return x + y - z; }`                              |

Типы параметров и тип возвращаемого значения в приведенных выше лямбдах невозможно вывести без соответствующего контекста, поэтому в случае неоднозначности, нужно явно указывать типы параметров и возвращаемого значения.

```csharp
x => {
	Console.WriteLine("x is " + x);
    
    int Pow2(x, power)
    {
        for(int i = 0; i < power; i++)
            x *= x * 2;
        return x;
    }
    
    Console.WriteLine("f(x) is " + Pow2(x));
};
```

* Анонимная функция (устаревший синтаксис) — это аналог литерала:

```csharp
delegate(double x)
{
	return 2 * x * x - 3;
}
```

> Лямбды могут приводится к 2 типам: к делегатам и к абстрактным синтаксическим деревьям (AST)

При использовании `var` для инициализации делегата лямбдой обязательно нужно указывать тип явно.

Делегаты могут содержать ссылки на неограниченное количество однотипных методов (одно и тоже возвращаемое значение и список параметров с их типами).

>Стандарт .NET порядок вызова методов делегата не специфицирует. Вызов методов может происходить в порядке добавления, в случайном порядке, параллельно. Поэтому мультиделегаты обычно используются, если они не возвращают значение (void).

ЧТО ВОЗВРАЩАЕТ МУЛЬТИДЕЛЕГАТ С ВОЗВРАЩАЕМЫМ ЗНАЧЕНИЕМ?

Добавление методов в делегат происходит с помощью оператора +:

```csharp
delegate double Rfunction (double x);
Rfunction func = Math.Sin;
func = func + Math.Cos;
func += Math.Tan;
func -= Math.Sin; // удаление функции из делегата
```

> Если инициализировать делегат лямбда-выражением, то невозможно будет удалить лямбду из списка выполняемых методов, так как ссылки в коде на нее нет.  Придется удалять все данные, на которые указывает делегат

## Методы делегатов

| Метод                 | Оператор  | Описание                                                          |
| --------------------- | --------- | ----------------------------------------------------------------- |
| `Combine()`           | `+`, `+=` | добавляет метод в список вызова                                   |
| `Remove()`            | `-`, `-=` | удаление метода из делегата                                       |
| `RemoveAll()`         |           | очистка делегата                                                  |
| `GetInvokationList()` |           | список делегатов, которые ссылаются на метод из текущего делегата |

## Замыкания

```csharp
Action Outer()  // метод или внешняя функция
{
    int x = 5;  // лексическое окружение - локальная переменная
    void Inner()    // локальная функция
    {
        x++;        // операции с лексическим окружением
        Console.WriteLine(x);
    }
    return Inner;   // возвращаем локальную функцию
}
//...

var fn = Outer;
fn(); //6
fn(); //7
fn(); //8
```

>Когда время жизни функции превосходит время жизни отдельных переменных, используемых внутри этой функции, то такие переменные захватываются функцией в специальный контекст. Этот механизм называется **захватом переменной** или **замыканием**. Поэтому в любом ЯП с наличием функциональных типов содержится не только ссылки на функции, но и специальный контекст

Далее: [[07 _Встроенные делегаты|Встроенные делегаты]]

#C-Sharp #C-Sharp/Fun