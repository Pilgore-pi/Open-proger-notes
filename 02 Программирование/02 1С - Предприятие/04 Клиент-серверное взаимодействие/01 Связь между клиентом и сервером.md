[Объект нельзя использовать в данных формы](https://forum.infostart.ru/forum9/topic275778/)

https://infostart.ru/1c/articles/75329/

https://infostart.ru/1c/articles/198766/

----

Платформа предпринимает массу усилий, чтобы в повседневной работе программиста ему не приходилось с этим заморачиваться. Как правило, мы, как и раньше, присваиваем свойства реквизитам формы, а они попадают в СправочникОбъект, а оттуда – в ИБ.

Разница заключается в том, что теперь на клиенте не существует «СправочникОбъект». Как я уже говорил, это сложный объект, он не сериализуется, а значит, его нельзя передавать с клиента на сервер. Вместо «Объекта» на клиенте существует его упрощенный аналог – хранилище данных – объект ДанныеФормы.

Это, по сути, просто структура, у которой свойства совпадают со свойством объекта


Основным «двигателем» всех аспектов управляемой формы является то, что у нас state-less сервер. На нем не сохраняется ничего, никаких промежуточных данных. Всё состояние формы (текст в полях ввода, строки табличных частей и т.п.) хранится на клиенте. Вся совокупность данных формы называется контекстом формы.


Весь клиент-серверный обмен выполняется через сериализацию данных, а это, в свою очередь накладывает ограничения на те типы данных, которые можно передавать на сервер и обратно. Ограничения существуют из-за того, что не все типы данных поддерживают сериализацию 

## Жизненный цикл формы объекта

Давайте рассмотрим, что происходит, когда мы открываем форму существующего элемента справочника.

1. На клиенте вызывается метод «ОткрытьФорму» или мы просто открываем форму из какого-либо списка справочника. Начинается серверный вызов
2. В памяти сервера создается новый СправочникОбъект, выполняется код модуля объекта (тот, что написан в самом низу модуля)
3. Данные объекта считываются из базы данных, присваиваются значения реквизитов, наполняются табличные части объекта СправочникОбъект.
4. В памяти сервера создается новая управляемая форма элемента
5. Вызывается событие формы ПриЧтенииНаСервере, куда передается свежесозданный СправочникОбъект в параметре ТекущийОбъект
6. Основной реквизит формы «Объект», тот, что в списке реквизитов выделен жирным шрифтом наполняется данными на основании данных СправочникОбъект. Здесь происходит обычное поэлементное присваивание свойствам объекта ДанныеФормы значений, записанных в одноименных свойствах объекта СправочникОбъект. По сути, происходит «ЗаполнитьЗначенияСвойств(ДанныеФормы, СправочникОбъект)
7. СправочникОбъект **уничтожается**. Все его данные стираются из памяти сервера.
8. Вызывается событие формы «ПриСозданииНаСервере», в котором мы получаем уже заполненные ДанныеФормы
9. Данные формы сериализуются и отправляются на клиента, где форма отображается пользователю

Обратите внимание, что СправочникОбъект, к которому мы так привыкли в обычном приложении, уничтожился. Если в модуле объекта были какие-либо глобальные переменные, экспортные или не экспортные, все они стали потеряны.

----

В управляемых формах на первый план выходит разделение контекста на клиентский и серверный. Для возможности работы по тонким каналам связи вся работа прикладных объектов теперь выполняется только на сервере. На клиенте отображается уже подготовленная на сервере форма, выполняется ввод данных и вызовы сервера для записи введенных данных и других необходимых действий

В модуле управляемой формы возможно объявление переменных, процедур и функций. Так как управляемая форма существует одновременно и на сервере и на клиенте, то каждая процедура и функция  и объявление переменной должны предваряться  директивой компиляции, определяющей среду исполнения.

**Допустимы следующие директивы:**

> `&НаКлиенте` — означает, что метод выполняется на стороне клиента, а **переменная существует все время жизни клиентской части** формы. Клиентская процедура исполняется в среде клиентского приложения.

Доступны: Свойства и методы глобального контекста, доступные на клиенте; экспортные переменные; процедуры и функции модуля управляемого приложения, общих модулей скомпилированных на клиенте, общих модулей скомпилированных на сервере, если у них установлено свойство «Вызов Сервера»; свойства и методы расширения формы, определяемого основным реквизитом; свойства и методы объекта встроенного языка УправляемаяФорма; реквизиты формы; локальный контекст модуля.

> `&НаСервере` — означает, что метод выполняется на стороне сервера, а **переменная существует только во время выполнения серверного вызова**, **при каждом серверном вызове значение переменной сбрасывается**.

Для серверных методов допустимы вызовы:

- серверных,
- серверных внеконтекстных
- и клиент-серверных внеконтекстных методов.

Контекст так же образуется:

- cвойствами,
- методами глобального контекста,
- экспортными процедурами,
- функциями общих модулей скомпилированных на сервере,
- свойствами и методами расширения формы, определяемого основным реквизитом,
- свойствами  и методами объекта встроенного языка `УправляемаяФорма`,
- реквизитами формы.

Клиентские процедуры, функции и переменные недоступны.

> `&НаСервереБезКонтекста` — определяет серверную процедуру, исполняемую вне контекста формы. **Переменные не могут предваряться такой директивой**.

Серверная процедура, исполняемая вне контекста формы, (внеконтекстная) исполняется в среде серверного приложения. В такой процедуре не доступен контекст формы (включая данные формы). Допустимыми являются вызовы только других внеконтекстных процедур. При вызове этих процедур не выполняется передача данных формы на сервер и обратно. Применение внеконтекстных процедур позволяет существенно уменьшить объем передаваемых данных при вызове серверной процедуры из среды клиентского приложения.

> `&НаКлиентеНаСервереБезКонтекста` — используется, когда к процедуре необходимо обращаться как с клиента, так и с сервера. Означает, что метод исполняется как на клиенте, так и на сервере вне контекста формы. **Переменные не могут предваряться такой директивой**.

Таким образом, разработчик должен понимать, что он фактически работает с двумя контекстами исполнения: серверным и клиентским, и между ними происходит обмен данными

При этом нужно учитывать, что на клиенте поддерживается лишь ограниченный набор типов данных и  интерфейсные функции.

**На клиенте не допускается:**

- непосредственная работа с базой данных,
- работа непосредственно с прикладными объектами,
- использование запросов,
- таблиц значений.

Доступность описана в синтакс-помошнике и ее необходимо проверять.

При разработке необходимо заботиться об оптимизации клиент-серверного взаимодействия:

- Основные вычисления должны выполняться в серверных процедурах;
- Нужно уменьшать количество серверных вызовов, когда из процедур `&НаКлиенте` вызываются процедуры `&НаСервереБезКонтекста` и `&НаСервере`;
- Количество контекстных серверных вызовов нужно минимизировать, лучше использовать процедуры `&НаСервереБезКонтекста` и передавать значения через параметры

Еще одна важная особенность управляемой формы состоит в том, что в ней происходит лишь отображение объекта. Основным ее реквизитом является не сам объект, а данные формы, в которые он преобразуется.

Элементами данных формы могут быть

- `ДанныеФормыСтруктура` (СправочникОбъект, ДокументОбъект...)
- `ДанныеФормыКоллекция` (Табличные части, динамические списки, таблицы значений)
- `ДанныеФормыСтруктураСКоллекцией` (НаборЗаписейРегистра)
- `ДанныеФормыДерево` (ДеревоЗначений)

Поэтому, для управляемой формы напрямую свойства и методы объекта недоступны. Чтобы обратиться из формы к свойствам и методам объекта нужно сначала получить объект.

[!https://infostart.ru/upload/iblock/a78/gfywo%20w%20kwmwdt.jpg]


----

Код в формах разделен на 2 логических пространства: Клиент и Сервер. Каждая переменная или функция относится к клиенту, к серверу или к клиенту и серверу.

Ранее прямого разделения на Сервер и Клиент не было. Ранее существовал только толстый клиент, но с выходом версии 8.2 появился **тонкий клиент**, который уменьшил количество вычисляемых операций на стороне клиента.

Каждая из директив компиляции определяет, где будет выполняться процедура или функция: на клиенте или на сервере, и как будет происходить взаимодействие с контекстом формы. Контекст формы находится на клиенте ~И НА СЕРВЕРЕ*

Доступность вызова методов одних из других определяется этой схемой:

- `&НаКлиенте`
    - `&НаСервере`
        - `&НаКлиентеНаСервере`~
            - `&НаСервереБезКонтекста`
                - `&НаКлиентеНаСервереБезКонтекста`

## Где доступны директивы

| Директива                         | Где доступно                       |
| --------------------------------- | ---------------------------------- |
| `&НаКлиенте`                      | Модули форм, общие модули, команды |
| `&НаСервере`                      | Модули форм, общие модули          |
| `&НаКлиентеНаСервере`             | Модули форм                        |
| `&НаСервереБезКонтекста`          | Модули форм                        |
| `&НаКлиентеНаСервереБезКонтекста` | Модули форм                        |

Из клиента можно вызывать любую функцию, а, например, из `&НаСервереБезКонтекста` можно вызывать только `&НаКлиентеНаСервереБезКонтекста`

>**Серверный вызов** – это передача какой-то информации с клиентской части «1С:Предприятие 8» на серверную часть с целью вернуть обратно некий набор данных. Сервер не может инициировать запрос к клиенту

При совершении серверного вызова можно увидеть обновление счетчика "Текущие вызовы" в левой нижней окна приложения

| Сущность кода с аннотацией              | Доступность | Где доступно |
| --------------------------------------- | ----------- | --------------------------------- |
| `&НаСервере` любая сущность             | Есть        | Данные формы, база данных         |
| `&НаКлиенте` любая сущность             | Есть        | Данные формы                      |
| `&НаКлиентеНаСервере` любая сущность    | Есть        | Данные формы                      |
| `&НаСервереБезКонтекста` любая сущность | Есть        | База данных                       |
| `&НаКлиентеНаСервереБезКонтекста` метод | Есть        | Только параметры метода           |
| Метод `&НаКлиенте`                      | Нет         | переменная модуля `&НаСервере`    |
| Метод `&НаСервере`                      | Нет         | переменная модуля `&НаКлиенте`    |

>В общих модулях доступны только 2 директивы: `&НаКлиенте` и `&НаСервере`. В общих модулях контекст формы отсутствует~~

* В правой колонке под "базой данных" подразумевается вся информация в базе данных, объекты конфигурации и метаданные конфигурации. Клиент может получить данные из БД только через серверные вызовы.

Директива `&НаСервере` **используется по умолчанию** и подразумевает выполнение кода на сервере, при этом на сервер передается весь контекст формы (для общих форм контекст не передается~).

При использовании директивы `&НаСервереБезКонтекста` отправка контекста не совершается, что позволяет совершать меньше операций и занимать меньше памяти. Однако можно передать необходимые данные через параметры серверного метода

Рекомендуется совершать минимальное количество серверных вызовов и избегать их выполнение в цикле. Обычно, можно подготовить данные для отправки одним пакетом, чтобы не плодить много вызовов.

Метод с директивой `&НаКлиентеНаСервереБезКонтекста` полностью аналогичен двум таким же методам с директивами: `&НаКлиенте` и `&НаСервереБезКонтекста`. Метод с такой директивой может взаимодействовать с общими модулями

* Нельзя применять несколько директив к методу и объявлять одинаковые методы с разными директивами

## Конвертация данных формы (клиента) в прикладные объекты (сервер)

Для конвертирования прикладных объектов в данные формы и обратно существует набор глобальных методов:

| Метод | Описание |
|-|-|
| `ЗначениеВДанныеФормы(значение, объектФормы)` | преобразует объект прикладного типа в данные формы |
| `ДанныеФормыВЗначение(объектФормы, тип)` | (не рекомендуется) преобразует данные формы в объект прикладного типа. **Нельзя преобразовать в объект типа `ТабличнаяЧасть`**. Эффект данного метода полностью совпадает с метдом `РеквизитФормыВЗначение()`. Данный метод требует обязательное указание типа данных, в то время, как `РеквизитФормыВЗначение()` автоматически выводит тип |
| `КопироватьДанныеФормы(источник, приемник)` | Копирует данные одного объекта формы в другой. Возвращает значение Истина, если копирование произведено, или Ложь, если структура объектов несовместима. Метод доступен `&НаКлиенте` |
| `<УправФорма>.РеквизитФормыВЗначение(имяРеквизита, [тип])` | преобразует реквизит данных формы в объект прикладного типа |
| `<УправФорма>.ЗначениеВРеквизитФормы(значение, имяРеквизитаФормы)` | выполняет преобразование объекта прикладного типа в заданный реквизит формы |

Все методы, кроме `КопироватьДанныеФормы`, не доступны на клиенте

Упомянутый параметр `объектФормы` может представлять один из типов формы:

- `ДанныеФормыСтруктура`
- `ДанныеФормыКоллекция`
- `ДанныеФормыСтруктураСКоллекцией`
- `ДанныеФормыДерево`

В целом, только эти типы данных поддерживают преобразования в прикладные объекты (помимо примитивных типов)

При преобразовании данных формы в прикладные объекты и обратно используется кеширование объектов, но при этом выполняется проверка актуальности версии объекта в кеше

При выполнении стандартных действий (открытие формы, выполнение стандартной команды Записать и т. д.) в форме с основным реквизитом преобразование выполняется автоматически

Использование данных методов обычно удобнее, так как они имеют, например, информацию о типе реквизита формы. Кроме того, метод РеквизитФормыВЗначение() выполняет установку соответствия данных формы и объекта, которая используется при формировании сообщений (см. [здесь](https://its.1c.ru/db/v837doc/content/src/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0/%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0%206.%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D1%8B%D0%B9%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81.htm_?anchor=_ref220330559).

При преобразовании ТаблицыЗначений и ДереваЗначений, требуется чтобы количество всех колонок было не меньше, чем в соответствующих элементах формы (ДанныеФормыКоллекция, ДанныеФормыДерево)

> Колонки реквизитов, не связанные с данными, не участвуют в преобразовании значений между данными формы и объектами информационной базы и обратно. Колонки, отсутствующие в данных объекта, очищаются при преобразовании в данные формы

**Пример:**

```bsl
&НаСервере
Процедура ПересчитатьНаСервере()

    // Преобразует реквизит Объект в прикладной объект
    Документ = РеквизитФормыВЗначение(«Объект»);

    // Выполняет пересчет методом, определенным в модуле объекта
    Документ.Пересчитать();

    // Преобразует прикладной объект обратно в реквизит
    ЗначениеВРеквизитФормы(Документ, «Объект»);

КонецПроцедуры
```

> **`ЗначениеВРеквизитФормы()`** необходимо использовать, если происходит редактирование данных формы на сервере, полученных через `РеквизитФормыВЗначение()`, чтобы оповестить форму о совершенных изменениях.

Если бы мы сразу в этой процедуре изменили что-нибудь на форме, то она бы перерисовалась сама собой. А, так как вызывается метод объекта, который никак не связан с представлением, то надо бы "оповестить" форму о том, что ее изменили.

#question

> **Можно ли выполнять преобразование вложенных данных формы, типа Объект.Товары?**

-----

## Предопределенные значения на клиенте

Значение предопределенных данных `&НаКлиенте` можно получить только через функцию `ПредопределенноеЗначение()`

Метод применим к перечислениям, ссылкам, элементам справочников и др.

```bsl
// Пользовательское перечисление
ЮрФизЛицо = ПредопределенноеЗначение("Перечисление.ЮридическоеФизическоеЛицо.ЮридическоеЛицо");

// Системное перечисление (типСистемногоПеречисления.Значение)
ТипДиаграммы = ПредопределенноеЗначение("ТипДиаграммы.ВогнутаяПоверхность");

// Пустая ссылка на тип "Документ.РасходнаяНакладная". Тип - это предопределенное значение
ПредопределенноеЗначение("Документ.РасходнаяНакладная.ПустаяСсылка");

// Получение предопределенных данных справочника
Элемент = ПредопределенноеЗначение("Справочник.Валюта.Рубль");

// Точка маршрута бизнес процесса
Точка = ПредопределенноеЗначение("БизнесПроцесс.Согласование.ТочкаМаршрута.Одобрение");
```

#1С #1С/Язык_программирования
