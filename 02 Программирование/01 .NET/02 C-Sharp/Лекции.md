# Делегаты

Делегаты – функциональные типы

delegate double F(double x); – создание нового типа данных “F”

◉ Делегаты – это ссылочные типы

Вопрос 1: с чем данный тип совместим?

Вопрос 2: какие действия над ним можно выполнять?

```cs
F f = Math.Sin;

double sinus = f(3);

void Tabulate(double x0, double x1, double step, F f)
{
	for(var x = x0; x < x1; x += step)
	{
		Console.WriteLine($”x = {x} y = {f(x)}”);
	}
}

Tabulate(0, 1.0, 0.01, Math.Sin);
```

```cs
...
double MyParab(double x) => 2*x*x – 3;

Tabulate(0, 1.0, 0.01, MyParab);

Tabulate(0, 1.0, 0.01, delegate(double x) {

return 2*x*x-3;
}


); //старый синтаксис

Tabulate(0, 1.0, 0.01, x => 2*x*x - 3); //новый лямбдовый синтаксис

Общий синтаксис лямбд:

параметры => результат

* () => ...

* x => ...

* (x) => ...

* (x, y) => ...

* (double x) => ...

* () => 2*x

* () => {... return ..;}
```

λ-выражения могут приводиться к разным типам данных:
1. К делегатам
2. К абстрактным синтаксическим деревьям (AST – expression)

Поэтому могут возникать коллизии

```cs
F f = x => 2*x; // λ приводится к делегату

var f = x => 2*x; //Ошибка компиляции

public delegate void Logger(object o);

void Print2Console(object o)
{
    Console.WriteLine(o);
}

void Print2File(object o)
{
    File.AppendText(o.ToString());
}

...

Logger l = Print2Console;

l(“abc”);

l = Print2File;

l(“abc”);

///

Logger l = Print2Console;

l(“abc”);

l = l + Print2File; //Мультиделегат – произошло комбинирование

l(“abc”); //запись объекта как в консоль, так и в файл

l+= Print2Console;

l(“def”);
```

▽ Стандарт .Net порядок вызова методов делегата не специфицирует. Вызов методов может происходить в порядке добавления, в случайном порядке, параллельно. Поэтому мультиделегаты обычно используются, если они не возвращают значение (void).

```cs
F MakeAdder(double delta)

{

return x => x + delta;

}//x – double, так как был объявлен делегат delegate double F(double x);

...
```

```cs
var inc = MakeAdder(1);

var dec = MakeAdder(-1);

inc(5);//6

dec(5);//4
```

Где хранится delta?

Параметры метода храняться в стеке, пока функция не завершена.

//В приведенном случае ошибки не происходит, так как параметр

Когда время жизни функции превосходит время жизни отдельных переменных, используемых внутри этой функции, то такие переменные захватываются функцией в специальный контекст. Этот механизм называется захват переменной или замыкание. Поэтому в любом ЯП с наличием функциональых типов содержится не только ссылки на функции, но и специальный контекст.

```cs
Обобщенный делегат Func<R>       R Func();

Func<T,R>       R Func(T t)

Func<T1, … , Tn, R>    R Func(T1 t1, … Tn tn)

Action                 void Action()

Action<T>              void Action(T t)
```

# События

Это публичный член класса, который позволяет снаружи класса узнать, что внутри класса что-то случилось.

Синтаксис:

```cs
[<access modifier>] event <Delegate> <Name>;
```

События могут содержаться в: структурах, классах, интерфейсах.

Обработчик события – это метод, соответствующий типу делегата события, который вызывается при проишествии события.

Событие могут обрабатывать множество обработчиков событий. Это можно сделать с помощью подписки на события нескольких методов или лямбд, или делегата.

Ключевое поле event внутри класса позволяет делать все, что угодно, а снаружи класса доступны 2 действия (подписка на событие (subscribing) + и отписка от события (unsubscribing) –)

```cs
public event EventHandler ItHappened;

...

ItHappened += WriteMessage;

ItHappened += PrintMessage;

ItHappened –= PrintMessage;
```
Событие, не указывающее ни на один из обработчиков события равно null.

**Вызов** события может осуществляться только в определяющем типе. Есть 3 способа вызова события:

```cs
ItHappened(...)

ItHappened.Invoke(...)

ItHappened?.Invoke(...)
```

Аксессоры

Пример

```csharp
public class Electro {

public event EventHandler TurnedOn;

//происходит после включения прибора (завершенные события)

public void TurnOn() {
    //включаем прибор
    if(TurnedOn != null)
        TurnedOn(this);
    }
}

...

var lamp = new Electro();

lamp.TurnedOn += OnTurnOn;

//+= – subscribe

//-= – insubscribe – это доступные из вне методы для любого события

lamp.TurnOn();

//Событие вызывается внутри определяющего его класса

lamp.TurnedOn(null); //Error! нельзя обращаться к событию напрямую

lamp.TurnedOn += (o) => {...} //Не рекомендуется

//такой обработчик события нельзя отписать от события
```

# Интерфейсы

Отвечает на вопрос, какой функционал реализуется классом.

Жесткий диск – это не интерфейс SATA, он реализует его, поэтому SATA должен быть интерфейсом, а не базовым классом.

Интерфейс – это стандарт на взаимодействие 2х и более частей.

Синтаксис:

```cs
[<modifier>] interface <Title>{...}
```

◉ модификатор интерфейса – это только модификатор доступа.

Все элементы интерфейса по умолчанию – public

Элементами интерфейса могут быть:

* Константы
* Свойства
* Методы
* События

```cs
interface IPrintable
{
    void Print();
}
```

jjjj

Интерфейс **совметстим** с любым объектом, реализующим этот интерфейс.

Все допустимые **действия над интерфейсом** определены внутри этого интерфейса.

▽ Интерфейс не может быть реализован частично

Реализация интерфейса


```cs
class Cat : Animal, IPrintable
{
    public void Print(){...}  //неявная реализация
}
```


Если в классе есть публичные элементы, которые сопадают по прототипу с членом интерфейса, то они будут восприняты как реализация члена интерфейса, в противном случае нужно будет создать публичный член класса, реализующий член интерфейса.

```cs
var c = Cat();

IPrintable p = c;

c.Print(); //public Print

p.Print(); //public Print

Явная реализация

class Cat : Animal, IPrintable

{

void IPrintable.Print() => Console.WriteLine(“Meow”); //private

//модификатор private явно писать нельзя

}

var c = Cat();

IPrintable p = c;

c.Print(); //Ошибка компиляции

p.Print(); //private Print

///////////////////////////////////////

class Cat : Animal, IPrintable

{

void IPrintable.Print() => Console.WriteLine(“Meow”); //private

public void Print() => Console.WriteLine(“Ruff”);

}

var c = Cat();

IPrintable p = c;

c.Print(); //public Print

p.Print(); //private Print

class Cat : Animal, IPrintable, IWritable

{

//IPrintable.Print(){...}

//Iwritable.Print(){...}

}

...

//Реализация вывода в консоль или в файл по выбору

interface IPrintable

{

void Print(TextWriter w);

void Print() => Print(Console.Output);

}
```

Класс должен реализовать только элементы, которые не реализованы. При этом остальные члены интерфейса добваляются в класс автоматически.

Если метод в интерфейсе является приватным, то он должен объявлять тело.

# Конструкторы

В C# есть деструкторы. В подавляющем большинстве случаев они не используются.

Все конструкторы неявно вызывают метод Initialize. То есть фактически конструкторы – это инициализаторы, деструкторы – финализаторы.

Если в классе не описан ни одни конструктор, то компилятор C# (не .Net) создает конструктор по умолчанию без параметров.

Если описан хотя бы один конструктор, то компилятор больше не вмешивается.
```cs
class Point {

public Point(double x, double y) => ...

...

}

var p = new Point (5, -3);
```
Если единственный конструктор приватный, то объект создать нельзя.

Статический конструктор

class Point

{

static Point(){...} //без модификаторов

}

Нужен для инициализации статических членов класса.

Статический конструктор вызывается автоматически средой .Net, при этом неизвестно когда. Но система гарантирует, что инициализация произойдет до обращения к статическим полям/свойствам.

#C-Sharp #Functions/Delegates