
> **Дерево** — это иерархическая структура данных, состоящая из узлов, связанных между собой рёбрами, где один узел является корнем, а остальные образуют поддеревья

Деревья являются одной из самых важных нелинейных структур данных и широко используются в программировании. Деревья имеют следующие преимущества:

- Эффективный поиск данных (`O(log n)` для сбалансированных деревьев)
- Естественное представление иерархических данных
- Гибкость в организации данных
- Эффективные операции вставки и удаления

Недостатки:

- Сложность реализации по сравнению с линейными структурами
- Возможна деградация производительности при несбалансированности
- Требуют больше памяти из-за хранения указателей

## Основные понятия

> **Узел (Node)** — базовый элемент дерева, содержащий данные и ссылки на другие узлы

```csharp
public class TreeNode<T> {
    public T Data { get; set; }
    public TreeNode<T> Left { get; set; }
    public TreeNode<T> Right { get; set; }
}
```

> **Корень (Root)** — верхний узел дерева, не имеющий родителя. Точка входа в дерево

> **Лист (Leaf)** — узел, не имеющий потомков (дочерних узлов)

> **Родитель (Parent)** — узел, имеющий ссылки на дочерние узлы

> **Потомок (Child)** — узел, на который ссылается родительский узел

> **Поддерево (Subtree)** — часть дерева, которая сама является деревом

> **Высота дерева (Height)** — максимальное расстояние от корня до листа (количество рёбер)

> **Глубина узла (Depth)** — расстояние от корня до данного узла

> **Уровень (Level)** — множество узлов на одинаковой глубине

> **Степень узла (Degree)** — количество потомков узла

**Пример**. Рассмотрим файловую систему компьютера. Корневая папка `C:\` — это корень дерева. Папки `Program Files`, `Windows`, `Users` — это потомки корня. Файлы внутри папок, не содержащие вложенных элементов — это листья. Вся структура папки `Users` со всеми вложенными папками и файлами — это поддерево.

## Виды деревьев

### Бинарное дерево (Binary Tree)

> **Бинарное дерево** — дерево, в котором каждый узел имеет не более двух потомков (левый и правый)

```csharp
public class BinaryTreeNode<T> {
    public T Value { get; set; }
    public BinaryTreeNode<T> Left { get; set; }
    public BinaryTreeNode<T> Right { get; set; }
}
```

**Свойства:**

- Максимум 2 потомка у каждого узла
- Различают левое и правое поддерево
- Максимальное количество узлов на уровне h: 2^h

### Бинарное дерево поиска (Binary Search Tree, BST)

> **BST** — бинарное дерево, где для каждого узла все значения в левом поддереве меньше значения узла, а в правом — больше

```csharp
public class BST<T> where T : IComparable<T> {
    private TreeNode<T> root;
    
    public void Insert(T value) {
        root = InsertRec(root, value);
    }
    
    private TreeNode<T> InsertRec(TreeNode<T> node, T value) {
        if (node == null) return new TreeNode<T>(value);
        
        if (value.CompareTo(node.Data) < 0)
            node.Left = InsertRec(node.Left, value);
        else if (value.CompareTo(node.Data) > 0)
            node.Right = InsertRec(node.Right, value);
            
        return node;
    }
}
```

**Сложность операций:**

- Поиск: `O(log n)` в среднем, `O(n)` в худшем
- Вставка: `O(log n)` в среднем, `O(n)` в худшем
- Удаление: `O(log n)` в среднем, `O(n)` в худшем

### Полное бинарное дерево (Complete Binary Tree)

> **Полное бинарное дерево** — дерево, в котором все уровни, кроме возможно последнего, полностью заполнены, а последний уровень заполнен слева направо

**Применение:** используется в реализации двоичной кучи (heap)

### Совершенное бинарное дерево (Perfect Binary Tree)

> **Совершенное бинарное дерево** — дерево, в котором все внутренние узлы имеют ровно два потомка, а все листья находятся на одном уровне

**Свойства:**

- Количество узлов: $2^{h+1} - 1$, где $h$ — высота
- Количество листьев: $2^h$

### Сбалансированное дерево (Balanced Tree)

> **Сбалансированное дерево** — дерево, в котором для каждого узла высота левого и правого поддеревьев различается не более чем на 1

**Цель:** обеспечить `O(log n)` для основных операций

### AVL-дерево

> **AVL-дерево** — самобалансирующееся бинарное дерево поиска, где для каждого узла разница высот левого и правого поддеревьев не превышает 1

```csharp
public class AVLNode<T> {
    public T Value { get; set; }
    public AVLNode<T> Left { get; set; }
    public AVLNode<T> Right { get; set; }
    public int Height { get; set; }
}
```

**Операции балансировки:**

- Левый поворот (Left Rotation)
- Правый поворот (Right Rotation)
- Лево-правый поворот (Left-Right Rotation)
- Право-левый поворот (Right-Left Rotation)

**Операции поворотов**

- **Левый поворот** (Left Rotation): Поворачиваем поддерево так, чтобы правый ребёнок узла x стал его родителем, а левое поддерево этого правого ребёнка перешло в правое поддерево x. По сути, "проворачиваем" связку x и его правого ребёнка, изменяя ссылки так, чтобы высота и свойства дерева сохранились.

- **Правый поворот** (Right Rotation): Симметричная операция левому повороту, где левый ребёнок узла x становится его родителем, а правое поддерево этого левого ребёнка переходит в левое поддерево x.

Эти операции изменяют структуру дерева локально, сохраняя порядок элементов, и используются при исправлении нарушений свойств дерева после вставок и удалений.

**Сложность всех операций:** `O(log n)` гарантированно

### Красно-чёрное дерево (Red-Black Tree)

> **Красно-чёрное дерево** — самобалансирующееся бинарное дерево поиска, где каждый узел имеет цвет (красный или чёрный) и выполняются определённые правила

**Правила:**

1. Каждый узел либо красный, либо чёрный
2. Корень всегда чёрный
3. Все листья чёрные
4. Красный узел не может иметь красного потомка
5. Все пути от узла до листьев содержат одинаковое количество чёрных узлов
6. При вставке нового узла он изначально окрашивается в красный цвет. Если при этом нарушаются правила, выполняются повороты и перекраска, чтобы восстановить свойства

```csharp
public class RBNode<T> {
    public T Value { get; set; }
    public RBNode<T> Left { get; set; }
    public RBNode<T> Right { get; set; }
    public RBNode<T> Parent { get; set; }
    public bool IsRed { get; set; }
}
```

**Применение:** `SortedSet<T>` и `SortedDictionary<TKey, TValue>` в .NET

**Сложность операций:** O(log n) гарантированно

### B-дерево (B-Tree)

> **B-дерево** — самобалансирующееся дерево поиска, оптимизированное для систем, которые читают и пишут большие блоки данных (базы данных, файловые системы)

Количество ключей в узле и количество его потомков зависит от порядка B-дерева. Каждое B-дерево имеет порядок.

Порядок — это параметр (часто обозначается как $m$ или $t$), который определяет максимально допустимое число потомков (ветвей) у каждого узла дерева

B-дерево порядка $m$ обладает следующими свойствами:

- **Свойство 1**: Глубина всех листьев одинакова.
- **Свойство 2**: Все узлы, кроме корня должны иметь как минимум $(m/2) – 1$ ключей и максимум $m-1$ ключей.
- **Свойство 3**: Все узлы без листьев, кроме корня (т.е. все внутренние узлы), должны иметь минимум $m/2$ потомков.
- **Свойство 4**: Если корень – это узел не содержащий листьев, он должен иметь минимум 2 потомка.
- **Свойство 5**: Узел без листьев с $n-1$ ключами должен иметь $n$ потомков.
- **Свойство 6**: Все ключи в узле должны располагаться в порядке возрастания их значений.

Ключ — это значение, по которому происходит сортировка и поиск в дереве

[Статья на Habr](https://habr.com/ru/companies/otus/articles/459216/)

**Применение:** индексы в базах данных (SQL Server, PostgreSQL)

### B+ дерево

> **B+ дерево** — вариант B-дерева, где все данные хранятся только в листьях, а внутренние узлы содержат только ключи для навигации

**Преимущества:**

- Листья связаны в список — эффективный последовательный доступ
- Более эффективное использование кэша
- Лучше для range-запросов

### Префиксное дерево (Trie)

> **Trie (префиксное дерево)** — дерево для хранения строк, где путь от корня до узла представляет префикс. Префикс — это последовательность символов, которая является началом строки.

```csharp
public class TrieNode {
    public Dictionary<char, TrieNode> Children { get; set; }
    public bool IsEndOfWord { get; set; }
    
    public TrieNode() {
        Children = new Dictionary<char, TrieNode>();
        IsEndOfWord = false;
    }
}
```

**Применение:**

- Автодополнение текста
- Проверка орфографии
- IP-маршрутизация

**Сложность операций:** `O(m)`, где `m` — длина строки

### N-арное дерево (N-ary Tree)

> **N-арное дерево** — дерево, в котором каждый узел может иметь до N потомков

```csharp
public class NaryTreeNode<T> {
    public T Value { get; set; }
    public List<NaryTreeNode<T>> Children { get; set; }
    
    public NaryTreeNode(T value) {
        Value = value;
        Children = new List<NaryTreeNode<T>>();
    }
}
```

**Применение:** DOM-дерево в HTML, организационные структуры

### Дерево отрезков (Segment Tree)

> **Дерево отрезков** — структура данных для эффективного выполнения операций на отрезках массива (сумма, минимум, максимум)

**Сложность:**

- Построение: `O(n)`
- Запрос: `O(log n)`
- Обновление: `O(log n)`

**Применение:** задачи с запросами на отрезках

### Дерево Фенвика (Fenwick Tree / Binary Indexed Tree)

> **Дерево Фенвика** — структура данных для эффективного вычисления префиксных сумм и обновления элементов

```csharp
public class FenwickTree {
    private int[] tree;
    
    public FenwickTree(int size) {
        tree = new int[size + 1];
    }
    
    public void Update(int index, int delta) {
        index++; // 1-based indexing
        while (index < tree.Length) {
            tree[index] += delta;
            index += index & (-index);
        }
    }
    
    public int Query(int index) {
        index++; // 1-based indexing
        int sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= index & (-index);
        }
        return sum;
    }
}
```

**Сложность:** `O(log n)` для обновления и запроса

### Куча (Heap)

> **Куча** — специальное бинарное дерево, где значение каждого узла больше (max-heap) или меньше (min-heap) значений его потомков

```csharp
// Min-heap в .NET
var minHeap = new PriorityQueue<int, int>();
minHeap.Enqueue(5, 5);
minHeap.Enqueue(3, 3);
minHeap.Enqueue(7, 7);
int min = minHeap.Dequeue(); // 3
```

**Применение:**

- Алгоритм Дейкстры
- Сортировка кучей (Heapsort)
- Приоритетные очереди

**Сложность:**

- Вставка: `O(log n)`
- Извлечение min/max: `O(log n)`
- Получение min/max: `O(1)`

## Способы связывания узлов

### Односвязное дерево

> **Односвязное дерево** — дерево, где узлы содержат ссылки только на потомков

```csharp
public class SingleLinkedTreeNode<T> {
    public T Value { get; set; }
    public SingleLinkedTreeNode<T> Left { get; set; }
    public SingleLinkedTreeNode<T> Right { get; set; }
}
```

**Особенности:**

- Невозможно перейти от потомка к родителю
- Меньше памяти
- Проще в реализации

### Двусвязное дерево

> **Двусвязное дерево** — дерево, где узлы содержат ссылки как на потомков, так и на родителя

```csharp
public class DoubleLinkedTreeNode<T> {
    public T Value { get; set; }
    public DoubleLinkedTreeNode<T> Left { get; set; }
    public DoubleLinkedTreeNode<T> Right { get; set; }
    public DoubleLinkedTreeNode<T> Parent { get; set; }
}
```

**Особенности:**

- Возможность движения вверх по дереву
- Упрощение некоторых операций (удаление, балансировка)
- Больше памяти на хранение

## Обходы дерева (Tree Traversal)

### Обход в глубину (Depth-First Search, DFS)

**Прямой обход (Pre-order):** корень → левое поддерево → правое поддерево

```csharp
void PreOrder(TreeNode node) {
    if (node == null) return;
    Console.Write(node.Value + " ");
    PreOrder(node.Left);
    PreOrder(node.Right);
}
```

**Центрированный обход (In-order):** левое поддерево → корень → правое поддерево

```csharp
void InOrder(TreeNode node) {
    if (node == null) return;
    InOrder(node.Left);
    Console.Write(node.Value + " ");
    InOrder(node.Right);
}
```

*Для BST дает отсортированную последовательность*

**Обратный обход (Post-order):** левое поддерево → правое поддерево → корень

```csharp
void PostOrder(TreeNode node) {
    if (node == null) return;
    PostOrder(node.Left);
    PostOrder(node.Right);
    Console.Write(node.Value + " ");
}
```

### Обход в ширину (Breadth-First Search, BFS)

> **Обход в ширину** — обход дерева по уровням, слева направо

```csharp
void LevelOrder(TreeNode root) {
    if (root == null) return;
    
    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    
    while (queue.Count > 0) {
        TreeNode node = queue.Dequeue();
        Console.Write(node.Value + " ");
        
        if (node.Left != null) queue.Enqueue(node.Left);
        if (node.Right != null) queue.Enqueue(node.Right);
    }
}
```

## Применение деревьев

- **Файловые системы** — иерархическая структура папок и файлов
- **DOM в браузерах** — представление HTML-документа
- **Базы данных** — B-деревья для индексов
- **Компиляторы** — абстрактное синтаксическое дерево (AST)
- **Искусственный интеллект** — дерево решений, игровые деревья
- **Маршрутизация** — IP-таблицы маршрутизации (Trie)
- **Автодополнение** — префиксные деревья
- **Сжатие данных** — дерево Хаффмана
- **Приоритетные очереди** — куча

#GENERATED
