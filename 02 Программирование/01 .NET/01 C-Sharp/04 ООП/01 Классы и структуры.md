
> **_Класс_ (в ООП)** — это шаблон, по которому конструируются объекты. Этот шаблон описывает структуру данных и механизмы обработки этих данных

> **_Класс_ (в C\#)** — это пользовательский ссылочный тип данных

**_Объект_** — это экземпляр шаблона (класса, структуры или интерфейса). Объекты одного шаблона отличаются друг от друга только хранимыми данными и ссылками в памяти. Механизмы управления данными у таких объектов идентичны

**_Структура_** — это упрощенная версия класса, которая более оптимизирована по памяти и быстродействию, но имеет больше ограничений

- Объекты классов **по умолчанию** располагаются в куче
- Объекты структур, в приоритете, располагаются на стеке

[[Механизмы выделения памяти|Подробно узнать об управлении памятью можно узнать здесь]]

Структуры и классы могут содержать в себе некоторые атрибуты, называемые **членами**. Все члены можно разделить на 2 типа:

- **Свойства**: содержат данные
- **Методы**: обрабатывают данные

| Член                            | Есть в class | Есть в struct | Есть в Interface |
| ------------------------------- | ------------ | ------------- | ---------------- |
| Поле (простое хранилище данных)                                                                    | да           | да            | нет              |
| Свойство (механизм доступа к хранилищу данных)                                                     | да           | да            | да               |
| Метод (операция над данными)                                                                       | да           | да            | да               |
| Конструктор (особый метод, создающий объект)                                                       | да           | да            | нет              |
| Деструктор (особый метод, выполняющийся перед удалением объекта)                                   | да           | нет           | нет              |
| Индексатор (особое свойство, определяющее механизм доступа к данным через оператор индексирования) | да           | да            | да               |
| Событие (специальный механизм событийного программирования)                                        | да           | да            | да               |
| Перегрузки операторов                                                                              | да           | да            | нет              |
| Вложенные определения типов: `class`, `struct`, `interface`, `enum`, `delegate`, `event`, `record` | да           | да            | да               |

> Во всех объектах .NET есть встроенные члены, так как все объекты наследуются от корневого типа всех типов .NET — System.Object (`object`)

#### Синтаксис класса

Полный синтаксис C#10:

```csharp
// possible modifiers: public, private, protected, internal, private protected, protected internal, file

[modifier] [abstract|sealed|static] [partial] class ClassName
{
    [<Constructors>]
        // Constructor syntax:
        [modifier] [static] ClassName([<parameters>]) [:this([<parameters>])|:base([<parameters>])]
        {
            [<Constructor body>]
        }
    
    [<Feilds>]
        //Feild syntax:
        [modifier] [static] [readonly] <Type> feildName;
    
    [<Methods>]
        //Method syntax:
        [modifier] [abstract|static|virtual|override|sealed] [ref] <ReturnType> MethodName([<parameters>])
        {
            [<Body>]
        }
    
    [<Properties>]
        //Property syntax:
        [modifier] [abstract|static|virtual|override|sealed] [ref] <ReturnType> PropertyName
        {
            [ [modifier] get [=> <expression>] | [ { <Body> } ] ]
            [ [modifier] set|init [=> <Body>] | [ { <Body> } ] ]
        }
    
    [<Operators>]
    
    [<Events>]
        //Event syntax:
        [modifier] event <DelegateType> EventName [{ add; remove; }] // по аналогии со свойствами
        
    [<InnerTypes>]
        //объявление вложенного типа: class, struct, delegate, interface...
}
```

```csharp
public class Person
{
    private int _phoneNumber;
    
    public string FirstName { get; set; }
    public string LastName { get; set; }
    
    public void Introduce()
    {
        Console.WriteLine($"Hello, my name is {FirstName} {LastName}.");
    }
}

// Простейший класс без пользовательских членов
public class MyClass;
```

Структуры:

```cs
possible modifiers: public, private, protected, internal, private protected, protected internal, file

[modifier] [readonly|partial] [ref] struct StructName
{
    [<Constructors>]
        // Constructor syntax:
        [modifier] StructName([<parameters>])
        {
            [<Constructor body>]
        }
    
    [<Fields>]
        // Field syntax:
        [modifier] [static] [readonly] <Type> fieldName;
    
    [<Methods>]
        // Method syntax:
        [modifier] [static] [readonly] <ReturnType> MethodName([<parameters>])
        {
            [<Body>]
        }
    
    [<Properties>]
        // Property syntax:
        [modifier] [static] <ReturnType> PropertyName
        {
            [ [modifier] get [=> <expression>] | [ { <Body> } ] ]
            [ [modifier] set|init [=> <Body>] | [ { <Body> } ] ]
        }
    
    [<Operators>]
        // Operator syntax analogous to class operators (e.g. public static operator +)
    
    [<Events>]
        // Event syntax:
        [modifier] event <DelegateType> EventName [{ add; remove; }]
    
    [<InnerTypes>]
        // Nested types declaration: class, struct, delegate, interface...
}
```

```csharp
public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
    
    public void Display()
    {
        Console.WriteLine($"Point position ({X}, {Y})");
    }
}
```

> Структуры и классы можно объявить как неизменяемый набор свойств. Для этого используются [[15 Записи (Records)|Записи (Records]]

## Модификаторы доступа

Для разграничения логики и создания строгой и надежной программной системы применяются модификаторы доступа. Они могут применяться почти ко всем сущностям:

* Класс
* Структура
* Поле
* Свойство
* Метод
* Метод доступа (аксессор: геттер и сеттер)
* Любой вложенный тип
* Событие
* Индексатор

| Модификатор доступа  | Описание  |
| -------------------- | ----------------------------------------- |
| `public`             | Доступность из любого места в коде        |
| `internal`           | Доступность внутри текущей сборки (проекта)|
| `protected`          | Доступность внутри типа и его производных типов|
| `private`            | Доступность только внутри определяемого типа   |
| `protected internal` | Доступность внутри текущей сборки и в производных типах. Производные типы из других сборок **могут** получить доступ к этому члену |
| `private protected`  | Доступность внутри типа и его производных типов, но только в пределах текущей сборки. Производные типы из других сборок **не могут** получить доступ к этому члену. |
| `file`               | Доступность в рамках текущего файла с кодом          |

Применяемость модификаторов доступа:
class, struct, interface, field, property (get, set тоже), operator

| Модификатор доступа  | class | struct         | interface | delegate | field | property | get | set | operator |
| -------------------- | ----- | -------------- | --------- | -------- | ----- | -------- | --- | --- | -------- |
| `public`             | `+`   | `+`            | `+`       | `+`      | `+`   | `+`      | `+` | `+` | `+`      |
| `internal`           | `+`   | `+`            | `+`       | `+`      | `+`   | `+`      | `+` | `+` | `-`      |
| `protected`          | `+`   | `+` (как поле) | `+`       | `-`      | `+`   | `+`      | `+` | `+` | `-`      |
| `private`            | `+`   | `+`            | `+`       | `+`      | `+`   | `+`      | `+` | `+` | `-`      |
| `protected internal` | `+`   | `+`            | `+`       | `-`      | `+`   | `+`      | `+` | `+` | `-`      |
| `private protected`  | `+`   | `+`            | `+`       | `-`      | `+`   | `+`      | `+` | `+` | `-`      |
| `file`               | `+`   | `+`            | `+`       | `+`      | `+`   | `+`      | `+` | `+` | `-`      |

> Типы, определенные напрямую в пространстве имен и не являющиеся вложенными в другие типы, могут иметь модификаторы доступа только `public` или `internal`

### Оператор this

Представляет собой ссылку на текущий объект, используется внутри определения класса

```csharp
this.field1 = 2002;
```

## Объекты первого класса

Объект называют **"объектом первого класса"**, если он:

- может быть сохранен в переменной или структурах данных;
- может быть передан в функцию как аргумент;
- может быть возвращен из функции как результат;
- может быть создан во время выполнения программы;
- внутренне самоопознаваем (независим от именования).

Термин **"объект"** используется здесь в общем смысле и не ограничивается объектами языка программирования. Так, значения простейших типов данных, например, integer и float, во многих языках являются «объектами первого класса»

Это понятие было предложено в 1967 году Кристофером Стрэчи

**Пример.** В C и C++ нельзя создавать функции во время выполнения программы, поэтому функции не являются объектами первого класса в этих языках

Далее: [[02 Конструкторы объектов|Конструкторы]]

#C-Sharp #OOP #Memory
