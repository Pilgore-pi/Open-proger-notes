Назад: [[03 Условия и циклы]]

## Ввод-вывод

```scala
print(value)    // вывод без перевода строки
println(value)  // вывод с переводом строки
```

Чтение с консоли:

```scala
val res = scala.io.StdIn.readLine()    // чтение строки
val ch = scala.io.StdIn.readChar()     // чтение символа
val d = scala.io.StdIn.readDouble()    // чтение Double
// Аналогичные методы для Int, Float, Long и т.д.
```

## Рандом

```scala
val rand = new scala.util.Random

// Получение случайных чисел
rand.nextInt()       // любое целое число
rand.nextInt(10)     // от 0 до 9 (исключая 10)
rand.nextLong()
rand.nextFloat()
rand.nextDouble()

// Диапазон с методом between
rand.between(start, end)  // [start, end)
```

## Коллекции

### Массивы

> Все коллекции реализуют интерфейс `Iterable`

```scala
val res = Array(5, -2, 0)

println(res(1))    // -2
res(1) = -20       // изменение значения по индексу
println(res(1))    // -20
```

Создание массива заранее заданного размера:

```scala
val d = new Array[Double](8)
for x <- d do {
	println(x) //8 нулей (0.0)
}

// С нотацией типа:
a1: Array[Int] = Array(1, 2, 3)
```

> Обращение по индексу, на самом деле, — это вызов метода **apply**

```scala
a(1)            // получение элемента
a.update(1, 5)  // изменение элемента (тоже по индексу)
```

Основные методы массивов и коллекций:

```scala
a.length          // длина массива
a.size            // длина любой коллекции
a.reverse         // повернутая последовательность
a.clone           // копия массива
a.contains(x)     // проверка элемента
a.count(p)        // количество элементов по условию p
a.appendedAll(a2) // добавление массива, возвращает новый массив
a.copyToArray(a2) // копирование в другой массив
a.map(x => x * 3) // преобразование каждого элемента
a.distinctBy(f)   // уникализация по функции
a.filter(p)       // фильтрация коллекции по условию
a.foreach(f)      // выполнение побочных действий для каждого элемента
a.flatMap(f)      // преобразование и "сплющивание" коллекций внутри
a.min, a.max, a.sum, a.sorted  // статистика и сортировка
```

Преобразования:

```scala
a.toList
a.toMap
a.toArray
a.toSet
```

### Связные списки

> Элементы списка неизменяемы

```scala
val fruit1: List[String] = List("apples", "oranges", "pears")

val fruit2 = List("apples", "oranges", "pears")

val dim: List[List[Int]] =
   List(
      List(1, 0, 0),
      List(0, 1, 0),
      List(0, 0, 1)
   )
```

Примеры работы со списком:

```scala
val myList = List(1,2,3)
println(0 :: myList) // List(0, 1, 2, 3) - добавление в начало (prepend)
```

> **`Nil`** — пустой список, наследник `List`

```scala
b.head    // первый элемент
b.tail    // все элементы, кроме первого
b.isEmpty
```

Создание списков с элементами:

```scala
List.fill(size)(element) // генерирует список size элементов, равных element

// Пример:
List.fill(3)("hello")  // List("hello", "hello", "hello")
```

Перебор элементов:

```scala
b.foreach(println)  // вывод всех элементов

var mult = 1
val myList = List(10, 20, 30)

myList.foreach(x => mult *= x)  // умножение всех элементов

// Сокращенная запись
myList.foreach(mult *= _)
```

### Set

`Set` — это множество, коллекция уникальных элементов. При попытке добавления в множество значения, которое уже существует, это значение добавлено не будет и ошибки не возникнет

```scala
val set = Set(1,2,3)
val set2 = set + 4  // Set(1, 2, 3, 4)
val set3 = set2 - 1 // Set(2, 3, 4)
```

### Map (словарь)

`Map` — коллекция пар (ключ, значение)

Инициализация несколькими кортежами:

```scala
val map = Map(
"key1" -> "value1",
"key2" -> "value2"
)
```

Можно получать значение по ключу:

```scala
map("key1")   // "value1"
```

Можно добавлять ключ-значение:

```scala
val newMap = map + ("key3" -> "value3")
```

Далее: [[05 Классы]]

#Scala