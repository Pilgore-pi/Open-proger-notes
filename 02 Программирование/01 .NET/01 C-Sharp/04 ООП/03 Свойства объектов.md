
Назад: [[02 Конструкторы объектов|Конструкторы объектов]]
Далее: [[03.5 Ключевое слово readonly|Ключевое слово readonly]]

Свойства в C# позволяют управлять доступом к полям класса, предоставляя механизм для чтения и записи значений. Они выглядят как поля, но, на самом деле, одно свойство — это пара методов: `get` и `set`, которые позволяют контролировать доступ к данным

> Свойство состоит из метода доступа **`get`** и метода изменения **`set`**. Эти методы называются **аксессорами**

Для каждого свойства **всегда** определяется соответствующее поле (в единственном числе). Поле может определяться явно или скрыто компилятором

- **Имя свойства** — должно быть осмысленным и обычно пишется с заглавной буквы.
- **Тип свойства** — определяет тип данных, которые свойство может хранить.
- **Геттер (get)** — метод, который возвращает значение свойства
- **Сеттер (set)** — метод, который устанавливает значение свойства

Синтаксис полного свойства

```csharp
private <return_type> my_field;
public <return_type> MyProperty {
    get { return my_field; }
    set { my_field = value; }
}

public <return_type> MyProperty {
    get => my_field;
    set => my_field = value;
}
```

> **Контекстное ключевое слово `value`** представляет собой входной (`in`) параметр того же типа, что и тип свойства

```csharp
internal class Employee {
    
    // "backing-field" — "фоновое" поле для свойства PhoneNumber
    private string _phoneNumber;
    
    // Свойство "Номер телефона"
    public string PhoneNumber {
        get => _phoneNumber;
        set {
            bool matches = SimplePhoneNumberRegex().IsMatch(value);
            if (matches is false) throw new ArgumentException($"Phone number \"{value}\" doesn't match the regular expression");
            
            _phoneNumber = value;
        }
    }
    
    // Свойство "Полное имя"
    public string FullName { get; set; }
}
```

> Вызов метода `get` происходит при получении значения свойства или передаче свойства в метод

> Вызов метода `set` происходит при использовании оператора `=`, где левым операндом является свойство, а правым — совместимый по типу объект

```csharp
var emp = new Employee();

// Вызов аксессора set у свойства FullName
emp.FullName = "Anna Javana";

// Вызов аксессора set у свойства PhoneNumber
emp.PhoneNumber = "89008004545";

// Вызов аксессора get у свойства PhoneNumber
var number = emp.PhoneNumber;

// Вызов аксессора get у свойства emp.FullName
Console.WriteLine($"Employee. name: {emp.FullName}; phone: {number}");
```

## Модификаторы доступа для аксессоров

1) Модификатор может применятся только для одного из аксессоров
2) Модификатор аксессора должен быть **более ограничивающим**, чем модификатор доступа свойства

Свойство может не иметь один из аксессоров

## Автоматические свойства

C# позволяет создавать свойства без явного объявления полей. Компилятор автоматически создает скрытое поле для хранения значения

```csharp
public class Person {
    public string Name { get; set; } // автоматическое свойство
}
```

**Один** из аксессоров (геттер или сеттер) может отсутствовать, соответственно свойство будет *read only* (только для чтения) или *write only* (только для записи)

К аксессорам можно применять различные модификаторы доступа, например, можно сделать какое-то свойство только для чтения снаружи класса, а внутри сам определяющий класс имеет полный доступ (`public int Property { get; private set; }`)

```csharp
public int Age {
    get => age; // сокращенный синтаксис
    set {
        if (value < 0)
            throw new ArgumentException("Age cannot be negative");
        age = value;
    }
}
```

```csharp
public class Person {
    private string name;
    
    public string Name {
        get => name;
        set => name = value; // контекстное ключевое слово
    }
}
```

`value` — это значение, которое было помещено в свойство при присваивании

## Инициализаторы объектов

C# позволяет инициализировать свойства при создании объекта

```csharp
public class Person {
    public string Name { get; set; }
    public int Age { get; set; }
}

var person = new Person { Name = "John", Age = 30 };
```

Можно задавать значения по умолчанию:

```csharp
public class Person {
    public string Name { get; set; } = "Unknown";
}
```

## Свойства, инициализируемые один раз

Начиная с версии C# 9.0, стал доступен тип аксессора `init` — разновидность сеттера. Свойства с этим аксессором могут быть инициализированы только при создании объекта

```csharp
public class Person {
    public string Name { get; init; }
}

var person = new Person { Name = "Dude" };
person.Name = "Dawg"; // Ошибка компиляции
```

Свойства инициализируемые один раз называются "init-only" свойствами

Далее: %%ссылка на след. заметку%%

Ниже описываются внутренние механизмы свойств, понимание которых улучшит представление о том, что из себя представляют свойства

## Внутренние механизмы компиляции свойств

### Генерация имен

При компиляции свойства C# аксессоры get и set преобразуются в методы с именами, которые формируются следующим образом:

- Для аксессора get метод будет иметь имя: `get_<ИмяСвойства>`

- Для аксессора set метод будет иметь имя: `set_<ИмяСвойства>`

Например, если есть свойство

```csharp
public class TestClass {
    
    private int _fullProperty;
    
    public int FullProperty {
        get => _fullProperty;
        set => _fullProperty = value;
    }
}
```

Для этого свойства компилятор создаст два метода:

- `int get_FullProperty()`
- `void set_FullProperty(int value)`

Эти методы являются скрытыми и используются при обращении к свойству напрямую в IL-коде и во время выполнения

У автосвойств есть скрытые поля, для которых, также, генерируется имя

```csharp
public int AutoProperty { get; set; }
```

Сгенерированное поле:

```csharp
private int <AutoProperty>k__BackingField;
```

Вот, во что разворачивается автосвойство `AutoProperty`:

```csharp
[CompilerGenerated]
[DebuggerBrowsable(DebuggerBrowsableState.Never)]
private int <AutoProperty>k__BackingField;

public int AutoProperty{
    [CompilerGenerated]
    get
    {
        return <AutoProperty>k__BackingField;
    }
    [CompilerGenerated]
    set
    {
        <AutoProperty>k__BackingField = value;
    }
}
```

### IL-код свойств

#Dotnet/CIL

Получить IL-код можно с помощью сервиса [SharpLab](https://sharplab.io/)

Код C#, определяющий полное свойство (приведенное выше) `int FullProperty`, конвертируется в CIL (Common Intermediate Language):

```il
.class public auto ansi beforefieldinit TestClass
    extends [System.Runtime]System.Object
{
    // Поля
    .field private int32 _fullProperty
    
    // Методы
    .method public hidebysig specialname 
        instance int32 get_FullProperty () cil managed 
    {
        // Метод начинается на RVA 0x2050
        // Размер кода 7 (0x7)
        .maxstack 8
    
        IL_0000: ldarg.0
        IL_0001: ldfld int32 TestClass::_fullProperty
        IL_0006: ret
    } // конец метода TestClass::get_FullProperty
    
    .method public hidebysig specialname 
        instance void set_FullProperty (
            int32 'value'
        ) cil managed 
    {
        // Метод начинается на RVA 0x2058
        // Размер кода 8 (0x8)
        .maxstack 8
    
        IL_0000: ldarg.0
        IL_0001: ldarg.1
        IL_0002: stfld int32 TestClass::_fullProperty
        IL_0007: ret
    } // конец метода TestClass::set_FullProperty

    // Стандартный конструктор
    .method public hidebysig specialname rtspecialname 
        instance void .ctor () cil managed 
    {
        // Метод начинается на RVA 0x2061
        // Размер кода 7 (0x7)
        .maxstack 8
    
        IL_0000: ldarg.0
        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
        IL_0006: ret
    } // конец метода TestClass::.ctor
    
    // Свойства
    .property instance int32 FullProperty()
    {
        .get instance int32 TestClass::get_FullProperty()
        .set instance void TestClass::set_FullProperty(int32)
    }
} // конец класса TestClass
```

### Инициализация get-only свойства

Значения свойства без аксессора `set` можно менять, только обращаясь к фоновому полю напрямую.
Если речь идет об автосвойствах, то инициализировать их можно один раз в конструкторе. При этом неявно идет обращение к фоновому полю, а не к несуществующему методу `set`

```csharp
public class TestClass {
    
    public TestClass() {
        //<AutoProperty>k__backingField = 13;
        AutoProperty = 13; // Нет ошибки
    }
    
    public int AutoProperty { get; }
}
```

```csharp
public class TestClass {
    
    public TestClass() {
        FullProperty = 13; // Ошибка компиляции
    }
    
    private int _fullProperty;

    public int FullProperty {
        get => _fullProperty;
    }
}
```

Далее: [[03.5 Ключевое слово readonly|Ключевое слово readonly]]

#C-Sharp #OOP
