
По умолчанию, объекты ссылочных типов сравниваются по ссылкам, то есть сравнение проверяет, указывают ли две переменные на один и тот же объект в памяти

Для сравнения по значению можно переопределить метод `Equals()` или использовать интерфейсы сравнения

C# предлагает разные подходы к сравнению: метод Equals, операторы == и !=, интерфейсы IComparable и IComparer.

## Интерфейсы IComparable и IComparable\<T\>

Метод `CompareTo()`: Сравнивает текущий экземпляр с другим объектом того же типа и возвращает целое число, которое показывает, расположен ли текущий экземпляр перед, после или на той же позиции в порядке сортировки, что и другой объект (из оф. доков)

### IComparable

Интерфейс `IComparable` используется для реализации естественного порядка сравнения объектов одного типа, он определяет метод `CompareTo()`

Интерфейс `IComparable` содержит единственный метод `int CompareTo(object obj)`

Метод `CompareTo()` сравнивает текущий объект с другим объектом того же типа, возвращая целое число:

- Отрицательное число, если текущий объект меньше

- Ноль, если объекты равны

- Положительное число, если текущий объект больше

Используется для сортировки и упорядочивания объектов по естественному порядку

### IComparable\<T\>

Это обобщенная версия интерфейса, которая принимает параметр типа `T`, что позволяет избежать ненужных операций приведения типа

Метод `int CompareTo(T other)` сравнивает текущий объект с другим объектом типа `T`

Обеспечивает типобезопасное сравнение и повышает производительность за счет отсутствия приведения типов

Рекомендуется применять вместо не обобщенного `IComparable`, когда известен конкретный тип объектов для сравнения

Эти интерфейсы широко используются для реализации сортировки коллекций и других операций, требующих сравнения объектов. `IComparable` задает естественный порядок, а `IComparable<T>` упрощает и типизирует реализацию этого порядка

Таким образом, для реализации сравнения объектов в C# рекомендуется использовать обобщенный интерфейс `IComparable<T>`, если это возможно, для обеспечения типобезопасности и удобства использования. `IComparable` остается совместимым вариантом для работы с не generic-коллекциями и объектами общего типа

## Переопределение `object.Equals()`

Переопределение Equals()
Метод Equals() определён в базовом классе Object и по умолчанию сравнивает объекты по ссылкам, т.е. равны только если указывают на один и тот же объект.

При переопределении Equals() нужно реализовать логику сравнения по содержимому объектов, обычно сравнивая значения ключевых полей.

Существует важный контракт: если два объекта равны по Equals, они должны возвращать одинаковый хэш-код в методе GetHashCode().

Переопределённый Equals должен быть рефлексивным (obj.Equals(obj) == true), симметричным, транзитивным и стабильно возвращать один результат, пока объект не изменяется.

Также надо корректно обработать сравнение с null и объектами другого типа, обычно возвращая false

### Переопределение операторов `==` и `!=`

Операторы `==` и `!=` в C# по умолчанию сравнивают ссылки для ссылочных типов

Чтобы сравнение по содержимому работало с операторами `==` и `!=`, их нужно явно переопределить

Логика операторов должна быть согласована с методом `Equals()`, чтобы поведение сравнения было единообразным

Обычно перегружается оператор `==` для вызова переопределённого `Equals`, а оператор `!=` — для возвращения противоположного результата

### Рекомендации

- При переопределении `Equals()` всегда следует переопределять `GetHashCode()`, чтобы объекты корректно работали в хэш-структурах (например, словарях)

- При перегрузке операторов равенства следует также переопределить `Equals()`

#MERGE_NOTES
