Назад: [[04 Ввод, рандом, коллекции]]

## Классы

Для членов по умолчанию модификатор **public**, но ключевого слова "`public`" не существует. Есть `private[this]`, `private`,  `protected`

`private[this]` — доступ только через `this.`. Дополнительные параметры для модификаторов доступа `protected` тоже существуют\*

```scala
class Animal
val anAnimal = new Animal
```

```scala
class Animal{
	val age: Int = 0
	def eat() = println("eating")
}

// конструктор (параметры НЕ РАВНО поля)
// это неявные val поля
class Dog(name: String) extends Animal
```

Параметры, передаваемые в конструкторе видны на уровне класса

```scala
// теперь name — поле
class Dog(val name: String) extends Animal

// обязательно указывать конструктор,
// если нет конструктора без параметров
class A extends B(i, j)

val dog = new Dog("Bally")
val name = dog.name;
```

Дополнения — конструкторы, поля и var/val:
- Параметры конструктора по умолчанию — не поля. Чтобы сделать поле — добавь `val` (или `var`, если нужно изменяемое поле).
- `var` создаёт изменяемое поле с геттером и сеттером; `val` — только геттер.
- Можно указывать параметры по умолчанию и перегружать конструктор через auxiliary constructors (см. ниже).

Примеры:

```scala
class Cat(val name: String, var age: Int = 0) {
  def this(name: String) = this(name, 0) // вспомогательный конструктор
}
```

Основной и вспомогательный конструкторы:

- Основной конструктор — это сигнатура класса (параметры после имени класса).
- Вспомогательные конструкторы объявляются как `def this(...) = { ... }` и обязаны в итоге вызывать предыдущий конструктор.

Наследование, `overriding`, `final`:

- По умолчанию методы виртуальные (можно переопределять).
- Чтобы переопределить метод, используйте `override`.
- Запретить наследование класса — ключевое слово `final class`.
- Запретить переопределение метода/поле — `final def` / `final val`.

Метод ***apply*** является особенным. Он фактически представляет собой конструктор, к которому можно обратиться как конструктору, а можно явно **`.apply`**

```scala
def apply(x: Int): Int = x + 1

MySingleton.apply(65)
MySingleton(65) // эквивалентно MySingleton.apply(65)
```


## Интерфейсы

Интерфейсы классов в Scala называются "чертами". Черты класса могут иметь реализацию:

```scala
trait Yellable{
	def yell(sound: String): Unit
}
trait Movable{
	def move(): Unit
}

class elephant extends Animal with Yellable with Movable{
	override def yell(sound: String): Unit = print("Hoo")
	override def move():Unit = ()
}
```

Инфиксная нотация: `object method argument` (только один параметр)

```scala
class Human{
	def ?(question: String): Unit = println(question)
}

val human = new Human
human ? "Who am I?"
```

```scala
val basicMath = 1 + 2
val anotherBasicMath = 1.+(2) // эквивалент
```

## Анонимные классы (как в Java)

Анонимный класс, реализующий черту `Movable`:

```scala
val snake = new Movable{
	override move(): Unit = println("I'm moving!")
}
```

## Объекты

Объекты — это как статические классы

```scala
object Animal { }
```

Если определен класс "`Animal`" и объект "`Animal`", то эти класс и объект имеют доступ к приватным членам друг друга

В таком случае `object Animal` будет называться **классом-компаньоном**

## Case-classes

Это классы, для которых неявно определены классы-компаньоны с методом `apply`, который возвращает экземпляр обычного класса

```scala
case class Person(name: String, age: Int)

val bullyMaguire = Person(name: "Bully", age: 166)
//Person.apply(name: "Bully", age: 30)
```

Далее: [[06 Обобщения]]

#Scala