Классы в JS являются синтаксическим сахаром. Фактически они реализованы на основе функций

Как существует **`Function declaration & Function expression`**, так существует **`Class declaration & Class expression`**

Синтаксис классов поддерживается только в последних версиях JavaScript, поэтому может возникнуть несовместимость при использовании разных версий

```js
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    // Методы:
    countSquare = () => height * width;
    // ИЛИ
    countSquare(){ return height * width; }
    static countSquare(){ return height * width; }
    
    // Публичные поля
    field1 = 'text'
    static field2 = 'txt'
    
    // Приватные поля
    #_privateField = 2
    
    // Аксессоры
    get property() { return 'p'; }
    set property(value) { field1 = value; }
}
```

> Классы нельзя использовать до их объявления

> Классы могут содержать **ОДИН** конструктор, методы, свойства и аксессоры.

Публичные и приватные поля — новая функция, поддерживаемая не всеми браузерами.

> Доступ к несуществующим свойствам класа осуществляется также как и в случае классических объектов, то есть можно обращаться к несуществующим членам

Класс-выражение:

```js
// Безымянный
// Rectangle.name == 'Rectangle'
let Rectangle = class {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};

// Именованный
// square.name == Rectangle
let square = class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};
```

> Все свойства класса должны быть определены внутри его методов

## Наследование классов

```js
class Dog extends Animal {
// вызывает конструктор super класса и передаёт параметр name
    constructor(name) {
        super(name);
    }
};
```

> Если в подклассе присутствует конструктор, он должен сначала вызвать `super`, прежде чем использовать `this`.

> Ссылку `super` внутри класса можно использовать также как и `this`

> Классы нельзя переопределять (вторично объявлять)

Далее: [[11 Прототипное наследование|Прототипное наследование]]

#JavaScript
