
> **Паттерн Стратегия** — это поведенченский паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы

> Паттерн стратегия построен на типе связи **композиция**

Решим проблему. Пусть у нас имеется 3 различных алгоритма выполнения одного и того же действия. Необходимо реализовать логику обработки такого поведения наиболее рациональным 

### Простой подход

Можно определить всю логику в единственном методе и передавать параметр, который будет определять, какой алгоритм нужно в данном случае выполнить 

```csharp
enum MovementKind {
    Walk,
    Drive,
    Scooter
}

static void StartMovement(MovementKind movement){
    switch(movement){
        case MovementKind.Walk:    Console.WriteLine("Walking"); break;
        case MovementKind.Drive:   Console.WriteLine("Driving"); break;
        default:                   Console.WriteLine("On scooter"); break;
    }
}
```

**Преимущества:**

- Краткость кода

**Недостатки:**

- Отсутствующая гибкость, нарушение **принципа открытости-закрытости**. При добавлении нового типа передвижения, нужно будет добавлять новое поле перечисления и редактировать метод `StartMovement()`, добавляя новую ветку логики

### Разделение логики в семействе класса

Рассмотрим пример структуру программы, основанную на **наследовании** и **полиморфизме**

```csharp
// Человек, который может передвигаться
interface IHuman {
    void Move();
}

class WalkHuman : IHuman {
    public override Move() { /*Передвижение пешком*/ }
}

class DriveHuman : IHuman {
    public override Move() { /*Передвижение на машине*/ }
}

class ScooterHuman : IHuman {
    public override Move() { /*Передвижение на самокате*/ }
}

// Полиморфный вызов метода Move()
static void StartMovement(IHuman human) => human.Move();

IHuman human = new DriveHuman();
StartMovement(human);
human = new ScooterHuman();
StartMovement(human);
StartMovement(new WalkHuman());

```

**Преимущества:**

- Большая гибкость

**Недостатки:**

- Усложнение кода

### Разделение алгоритмов на стратегии в ООП стиле

```csharp

```

### Разделение алгоритмов на стратегии в смешанном стиле

```csharp

```

### Разделение алгоритмов на стратегии в функциональном стиле

```csharp

```

#Patterns