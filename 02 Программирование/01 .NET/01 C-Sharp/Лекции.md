Когда время жизни функции превосходит время жизни отдельных переменных, используемых внутри этой функции, то такие переменные захватываются функцией в специальный контекст. Этот механизм называется захват переменной или замыкание. Поэтому в любом ЯП с наличием функциональых типов содержится не только ссылки на функции, но и специальный контекст.

```cs
Обобщенный делегат Func<R>       R Func();

Func<T,R>       R Func(T t)

Func<T1, … , Tn, R>    R Func(T1 t1, … Tn tn)

Action                 void Action()

Action<T>              void Action(T t)
```

# Конструкторы

В C# есть деструкторы. В подавляющем большинстве случаев они не используются.

Все конструкторы неявно вызывают метод Initialize. То есть фактически конструкторы – это инициализаторы, деструкторы – финализаторы.

Если в классе не описан ни одни конструктор, то компилятор C# (не .Net) создает конструктор по умолчанию без параметров.

Если описан хотя бы один конструктор, то компилятор больше не вмешивается.

```cs
class Point {

public Point(double x, double y) => ...
    
    ...
    
}

var p = new Point (5, -3);
```
Если единственный конструктор приватный, то объект создать нельзя.

Статический конструктор

```cs
class Point {

static Point(){...} //без модификаторов
    
}
```

Нужен для инициализации статических членов класса.

Статический конструктор вызывается автоматически средой .Net, при этом неизвестно когда. Но система гарантирует, что инициализация произойдет до обращения к статическим полям/свойствам.

#C-Sharp #Functions/Delegates