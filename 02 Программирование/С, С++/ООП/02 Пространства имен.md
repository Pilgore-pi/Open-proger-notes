
> **Пространство имен** — это область, в которой определяются имена для типов данных, функций и переменных. В рамках одного пространства имен все идентификаторы должны быть уникальны

Пространство имен предназначено для организации кода и разрешения конфликтов имен

- Пространства имен могут быть вложенными

[Официальная документация](https://learn.microsoft.com/en-us/cpp/cpp/namespaces-cpp?view=msvc-170)

```cpp
namespace ContosoData
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}
```

## Обращение к идентификаторам из другого пространства имен

Есть 3 способа:

1) Каждый раз указывать полный идентификатор с указанием пространства имен: `myNameSpace::MyIdentifier`

```cpp
ContosoData::ObjectManager mgr;
mgr.DoSomething();
ContosoData::Func(mgr);
```

2) Добавление одного идентификатора из другого пространства имен

```cpp
using ContosoData::ObjectManager;

ObjectManager mgr;
mgr.DoSomething();
```

3) Добавление пространство имен целиком, что позволяет не указывать префиксом имя пространства имен

```cpp
using namespace ContosoData;

ObjectManager mgr;
mgr.DoSomething();
Func(mgr);
```

## Вложенные пространства имен

```cpp
namespace ContosoDataServer
{
    void Foo();

    namespace Details
    {
        int CountImpl;
        void Ban() { return Foo(); }
    }

    int Bar(){...};
    int Baz(int i) { return Details::CountImpl; }
}
```

Обращение к идентификатору вложенного пространства имен:

```cpp
NS1::NS1_2::Identifier
```

## Глобальное пространство имен

Если какие-то идентификаторы были объявлены вне какого-либо пространства имен, то они помещаются в глобальное пространство имен. Чтобы явно обратиться к глобальному пространству имен нужно использовать следующий синтаксис:

```cpp
::SomeFunction(x);
```

## Пространство имен std

Стандартные типы данных и функции находятся в пространстве имен `std`

## Встраиваемые пространства имен

In contrast to an ordinary nested namespace, members of an inline namespace are treated as members of the parent namespace. This characteristic enables argument dependent lookup on overloaded functions to work on functions that have overloads in a parent and a nested inline namespace. It also enables you to declare a specialization in a parent namespace for a template that is declared in the inline namespace. The following example shows how external code binds to the inline namespace by default:

```cpp
// Header.h
#include <string>

namespace Test
{
    namespace old_ns
    {
        std::string Func() { return std::string("Hello from old"); }
    }

    inline namespace new_ns
    {
        std::string Func() { return std::string("Hello from new"); }
    }
}

// main.cpp
#include "header.h"
#include <string>
#include <iostream>

int main()
{
    using namespace Test;
    using namespace std;

    string s = Func();
    std::cout << s << std::endl; // "Hello from new"
    return 0;
}
```

## Анонимные пространства имен

Можно объявить явное пространство имен без указания имени. Такое пространство имен используется для ограничения области видимости кода, чтобы другой код не имел доступа к объектам анонимного пространства имен

```cpp
namespace
{
    int MyFunc(){}
}
```

## Псевдонимы пространств имен

Имена пространств имен должны быть уникальны, поэтому им могут даваться длинные имена, которые трудно воспринимаются. Можно объявлять псевдонимы для пространств имен:

```cpp
namespace a_very_long_namespace_name { class Foo {}; }

namespace AVLNN = a_very_long_namespace_name;

void Bar(AVLNN::Foo foo){ }
```

#C-Plus-Plus
