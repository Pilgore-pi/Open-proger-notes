# ComponentScript

>Интерактивный граф для визуального программирования. Добавить палитру команд (открыть приложение)
>Приложение должно быть в двух экземплярах: Как интегрируемая библиотека с элементом управления `ManagementGraph`, и как полноценное приложение

>Спросить у Perplexity, есть ли аналоги такого приложения

Создать портативный программный модуль (библиотека AvaloniaUI), позволяющий создавать графы (с физикой как в Obsidian). Граф должен быть кастомизируемым с возможностью выбора оформления для конкретной вершины, для типа вершин или для отдельных компонент связности.

Зачем?

Эта библиотека представляет собой настраиваемый интерфейс взаимодействия с программами. Каждому узлу можно задать скрипт или действие. Через рефлексию можно загружать код в "узлы". В целом можно использоваь этот граф во многих приложениях и задавать различные действия.

Если я решу загружать скрипты в узлы, то можно добавить разные языки:

* `C#`
* `Python`
* `Batch`
* `PowerShell`
* `Bash`
* `VBS`
* ``

Добавить возмножность сохранять граф как SVG
Добавить возможность создавать надписи с заданным фоном, бордером, шрифтом, размером...

### Типы узлов

* Обычный:
  * Скртипты C#, Python, Batch, PowerShell
  * Запросы
  * Команда из палитры (завершение работы, запуск приложения)
  * Независимый (bool) Узел может быть выполнен как отдельная компонента связности
  * Комбинация клавиш (только если Независимый = true) — ассоциировать активизацию узла с комбинацией клавиш
* Событие. Выбор из списка:
  * Кастомное событие C#
  * `<Список событий Windows>`: ПриЗапускеПриложения(путь), КогдаВремя(часы, минуты, `[секунды]`)
  * События, связанные с данными HTTP-запроса
* 

Структура узла (`ManagementNode`):

```csharp
public bool SystemError; // global info about error status

public sealed class ManagementNode
{
    public enum NodeContentType
    {
        ScriptCS,
        ScriptPython,
        ScriptBatch,
        ScriptPowerShell,
        HttpRequest,
        TcpRequest,
        BuiltInCommand // контент узла - число, преобразуемое в перечисление BuiltInCommand
    }
    
    // Предопределенные команды, по возможности, парсить в исходный код,
    // а затем транслировать этот код
    private enum CommandType
    {
        
    }
    
    public void Execute()
    {
        try
        {
            ContentType switch
            {
                case ContentType.ScriptCS => TranslateCS(Content),
                case ContentType.ScriptPython => TranslatePython(Content),
                case ContentType.ScriptBatch => TranslateBatch(Content),
                case ContentType.ScriptPowerShell => TranslatePowerShell(Content),
                case ContentType.HttpRequest => SendHttpRequest(Content),
                case ContentType.TcpRequest => SendTcpRequest(Content),
                case ContentType.BuiltInCommand => ExecuteCommand(int.Parse(Content)),
            }
        }
        catch(Exception ex)
        {
            ErrorMessage = ex.Message;
            SystemError = true;
        }
    }
    
    // Формирование Portable приложения для текущей компоненты
    public Result CompileToPortableExeFile(enum CPUArchitecture);
    
    public void IEnumerable<idk>? CommandParameters { get; set; }
    
    private void ExecuteCommand(int commandId)
    {
        try
        {
            NodeContentType command = //parse id to enumeration
            command switch
            {
                case CommandType.ShutdownComputer => ShutdownComputer(),
                case CommandType.OpenFileWithDefaultApp => OpenFileWithDefaultApp(),
                case CommandType.OpenCalc => OpenCalc(),
            }
        }
        catch(Exception ex)
        {
            ErrorMessage = ex.Message;
            SystemError = true;
        }
    }
    
    public IEnumerable<T> InputParameters? { get; set; }
    public IEnumerable<T> OutputParameters? { get; private set; }
    
    private static List<int> allNodesId { get; set; }
    
    // обход дерева с поиском узла с этим именем
    private static ManagementNode GetNodeById(int id);
    
    public static int this[int id]
    {
        public get => GetNodeById(id);
        private set => GetNodeById(id) = value;
    }
    
    public int ID { get; (set-> контроль уникальности + событие NameChanged)};
    public string Label { get; set; } // по умолчанию = "Узел " + ID
    // Check content with Regex (C#, HTTP request, number, ...)
    public string? Content { get; set...; } // check with regex when set and try to guess content type
    public NodeContentType ContentType { get; set; }
    
    public bool IsEnabled = true;
    
    // Было ли вызвано исключение при последнем выполнении
    public bool HasError => ErrorMessage is null;
    public string? ErrorMessage { get; private set; }
    
    // name and go to condition
    public Dictionary<int, Predicate> Children { get; set; }
}

```

Компоненты связности `Claster`. Могут быть вложенными, реализуют интерфейс `IMenagementNode`

```csharp
// Connected component
public sealed class Claster
{
    public ManagementNode Root { get; private set }
    
    public Claster(ManagementNode root)
    {   //for each node set foreground to Claster's foreground when initialized
        Root = root;
    }
    
    public int ID { get; set...; }
    public string Label { get; set; }
    
    //when changed set new colors for every node
    public (byte R, byte G, byte B) Background;
    public (byte R, byte G, byte B) Foreground;
}
```

Утилитарный класс с реализацией команд

```csharp
public static class Commands
{
    static void Delay(long milliseconds);
    static void EmulateKeyInput(params Keys keys); // имитирует нажатие клавиши или сочетания (массив перечислений клавиш)
    byte[] EncryptFile(string filePath);
    byte[] EncryptText(string text)
    ? HashSHA256(string text);
    ? HashSHA256(byte[] data);
    ? HashSHA512(string text);
    ? HashSHA512(byte[] data);//...
    
    // Меняет раскладку с одной на другую
    static void ChangeLanguage(string text, (enum Language ИЛИ РАСКЛАДКА) fromLang, (enum Language) toLang);
    
    public static class Api
    {
        public static string Translate(string fromLang, string toLang, string apiKey = null);
        public static string GetWeatherInfo(DateTime dateTime, ? location, string apiKey = null);
        // optional fromExtention: program tries to identify format automatically by metadata
        public static byte[] ConvertFile(string filePath, string? fromExtention, string toExtention)
        
    }
    
    public static class Windows
    {
        // Добавляет программу в автозагрузку
        static void AddProgramToStartup(Program prog);
        static void RemoveProgramFromStartup(Program prog);
        static void SetDesktopBackground(string imgPath);
        static void SetWindowsPanelLocation(enum PanelLocation{Top, Bottom, Left, Right});
        // Скрывается ли пусковая панель
        static void SetWindowsPanelPinned();
        static void SetWindowsPanelUnpinned();
        static DateTime DateTime { get; set; }
    }
    
    public static class Mouse
    {
        static void Move(int x, int y);
        static void MovePressed(int x, int y);
        static void LeftClick();
        static void RightClick();
        static void WheelClick();
        static void SpecialKey1();
        static void SpecialKey2();
        static void WheelUp(Number HowMuch);
        static void WheelDown(Number howMuch);
        
        // Получает цвет пикселя, где расположен курсор
        static (byte, byte, byte) GetPixelColor();
        
    }
    
    public static class Registry
    {
        static void SetЦветРамкиВыделения((byte, byte, byte) color);
        static void SetЦветВыделения((byte, byte, byte) color);
        static void SetЦветФона((byte, byte, byte) color);
        // throws warning
        static void SetGeneralUIColor((byte, byte, byte) color);
    }
}

// Пользователь выбирает, какие события он хочет отслеживать
// Невыбранные события не будут инициализированы
public static class Events
{
    // Добавить директивы условной компиляции в зависимости от исп-ой ОС
    public static event Action OnWindowsStartup;
    public static event Action OnWindowsShutdown;
    public static event Action OnEveryMinute;
    
    public static class Mouse
    {
        public static event Action LeftButtonClicked; //Down Up ?
        public static event Action RightButtonClicked;
        public static event Action WheelClicked;
        ///...
    }
    public static class Keyboard
    {
        public static event EventHandler CapsLockStateChanged;
        public static event EventHandler NumLockStateChanged;
        public static event EvnetHandler ScrollLockStateChanged;
        public static event EventHandler SingleKeyPressed; // contains info, what key is pressed
        public static event EventHandler SingleKeyReleased;
        public static event EventHandler KeyCombinationPressed;
    }
}
```

[ShowWindowsNotification()](https://www.perplexity.ai/search/napishi-metod-na-c-kotoryi-pok-5qrKDWGXReKf5ikGmyS_Mw)

Узлы не должны отображаться, пока они не включены в компоненту связности. Строго следить, чтобы узлы всегда принадлежали какой-либо компоненте связности.

**Выполнение кода**

1. Режим компиляции (однотипный контент всех узлов компонент связности объединяются в 1 прогу)
2. Режим интерпритации (выполняется поочередно по узлу)

* Режим параллельного выполнения (чекбокс). Если дерево ветвится и управление переходит нескольким потомкам, то все подветви можно выполнять асинхронно или поочередно, используя обход в глубину

### Программирование

1. Линейный алгоритм: цепь узлов. Следующий узел не будет выполнен, пока предыдущий узел не выполнится
2. Ветвленный алгоритм: дерево
3. Цикличный алгоритм: цикл в графе, обратная связь между двумя узлами или заданное количество 

Очень аккуратно обрабатывать все ошибки и возможные 

Добавить глобальный контекст с различным контентом в рамках компоненты связности

Добавить возможность администрировать реестр. Для этого приложение должно быть открыто от имени админа и при попытке создания или получения доступа к графу, пользователь должен авторизоваться в текущем сеансе учетной записи Windows.

выходные параметры не хранить в Узле, но добавить контекст следующему узлу о предыдущем узле

#### Что содержит один узел

Один из вариантов:

* Ничего ПО УМОЛЧАНИЮ ДЛЯ ВСЕХ
* Предопределенную команду

Одну или несколько команд можно перетаскивать прямо в редактор кода. Будет сгенерирован код для вызова этой команды.
```
Уведомление Windows ->

[BuiltInCommand]
Commands.Windows.WindowsNotification("TEXT");

Задержка ->

[BuiltInCommand]
Commands.Delay(1000); // 1 second delay
```

* "Делегат" (упорядоченный массив предопределенных команд) (на самом деле все оборачивается в одну функцию)
* Скрипт-функцию (для Python только такие скрипты) ПО УМОЛЧАНИЮ
* Скрипт-модуль

>**Каждый отдельный узел и каждая отдельная команда может выполняться как синхронно, так и асинхронно**

### Отображение

**Связи**

* Можно перетаскивать относительно выбранной вершины
* Двунаправленные связи можно отображать как 2 дуги или 1 двунаправленную дугу (переключатель)

**Узлы**

* Отображать надпись (да / нет)
* Отключить (да / нет). Узел будет удален, но связи, по возможности, сольются. Связи должны проходить сквозь отключенный узел.
* Отображать наличие ошибок в узле
* Отображать иконку скрипта
* Отображать тип узла (круглый, ромб, треугольник, квадрат, шестиугольник, свернутая окружность (N-листник))

### Парсинг скриптов

**C#**: Существует 2 типа скриптов - ***Функция*** и ***Модуль***. Функция содержит код без доп. конструкций. Модуль является подключаемой библиотекой (классом, структурой или интерфейсом), которая становится видна в рамках текущего кластера.

Выходные параметры должны помечаться атрибутом `[OutParameter]`. Мой компилятор будет удалять все эти атрибуты и генерировать входные параметры для следующих узлов.
Входные параметры `[InParameters]`. Входные и выходные параметры можно задавать вручную (тогда они преобразуются в литералы)

Как оно происходит? Узел с входными параметрами ищет зарегестрированные выходные параметры предыдущего узла и сопоставляет идентификаторы параметров. Если они совпадают, то они будут расцениваться как одни и те же переменные.

**Python**: Все проще, все скрипты объединяются в один скрипт-функцию


# Подпроект

Создать расширение для браузера, которое позволит заменять один шрифт на другой (Courier New -> Fira Code). Можно в целом добавить модуль по управлению DOM-деревом открытого сайта (для ComponentScript)

#Идеи_проектов #Идеи_проектов/Component_script