
Алгоритм создания службы:

- Создание проекта по шаблону
- Выпуск проекта как исполняемого файла или как динамической библиотеки
- Регистрация службы
- Запуск службы

----

Службы Windows — это специальные приложения, выполняющиеся в фоновом режиме под управлением Service Control Manager (SCM). В отличие от обычных приложений, они[2]:

Не имеют пользовательского интерфейса
Запускаются до входа пользователя в систему
Управляются через стандартные механизмы ОС

----

## 1. Через `installutil`

```batch
:: service installing
installutil <yourproject>.exe

:: service uninstalling
installutil /u[ninstall] <yourproject>.exe
```

## 2. Через `sc.exe`

```batch
::registration (installation)
sc.exe create <yourproject>.exe [binpath= "path\to\service"] [start= auto]

:: service starting
sc.exe start "ServiceName"

:: service closing
sc.exe stop "ServiceName"

:: service removing
sc.exe delete "ServiceName"
```

----

https://learn.microsoft.com/ru-ru/dotnet/core/extensions/windows-service
https://habr.com/ru/articles/863770/


Существует 2 API для разработки служб:

- Для .NET Framework
- **BackgroundService** для .NET Core (.NET 8.0+, OS Windows)

## ServiceBase

Служба Windows (.NET Framework) создаёт класс, наследник от **ServiceBase** в пространстве имен System.ServiceProcess. Прогеру предлагается  реализовать виртуальные методы базового класса OnStart и OnStop, которые задают действия, подлежащие выполнению при запуске (остановке) службы, что собственно и есть суть и назначение Службы Виндовз. Регистрация Службы в этом случае производится с помощью утилиты installUtil.exe, в .Net Core это делается утилитой SC.exe.

Реализовать службу на .NET Core (в моем случае .NET 9) не сложнее, но по другому, шаблон проекта теперь называется Worker Service (Microsoft), а рабочий класс наследуется от **BackgroundService**.

## BackgroundService Worker

Алгоритм создания службы BackgroundService:

1. Создание проекта по шаблону
2. Установка зависимостей (Nuget: `Microsoft.Extensions.Hosting.WindowsServices`)
3. Написание программы
4. Выпуск релиза
5. Установка службы через `sx.exe`

### Установка зависимостей

Нужно установить пакет `Microsoft.Extensions.Hosting.WindowsServices` через менеджер пакетов Nuget. При этом важно выбрать правильную версию, совместимую с версией .NET и C\#

Второй способ через CLI:

```cs
dotnet package add Microsoft.Extensions.Hosting.WindowsServices
```

После установки пакета, в XML файла `.csproj` должны появиться элементы:

```cs
<ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.7" />
    <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="9.0.7" />
</ItemGroup>
```

### Написание построителя приложения

```cs
using App.WindowsService;
using Microsoft.Extensions.Logging.Configuration;
using Microsoft.Extensions.Logging.EventLog;

HostApplicationBuilder builder = Host.CreateApplicationBuilder(args);
builder.Services.AddWindowsService(options =>
{
    options.ServiceName = ".NET Joke Service";
});

LoggerProviderOptions.RegisterProviderOptions<
    EventLogSettings, EventLogLoggerProvider>(builder.Services);

// Отдельный класс, который передается в конструктор Worker
// ????????????????????
builder.Services.AddSingleton<JokeService>();
builder.Services.AddHostedService<Worker>();

IHost host = builder.Build();
host.Run();
```

### Написание программы

Шаблон Worker Service:

```csharp
namespace Svc2;

public class Worker : BackgroundService {

    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {

        while (!stoppingToken.IsCancellationRequested) {
            var time = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            Console.WriteLine($"Worker running at: {time}");
            await Task.Delay(1000, stoppingToken);
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken) {
        // stopping logic...
    }
}
```

## Публикация проекта

Параметры публикации:

| Параметр | Значение |
| ---- | ---- |
| Configuration | `Release / Any CPU` |
| Target framework | `net8.0-windows` |
| Deployment mode | `Self-contained` |
| Targer runtime | `win-x64` |
| Target location | путь к каталогу с файлами публикации |
| Produce single file | Да |
| Enable ReadyToRun compilation | Да |
| Trim unused assemblies | Нет |

Создать публикацию можно простой командой:

```bash
dotnet publish --output "C:\custom\publish\directory"
```

https://learn.microsoft.com/en-us/dotnet/core/extensions/windows-service

With .NET 6, if you attempt to debug the app with the <PublishSingleFile>true</PublishSingleFile> setting, you will not be able to debug the app. For more information, see Unable to attach to CoreCLR when debugging a 'PublishSingleFile' .NET 6 app.

```bash
dotnet publish -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -p:EnableCompressionInSingleFile=true -p:IncludeNativeLibrariesForSelfExtract=true
```

> By default, regular (non-admin) users cannot manage Windows services. To verify that this app functions as expected, you'll need to use an Admin account.

To verify that the service is functioning as expected, you need to:

Start the service
View the logs
Stop the service

An alternative publishing approach is to build the *.dll (instead of an *.exe), and when you install the published app using the Windows Service Control Manager you delegate to the .NET CLI and pass the DLL. For more information, see [.NET CLI: dotnet command.](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)

```bash
sc.exe create ".NET Joke Service" binpath= "C:\Path\To\dotnet.exe C:\Path\To\App.WindowsService.dll"
```

Запуск службы

```bash
sc.exe start ".NET Joke Service"
```

Остановка службы

```bash
sc.exe stop ".NET Joke Service"
```

Удаление службы

```bash
sc.exe delete ".NET Joke Service"
```

To debug the application, ensure that you're not attempting to debug the executable that is actively running within the Windows Services process.

Класс Worker наследован от BackgroundService и наш проект запускается и работает как консольное приложение но это еще не служба. Чтобы сделать из него Windows Service надо добавить в зависимости пакет Microsoft.Extensions.Hosting.WindowsServices, это сделает наш  класс Worker способным реагировать на команды запуска и остановки сервиса через стандартную консоль.

Создание проекта [через CLI](https://learn.microsoft.com/ru-ru/dotnet/core/tools/dotnet-new-sdk-templates#web-others):

```bash
dotnet new worker --name <Project.Name>
```

Класс Worker изменим следующим образом, добавим кое что

```csharp
namespace Svc2;

public class Worker : BackgroundService {
    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {
        // Service started
    }

    public override async Task StopAsync(CancellationToken cancellationToken) {
        // Service stoped
        await base.StopAsync(cancellationToken);
    }
}
```

Собственно код для сервиса у нас готов, теперь надо его выложить куда то, где он будет работать, то есть Опубликовать (Publish) наш проект.

Для того, Чтобы наш сервис был виден в Консоли Управления Службами Windows воспользуемся утилитой SC.EXE. Откроем окно командной строки под админской учеткой и выполним следующую команду: 

```batch
sc.exe create "AM Telebot" binPath=D:\Projects\CoreService\_pub\Svc2.exe
```

Отлично, полный успех, теперь смотрим что у нас в консоли управления службами.

И таки да, наш AM Telebot появился в списке служб. Тут уже, в свойствах Службы, можно поменять ему пользователя и тип запуска, например на Автомат, Чтобы сам запускался при перезагрузке сервера. Еще можно задать режим восстановления при непредвиденной ошибке и падении, в общем там есть полезные настройки.

Кстати, для удаления службы используем ту же утилиту SC.exe с опцией delete и указав имя службы, вот так.

```batch
sc.exe delete "AM Telebot"
```

#Dotnet #Dotnet/Applications
