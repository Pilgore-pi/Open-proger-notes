> Обобщенные типы в ООП — это способ описать множество однотипных сущностей, у которых отличаются определенные параметры, но при этом эти параметры должны обрабатываться одинаково. То есть может существовать абстрактный параметр типа `T`, который требует унифицированной обработки, которая учитывает все возможные состояния этого параметра

> **Обобщеным типом** в .NET называется тип, для которого определен полиморфный параметр на уровне этого типа. Значением параметра может быть один представитель из множества допустимых типов, например `int`, `string` и так далее

Обобщенными в .NET могут быть:

* Классы
* Структуры
* Методы
* Свойства
* Интерфейсы
* Делегаты

## Ограничения обобщенных параметров

> Ограничения универсальных параметров позволяют писать более чистый и предсказуемый код, что упрощает разработку программы и уменьшает вероятность ошибок

**Синтаксис:**

```csharp
class MyGeneric<T> where T: <restriction>, <restriction>, ...
```

| Ограничение | Допустимые типы |
| :-- | :-- |
| `where T : class` | ссылочный тип, не поддерживающий `null`: `class`, `Array`, `interface`, `delegate`, `record` |
| `where T : class?` | аналогичено ограничению `class`, но обобщенный параметр поддерживает значение `null`. Другими словами, `class = Nullable<C> where C: class` |
| `where T : struct` | любая структура (значимый тип), не поддерживающая `null`, в том числе `struct record`; несовместимо с ограничением `unmanaged` |
| `where T : notnull` | любой тип, не поддерживающий `null`, это может быть структура или ссылочный тип. Другими словами, `notnull = class + struct` |
| `where T : new()` | требование, обязывающее тип `T` иметь открытый конструктор без параметров. Данное ограничение должно быть указано последним в списке ограничений |
| `where T : <ClassName>` | тип `T` должен представлять или наследовать указанный класс |
| `where T : <ClassName>?` | аналог `<ClassName>` с поддержкой значений `null` |
| `where T : <InterfaceName>` | тип `T` должен представлять или реализовывать указанный интерфейс |
| `where T : <InterfaceName>?` | аналог `<InterfaceName>` с поддержкой значений `null` |
| `where T : U` | параметр `T` должен быть из семейства `U` |
| `where T : default` | [see about](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/unconstrained-type-parameter-annotations#default-constraint) Используется для обратной совместимости с устаревшим кодом, который не поддерживает явные ограничения обобщенных параметров |
| `where T : unmanaged` | неуправляемый тип, не поддерживающий `null`. Данное ограничение подразумевает использование ограничения `struct` |
| `where T : allows ref struct` | параметр `T` **может** представлять `ref struct` (структуру, принудительно размещаемую на стеке). Обобщенные типы и методы с таким параметром должны соответствовать ограничениям использования `ref struct` |

### Ограничения применения ограничений

- Допускается использование только одного из следующих ограничений: `struct`, `class`, `class?`, `notnull`, `unmanaged`. Все перечисленные виды ограничений должны указываться первыми в списке ограничений

- Ограничения по базовому классу `where T : Base` `where T : Base?` не могут совмещаться с этими ограничениями: `struct`, `class`, `class?`, `notnull`, `unmanaged`

- Ограничение по базовому классу может быть только одно в списке ограничений

- Ограничение `new()` не может совмещаться с ограничениями `struct` или `unmanaged`. Если указывается `new()`, то оно должно быть последним в списке ограничений

- Ограничение `default` может применяться только для реализаций интерфейса. Ограничение можно совмещать с `struct` или `class`

- Ограничение `allows ref struct` не совместимо с `class` или `class?`

* Ограничение `notnull` имеет смысл только при включенном контексте `null`. При нарушении этого ограничения ошибки не возникает, возникает предупреждение

```csharp
class Жырнич<T> where T : IEnumerable<int>, new() {}
```

```csharp
class Жырнич<T, B> where T : new() where B : class {}
```

```csharp
class GenericMethod<T>(T a, T b) where T : struct {}

class RefStructGeneric<T, S>
    where T : allows ref struct
    where S : T
{
    // etc
}
```

[[02 Совместимость обобщений|Далее: Совместимость обобщений]]

#C-Sharp #OOP #OOP/Generics #C-Sharp/Generics
