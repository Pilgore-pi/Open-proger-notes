
## Сопоставление свойств. Атрибуты DataAnnotations

```cs
using System.......
```

По умолчанию, все публичные свойства с геттером и сеттером включаются в Модель данных EF Core
По умолчанию, имена колонок SQL совпадают со свойствами сопоставляемых классов
По умолчанию, все текстовые атрибуты закодированы в Unicode
По умолчанию (`#nullable enable`), свойства, допускающие значение `null` считаются необязательными (`string?`, `int?`). Свойства, не допускающие `null` считаются обязательными (`string`, `int`). Если `#nullable disable`, то все ссылочные типы, которые могут хранить значение `null` считаются необязательными

[__1__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes)
[__2__](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/navigations?source=recommendations)
[One-to-one relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-one?source=recommendations)
[One-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-many?source=recommendations)
[Many-to-many relations](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/many-to-many?source=recommendations)

| Аннотация | Область применения| Описание |
|--------------------|-------------------|----------|
| `[NotMapped]` | Объект, свойство | Исключает свойство из модели данных EF Core |
| `[Table(name)]` | Свойство | Задает имя соответствующей SQL таблицы |
| `[Column(propName)]` | Свойство | Явно задает сопоставляемое имя атрибута SQL |
| `[Column(Order = index)]` | Свойство | Задает порядок атрибута в таблице SQL |
| `[Key]` | Свойство | Объявляет текущее свойство как первичный ключ |
| `[PrimaryKey(propertyList)]` | Объект | Объявляет первичный ключ для объекта. В атрибут передаются все имена свойств, формирующих составной или простой первичный ключ |
| `[ForeignKey(propName)]` |  |  |
| `[Keyless]` | Объект | Говорит о том, что объект не содержит ключей |
| `[Range(min, max)]` |  | Определяет диапазон допустимых значений |
| `[Precision(precision, scale)]` | Свойство | Определяет разрядность числового свойства |
| `[MinLength(value)]` |  | Указывает минимальную допустимую границу значений. Большинство БД поддерживают это ограничение для типов SQL `decimal`, `DateTime` |
| `[MaxLength(value)]` |  | Указывает максимальную допустимую границу значений |
| `[Required]` |  | Аналог SQL `NOT NULL`. Не имеет эффекта, если применять к Non-nullable типам |
| `[Index(propName)]` | Объект | Объявляет индекс БД. Индекс может быть простым (1 свойство) или составным (более 1 свойства)  |
| `[DatabaseGenerated(enum)]` | Свойство | Указывает на то, что значение текущего свойства должно генерироваться автоматически. В атрибут передается перечисление `enum DatabaseGeneratedOption {`</br>`    None = 0, // База данных не создает значений`</br>`    Identity = 1, // База данных создает значение при вставке строки`</br>`    Computed = 2 // База данных создает значение при вставке или обновлении строки`</br>`}` |
| `[Unicode(flag)]` | Свойство (текстовое) | Определяет, будет ли применяться кодировка Unicode к текстовому свойству |
| `[Comment(commentString)]` | Объект, свойство | Задает комментарий для колонки таблицы SQL на уровне схемы |
| `[RegularExpression(pattern)]` | Свойство, поле, параметр | Задает валидацию на основе регулярного выражения. Валидация пропускается, если атрибут `Required` не применяется и строка равна `string.Empty` или `null` |

## Ограничения целостности

```cs
public class Blog
{
    public int BlogId { get; set; }

    [Column(TypeName = "varchar(200)")]
    public string Url { get; set; }

    [Column(TypeName = "decimal(5, 2)")]
    public decimal Rating { get; set; }
}
```

## Первичные ключи

> Согласно общепринятой конвенции, свойства объектов, которые имеют имя `Id` или `<propertyName>Id` воспринимаются как первичные ключи

> По умолчанию, значения первичных ключей генерируются автоматически, но можно явно настроить способ генерации ключей через атрибут `[DatabaseGenerated()]`

```cs
internal class Car
{
    public string Id { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

internal class Truck
{
    public string TruckId { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

```cs
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

## Внешние ключи

### Как правильно задать внешний ключ из таблицы Cell, ссылающийся на таблицу CellModifier:
  

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    [ForeignKey(nameof(Modifier))]
    public CellModifier? Modifier { get; set; }
}

public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // status
    
    [Range(0, double.MaxValue)]
    public          double Work  { get; set; }
}
```

Правильное задание внешнего ключа в EF Core предполагает наличие в зависимой сущности (в твоём случае — `Cell`) отдельного свойства для хранения значения внешнего ключа, которое ссылается на первичный ключ связанной сущности (`CellModifier`), а также навигационного свойства для удобства работы с объектом.

В твоём примере класс `Cell` содержит навигационное свойство `Modifier` типа `CellModifier`, но нет свойства, которое бы хранило значение внешнего ключа (например, `ModifierTitle`), ссылающееся на ключ `Title` в `CellModifier`.

## Как правильно задать внешний ключ

1. Добавь в класс `Cell` свойство для внешнего ключа, совпадающее по типу с ключом в `CellModifier`:

```cs
public sealed class Cell {
    
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }  // внешний ключ
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

  

2. В классе `CellModifier` ключ `Title` уже определён:

```cs
public sealed class CellModifier {
    
    [Key, MinLength(1)]
    public required string Title { get; set; } // первичный ключ
    
    [Range(0, double.MaxValue)]
    public double Work { get; set; }
}
```

3. EF Core по соглашению сопоставит `ModifierTitle` как внешний ключ, ссылающийся на `Title` в `CellModifier`.

4. При необходимости можно дополнительно настроить связь в методе `OnModelCreating`:

```cs
modelBuilder.Entity<Cell>()
    .HasOne(c => c.Modifier)
    .WithMany() // или .WithMany(m => m.Cells), если навигация есть и в CellModifier
    .HasForeignKey(c => c.ModifierTitle)
    .HasPrincipalKey(m => m.Title);
```


  ### Почему так
  

- Внешний ключ — это обычно скалярное свойство (например, `string`, `int`), которое хранит значение ключа связанной сущности.

- Навигационное свойство (`Modifier`) — это объект, позволяющий работать с объектом `CellModifier` напрямую.

- Атрибут `[ForeignKey(nameof(ModifierTitle))]` указывает, что `ModifierTitle` — внешний ключ для навигационного свойства `Modifier`.

- Если не добавить отдельное свойство для внешнего ключа, EF Core не сможет корректно сопоставить связь и сгенерирует ошибку или создаст теневой внешний ключ, что усложнит работу.

### Итог

Твой исправленный класс `Cell` должен выглядеть так:

```cs
public sealed class Cell {
    [Key]
    public DateOnly Date { get; set; }
    
    public string? ModifierTitle { get; set; }
    
    [ForeignKey(nameof(ModifierTitle))]
    public CellModifier? Modifier { get; set; }
}
```

Это классический и правильный способ задания внешнего ключа в EF Core[^1][^2][^5].

#DB #Dotnet #Dotnet/EntityFramework

[^1]: https://metanit.com/sharp/entityframeworkcore/3.1.php
[^2]: https://learn.microsoft.com/ru-ru/ef/core/modeling/relationships/foreign-and-principal-keys
[^3]: https://learn.microsoft.com/ru-ru/ef/core/change-tracking/relationship-changes
[^4]: https://www.reddit.com/r/dotnet/comments/1da6vvb/foreign_keys_in_ef_core_8/?tl=ru
[^5]: https://metanit.com/sharp/efcore/3.1.php
[^6]: https://dir.by/developer/entity_framework/foreign_key/?lang=rus%3Ffknohdjecbaiekfk
[^7]: https://ru.stackoverflow.com/questions/628915/Не-понимаю-как-расставить-внешние-ключи-entity-framework
[^8]: https://andrey.moveax.ru/post/mvc3-in-depth-entity-framework-03-code-first-conventions
