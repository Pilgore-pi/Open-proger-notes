
# Установка значения для get-only свойства в конструкторе

Свойства в C# позволяют управлять доступом к полям класса, предоставляя механизм для чтения и записи значений. Они выглядят как поля, но, на самом деле, одно свойство — это пара методов: `get` и `set`, которые позволяют контролировать доступ к данным

> Свойство состоит из метода доступа **`get`** и метода изменения **`set`**. Эти методы называются **аксессорами**

Для каждого свойства **всегда** определяется соответствующее поле (в единственном числе). Поле может определяться явно или скрыто компилятором

- **Имя свойства** — должно быть осмысленным и обычно пишется с заглавной буквы.
- **Тип свойства** — определяет тип данных, которые свойство может хранить.
- **Геттер (get)** — метод, который возвращает значение свойства
- **Сеттер (set)** — метод, который устанавливает значение свойства

Синтаксис полного свойства

```cs
private <return_type> my_field;
public <return_type> MyProperty {
    get { return my_field; }
    set { my_field = value; }
}

public <return_type> MyProperty {
    get => my_field;
    set => my_field = value;
}
```

> **Контекстное ключевое слово `value`** представляет собой входной (`in`) параметр того же типа, что и тип свойства

```cs
internal class Employee {

    // "backing-field" — "фоновое" поле для свойства PhoneNumber
    private string _phoneNumber;
    
    // Свойство "Номер телефона"
    public string PhoneNumber {
        get => _phoneNumber;
        set {
            bool matches = SimplePhoneNumberRegex().IsMatch(value);
            if (matches is false) throw new ArgumentException($"Phone number \"{value}\" doesn't match the regular expression");

            _phoneNumber = value;
        }
    }

    // Свойство "Полное имя"
    public string FullName { get; set; }
}
```

> Вызов метода `get` происходит при получении значения свойства или передаче свойства в метод

> Вызов метода `set` происходит при использовании оператора `=`, где левым операндом является свойство, а правым — совместимый по типу объект

```cs
var emp = new Employee();

// Вызов аксессора set у свойства FullName
emp.FullName = "Anna Javana";

// Вызов аксессора set у свойства PhoneNumber
emp.PhoneNumber = "89008004545";

// Вызов аксессора get у свойства PhoneNumber
var number = emp.PhoneNumber;

// Вызов аксессора get у свойства emp.FullName
Console.WriteLine($"Employee. name: {emp.FullName}; phone: {number}");
```

## Модификаторы доступа для аксессоров

1) Модификатор может применятся только для одного из аксессоров
2) Модификатор аксессора должен быть **более ограничивающим**, чем модификатор доступа свойства

Свойство может не иметь один из аксессоров

## Автоматические свойства

C# позволяет создавать свойства без явного объявления полей. Компилятор автоматически создает скрытое поле для хранения значения

```csharp
public class Person {
    public string Name { get; set; } // автоматическое свойство
}
```

**Один** из аксессоров (геттер или сеттер) может отсутствовать, соответственно свойство будет *read only* (только для чтения) или *write only* (только для записи)

К аксессорам можно применять различные модификаторы доступа, например, можно сделать какое-то свойство только для чтения снаружи класса, а внутри сам определяющий класс имеет полный доступ (`public int Property { get; private set; }`)

```csharp
public int Age
{
    get => age; // сокращенный синтаксис
    set {
        if (value < 0)
            throw new ArgumentException("Age cannot be negative");
        age = value;
    }
}
```

```csharp
public class Person
{
    private string name;
    
    public string Name
    {
        get => name;
        set => name = value; // контекстное ключевое слово
    }
}
```

`value` — это значение, которое было помещено в свойство при присваивании

## Инициализаторы объектов

C# позволяет инициализировать свойства при создании объекта

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

var person = new Person { Name = "John", Age = 30 };
```

Можно задавать значения по умолчанию:

```csharp
public class Person {
    public string Name { get; set; } = "Unknown";
}
```

## Свойства, инициализируемые один раз

```csharp
public class Person {
    public string Name { get; init; }
}

var person = new Person { Name = "Dude" };
person.Name = "Dawg"; // Ошибка компиляции
```

## Внутренние механизмы компиляции свойств

### Генерация имен

При компиляции свойства C# аксессоры get и set преобразуются в методы с именами, которые формируются следующим образом:

- Для аксессора get метод будет иметь имя: `get_<ИмяСвойства>`

- Для аксессора set метод будет иметь имя: `set_<ИмяСвойства>`

Например, если есть свойство

```cs
private int _fullProperty;

public int FullProperty {
    get => _fullProperty;
    set => _fullProperty = value;
}
```

Для этого свойства компилятор создаст два метода:

- `int get_FullProperty()`
- `void set_FullProperty(int value)` МОДИФИКАТОР VALUE?????

Эти методы являются скрытыми и используются при обращении к свойству напрямую в IL-коде и во время выполнения

У автосвойств есть скрытые поля, для которых, также, генерируется имя

```cs
public int AutoProperty { get; set; }
```

Сгенерированное имя:

```text
AutoPropertyk__BackingField
```

#C-Sharp #OOP
