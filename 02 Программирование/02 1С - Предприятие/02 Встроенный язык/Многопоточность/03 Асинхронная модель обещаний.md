
Использование методов обратного вызова усложняет программный код, делает его фрагментированным, сложным для восприятия и доработки. Синхронный код, в котором выполняемые команды расположены последовательно, друг за другом, создается и анализируется гораздо проще.

По этой причине разработчики создали более современную асинхронную модель на основе понятия обещаний. В других языках программирования они называются `promise`, `future`, `task`

Похожий подход был реализован фирмой “1С” в платформе 8.3.18

Важно отметить, что сам принцип использования асинхронности в платформе остался прежним. По-прежнему асинхронность доступна для работы с блокирующими окнами, файлами и каталогами, механизмами криптографии и внешними компонентами. Изменился только “внешний вид” программного кода, другими словами – способ указания платформе, какой именно код нужно выполнить после завершения асинхронного метода. Главная задача нововведения – приблизить асинхронный код к обычному последовательному коду, уменьшить сложность разработки.

## Обещания

В платформе 8.3.18 появился новый тип данных – Обещание. Объект такого типа предназначен для организации асинхронного кода.

>***Обещание*** — это контейнер, который содержит в себе значение некоторого типа. Предполагается, что в будущем `Обещание` вернет результат, но это не гарантировано.

Например, существует обещание: "получить данные из БД". Такое "Обещание" говорит, что после выполнения операции получения данных из БД, мы сможем использовать результат обещания, но пока запрос к БД не выполниться, мы будем ждать результата, параллельно выполняя основную логику программы.

Существует 3 исхода выполнения асинхронной функции:

1. Мы **дождались** выполнения асинхронного метода и получили результат.
2. Мы **ждем** выполнения асинхронного метода и не получили результат, так как метод все еще выполняется. Возможно, асинхронный метод будет выполняться бесконечно.
3. Мы **не дождались** результата, так как асинхронный метод завершился с ошибкой (вернул `Неопределено`).

Как можно понять, нельзя всегда гарантированно получить результат, поэтому был введен тип `Обещание`, который обрабатывает такую логику и допускает все перечисленные состояния.

Оператор `ждать` может быть использован только внутри асинхронного метода. Этот оператор говорит, что нужно остановить выполнение кода и ждать до тех пор, пока `Обещание` не вернет значение. Если не использовать `ждать`, то ожадания не будет и код продолжит свое выполнение.

Асинхронный метод выполняется в фоновом потоке параллельно с основным. В версии 8.3.18 был добавлен специальный синтаксис:

```bsl
Асинх Процедура ИмяПроцедуры(<параметры>) //async
    [ждать] <Обещание>;                   //await
КонецПроцедуры

Асинх Функция ИмяФункции(<параметры>)
    возврат <Значение>;
КонецФункции
```

Фактически **Обещание** является заменой объекта `ОписаниеОповещения`.
При использовании асинхронности с методами обратного вызова в этом объекте указывается, какую процедуру нужно выполнить после завершения асинхронного метода. Результат выполнения асинхронного метода будет содержаться в параметре метода обратного вызова. При использовании асинхронности через обещания результат асинхронной функции будет содержаться именно в объекте типа **Обещание**.

> Объект типа **Обещание** доступен только в клиентском контексте: в тонком, толстом, мобильном клиентах и в веб-клиенте. На сервере этот объект недоступен. Это связано с тем, что асинхронные методы во встроенном языке создавались для использования только на клиенте

Объект Обещание не имеет конструкторов, методов и свойств. Объект такого типа можно получить во встроенном языке только в качестве результата вызова асинхронной функции.
Далее Обещание можно использовать в качестве аргумента оператора Ждать, чтобы получить результат выполнения асинхронной функции

> В новой асинхронной модели также существует конвенция именования асинхронных методов: их имена должны заканчиваться на "Асинх"

```bsl
Вопрос(            // Синхронный вариант
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);

ПоказатьВопрос(    // Асинхронный Callback-вариант
    <ОписаниеОповещенияОЗавершении>,
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);

ВопросАсинх(       // Асинхронный Promise-вариант
    <ТекстВопроса>,
    <Кнопки>,
    <Таймаут>,
    <КнопкаПоУмолчанию>,
    <Заголовок>,
    <КнопкаТаймаута>
);
```

Синхронный метод и асинхронный метод с обещанием являются функциями, а метод `ПоказатьВопрос()` является процедурой

Не для всех синхронных методов реализованы аналогичные функции с модификатором Асинх. Например, для метода формы ОткрытьМодально соответствующая асинхронная функция не существует. Поэтому следует использовать процедуру ОткрытьФорму с указанием обработчика оповещения:

```bsl
&НаКлиенте
Процедура ВыбратьНоменклатуру(Команда)
    
    ОписаниеОповещения = Новый ОписаниеОповещения(
        "ОткрытиеФормыЗавершение",
        ЭтотОбъект
    );
    
    ОткрытьФорму(
        "Справочник.Номенклатура.ФормаВыбора", , , , , ,
        ОписаниеОповещения,
        РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
    
КонецПроцедуры

&НаКлиенте
Процедура ОткрытиеФормыЗавершение(РезультатЗакрытия, ДополнительныеПараметры) Экспорт
    //Обработка результата...
КонецПроцедуры
```

